<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">

    

    
    <title>[Android] Compose | VictoryWoo</title>
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
        <meta name="keywords" content="Android,Jetpack,Compose">
    
    <link rel="stylesheet" href="https://cdn.rawgit.com/innks/NanumSquareRound/master/nanumsquareround.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theeluwin/NotoSansKR-Hestia@master/stylesheets/NotoSansKR-Hestia.css">
    <meta name="description" content="왜??선언적 프로그래밍이 UI 프로그래밍에 있어서 부상하고 있는 이유는 갈수록 복잡해지고 다양해지는 UI/UX 때문이라고 할 수 있다. 특히 애니메이션 같은 부분은 명령형으로 처리하기 매우 까다롭다.  가장 중요한 뷰의 상태라는 것에만 신경쓰고, 상세한 부분들은 프레임워크가 알아서 해주기를 기대하는 것이다. 기존의 안드로이드 UI 시스템에는 다음과 같은 문">
<meta name="keywords" content="Android,Jetpack,Compose">
<meta property="og:type" content="article">
<meta property="og:title" content="[Android] Compose">
<meta property="og:url" content="http://victorywoolee/victorywoolee.github.io/2019/10/05/Android-Compose/index.html">
<meta property="og:site_name" content="VictoryWoo">
<meta property="og:description" content="왜??선언적 프로그래밍이 UI 프로그래밍에 있어서 부상하고 있는 이유는 갈수록 복잡해지고 다양해지는 UI/UX 때문이라고 할 수 있다. 특히 애니메이션 같은 부분은 명령형으로 처리하기 매우 까다롭다.  가장 중요한 뷰의 상태라는 것에만 신경쓰고, 상세한 부분들은 프레임워크가 알아서 해주기를 기대하는 것이다. 기존의 안드로이드 UI 시스템에는 다음과 같은 문">
<meta property="og:locale" content="en">
<meta property="og:updated_time" content="2019-10-06T13:21:00.377Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Android] Compose">
<meta name="twitter:description" content="왜??선언적 프로그래밍이 UI 프로그래밍에 있어서 부상하고 있는 이유는 갈수록 복잡해지고 다양해지는 UI/UX 때문이라고 할 수 있다. 특히 애니메이션 같은 부분은 명령형으로 처리하기 매우 까다롭다.  가장 중요한 뷰의 상태라는 것에만 신경쓰고, 상세한 부분들은 프레임워크가 알아서 해주기를 기대하는 것이다. 기존의 안드로이드 UI 시스템에는 다음과 같은 문">
    

    
        <link rel="alternate" href="/" title="VictoryWoo" type="application/atom+xml">
    

    

    <link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="/libs/titillium-web/styles.css">
    <link rel="stylesheet" href="/libs/source-code-pro/styles.css">

    <link rel="stylesheet" href="/css/style.css">

    <script src="/libs/jquery/3.3.1/jquery.min.js"></script>
    
    
        <link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">
    
    
        <link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">
    
    
    


</head>
</html>
<body>
    <div id="wrap">
        <header id="header">
    <div id="header-outer" class="outer">
        <div class="container">
            <div class="container-inner">
                <div id="header-title">
                    <h1 class="logo-wrap">
                        <a href="/" class="logo"></a>
                    </h1>
                    
                        <h2 class="subtitle-wrap">
                            <p class="subtitle">VictoryWoo&#39;s Blog</p>
                        </h2>
                    
                </div>
                <div id="header-inner" class="nav-container">
                    <a id="main-nav-toggle" class="nav-icon fa fa-bars"></a>
                    <div class="nav-container-inner">
                        <ul id="main-nav">
                            
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/">Home</a>
                                </li>
                            
                                        <ul class="main-nav-list"><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Android/">Android</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Clean-Code/">Clean Code</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/ETC/">ETC</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Git/">Git</a></li><li class="main-nav-list-item"><a class="main-nav-list-link" href="/categories/Kotlin/">Kotlin</a></li></ul>
                                    
                                <li class="main-nav-list-item" >
                                    <a class="main-nav-list-link" href="/about/index.html">About</a>
                                </li>
                            
                        </ul>
                        <nav id="sub-nav">
                            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search" />
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..." />
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>
<script src="/js/insight.js"></script>

</div>
                        </nav>
                    </div>
                </div>
            </div>
        </div>
    </div>
</header>
        <div class="container">
            <div class="main-body container-inner">
                <div class="main-body-inner">
                    <section id="main">
                        <div class="main-body-header">
    <h1 class="header">
    
    <a class="page-title-link" href="/categories/Android/">Android</a>
    </h1>
</div>

                        <div class="main-body-content">
                            <article id="post-Android-Compose" class="article article-single article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
            <header class="article-header">
                
    
        <h1 class="article-title" itemprop="name">
        [Android] Compose
        </h1>
    

            </header>
        
        
            <div class="article-meta">
                
    <div class="article-date">
        <a href="/2019/10/05/Android-Compose/" class="article-date">
            <time datetime="2019-10-05T08:07:49.000Z" itemprop="datePublished">2019-10-05</time>
        </a>
    </div>

		

                
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link" href="/tags/Android/">Android</a>, <a class="tag-link" href="/tags/Compose/">Compose</a>, <a class="tag-link" href="/tags/Jetpack/">Jetpack</a>
    </div>

            </div>
        
        
        <div class="article-entry" itemprop="articleBody">
            <h2 id="왜"><a href="#왜" class="headerlink" title="왜??"></a>왜??</h2><p>선언적 프로그래밍이 UI 프로그래밍에 있어서 부상하고 있는 이유는 갈수록 복잡해지고 다양해지는 UI/UX 때문이라고 할 수 있다. 특히 애니메이션 같은 부분은 명령형으로 처리하기 매우 까다롭다. </p>
<p>가장 중요한 <strong>뷰의 상태</strong>라는 것에만 신경쓰고, 상세한 부분들은 프레임워크가 알아서 해주기를 기대하는 것이다.</p>
<p>기존의 안드로이드 UI 시스템에는 다음과 같은 문제가 있다.</p>
<ol>
<li>안드로이드 프레임워크와 강하게 묶여있다.</li>
</ol>
<p>안드로이드에서 제공하는 다양한 라이브러리들은 각자 버전이 따로 업데이트 된다. 그리고 개발자들은 다른 라이브러리를 신경쓰지 않고 필요한 버전만 해당 라이브러리에 적용해서 사용할 수 있다.</p>
<p>반면에, UI는 SDK와 함께 버전업이 되기 때문에 새로운 기능을 사용하려면 SDK를 함께 업데이트해야 한다. 하지만, SDK에는 UI만 있는게 아니기 때문에 버전을 올리기가 쉽지 않다. 예를 들면, 마시멜로에서 생긴 권한 체크가 그 중 한가지이다. </p>
<ol start="2">
<li>복잡한 코드와 클래스 구조</li>
</ol>
<p>View.java의 소스는 거의 3만줄에 육박한다. 그만큼 복잡하며 길다. 그리고 특정 뷰에 어울리지 않는 동작들이 있다. 예를 들면, Button이 TextView의 속성을 그대로 가지고 있다. 그래서 버튼 안의 텍스트를 선택하거나 수정하는 등의 동작이 가능하다. 설명 영상에서는 이를 API Regret이라고 표현했다.</p>
<ol start="3">
<li>너무 많은 코드</li>
</ol>
<p>커스텀 뷰를 작성하게 된다면 작성해야 하는 파일이 많다. 새로운 속성을 추가하기 위해서는 접근해야 하는 곳이 많다. </p>
<ul>
<li>CustomView.kt</li>
<li>layout.xml</li>
<li>attrs.xml</li>
<li>styles.xml</li>
</ul>
<p>이렇게 커스텀 뷰에 대해서 분산되어 있는 코드로 인해 수정과 유지보수를 위한 비용이 많이 든다. </p>
<ol start="4">
<li>일관되지 않은 데이터 흐름<br>MVP, MVVM, MVI 등의 프론트엔드 아키텍처는 <code>데이터 흐름을 일관되게 유지하는 것</code>을 목적으로 하고 있다고 할 수 있다. 이러한 아키텍처들은 대부분 뷰에 상태를 두지 않고, 뷰의 변화를 관찰하는 개체가 뷰의 상태를 관리한다. 이를 통해서 데이터의 흐름이 한 방향으로 흐르도록 할 수 있다.</li>
</ol>
<p>반면, 안드로이드 UI 시스템은 이러한 아키텍처들과는 다소 상반되는 구조를 가지고 있다. 안드로이드의 뷰들은 각자만의 상태를 가지고 있고, 스스로 상태를 제어한다. 이렇다보니 코드를 깔끔하게 만들지 않는다면 UI를 구현할 때나 디버깅을 할 때 힘들다.</p>
<h2 id="목표"><a href="#목표" class="headerlink" title="목표??"></a>목표??</h2><p>위에서 봤듯이 꽤 큰 문제들이 있다. Compose는 이러한 문제를 어떻게 해결할 수 있을까?</p>
<ol>
<li>SDK와 UI를 분리</li>
</ol>
<p>SDK와 UI를 분리함으로써 서로 의존성을 갖지 않게 하여 UI를 업데이트하는데 편리함을 갖게 될 수 있다.</p>
<ol start="2">
<li>재사용 가능하고 간단한 View 구조</li>
</ol>
<p>불필요한 상속을 없애고, 보일러플레이트 코드를 제거하는 것을 목표로 한다. 재사용 가능하고 작성한 대로 출력되는 직관적인 UI 코드를 작성하는 것이 목표다.</p>
<ol start="3">
<li>적은 코드</li>
</ol>
<p>커스텀 뷰를 작성할 때처럼 layout, attr, style과 같은 파일로 분산시켜 작성하는 것에서 하나의 UI 코드를 작성함으로써 수정 및 유지보수의 비용을 줄일 수 있다.</p>
<ol start="4">
<li>하나의 데이터 흐름</li>
</ol>
<p>State는 하나의 Owner만 갖으며, 하나의 Owner만 State를 변경한다. Owner가 이벤트를 감지하고 변경을 주도한다.</p>
<h2 id="Compose"><a href="#Compose" class="headerlink" title="Compose??"></a>Compose??</h2><p><strong>1. UI 작성을 위한 선언적 방법</strong></p>
<ul>
<li>Jetpack에 포함된 Compose는 UI 개발을 단순화하도록 설계된 번들 툴킷이다.</li>
<li>반응형 프로그래밍 모델과 Kotlin 프로그래밍 언어의 간결함 및 사용 편의성을 결합한다.</li>
<li>주의해야할 점은 Compose가 아직 초기 알파 단계 버전이기 때문에 실제 프로덕션에 사용하는 것을 권장하지는 않는다.</li>
</ul>
<p><strong>2. 핵심 원칙</strong></p>
<ul>
<li>Concise and Idiomatic Kotlin(간결하고 관용적인 코틀린)</li>
</ul>
<p>코틀린이 제공하는 이점으로 간결하고 안전하며 Java 언어와 완벽하게 상호 운용된다. 작성해야 하는 상용구 코드의 양을 대폭 줄이도록 설계되어 앱 코드에 집중하고 전체 클래스의 오류를 피할 수 있다.</p>
<ul>
<li>Declarative(선언적)</li>
</ul>
<p>레이아웃을 그리는 것부터 생성을 포함해서 UI 구성 요소를 정의하는데 선언적인 방법을 사용한다. UI를 컴포저블 함수로 표현하면 프레임워크는 뷰 계층에 대한 자동 업데이트를 하고 UI 최적화를 처리한다.</p>
<ul>
<li>Compatible(호환)</li>
</ul>
<p>기존의 View와 호완되므로 모든 Android 및 Jetpack API에 직접 접근해 원하는대로 혼합시키고 일치시킬 수 있다.</p>
<ul>
<li>Enable Beautiful Apps(아름다운 앱 사용)</li>
</ul>
<p>처음부터 Material Design과 애니메이션으로 설계되어 모션이 가득한 멋진 앱을 만들 수 있다.</p>
<ul>
<li>Accelerate Development(개발 가속화)</li>
</ul>
<p>적은 코드를 작성하고 Apply Changes 및 라이브 미리보기와 같은 도구를 사용해 개발을 가속화할 수 있다.</p>
<p><strong>3. 핵심적인 아이디어</strong></p>
<ul>
<li><code>UI as a function</code></li>
</ul>
<p>어떤 입력을 받아 결과를 반환하는 함수의 아이디어를 UI로 확장해서 <strong>어떤 입력을 받아 UI 구조를 반환하는 함수</strong>라고 생각하면 된다.</p>
<p>함수는 어떠한 상태도 가지고 있지않고, 외부의 어떤 상태도 변경해서는 안된다. 그저 자신이 그려야할 UI의 계층을 반환할 뿐이다. -&gt; 순수함수</p>
<p>또한, Kotlin의 함수로 UI를 표현하기 때문에 XML에서는 불가능한 프로그래밍 언어의 다양한 기능을 UI를 작성하는데 활용할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Greeting</span><span class="params">(name: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    Text(<span class="string">"Hello <span class="variable">$name</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Composable is composable</code></li>
</ul>
<p>Compose의 UI 위젯을 사용하기 위해서는 <strong>@Composable</strong> 어노테이션을 붙여줘야 한다. 그리고 이 함수는 다른 Composable 함수를 포함할 수 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">Greeting</span><span class="params">(name: <span class="type">String</span>)</span></span>&#123;</span><br><span class="line">    Text(<span class="string">"Hello <span class="variable">$name</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Observable Model</code></li>
</ul>
<p>데이터의 변경이 생길 때마다 직접 UI를 업데이트하는 건 번거로운 작업이다. 이런 문제를 해결하기 위해 RxJava나 LiveData와 같은 Observable을 사용하면 된다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vm.state.observe(<span class="keyword">this</span>) &#123; state -&gt;</span><br><span class="line">    updateUi(state)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Compose에서는 데이터가 바뀔 때마다 UI를 변경시키기 위해서 LiveData를 사용하는 방법을 쓸 수도 있다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vm.name.observe(<span class="keyword">this</span>) &#123; name -&gt;</span><br><span class="line">    Greeting(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>그려야할 데이터가 많다면 각 데이터에 대해 일일히 LiveData를 만들어줘야 하기 때문에 불편하다. 이런 경우에는 data class에 <code>@Model</code> 어노테이션을 붙여주어 값이 변경될 때마다 해당 값을 참조하고 있는 Composable 함수가 다시 Compose 된다고 한다.</p>
<h2 id="2가지-주요-구성-요소"><a href="#2가지-주요-구성-요소" class="headerlink" title="2가지 주요 구성 요소"></a>2가지 주요 구성 요소</h2><ol>
<li>레이아웃, 입력, 텍스트, 애니메이션, 스타일, 위젯 및 그래픽이 포함된 핵심 UI 툴킷이 포함된 UI 라이브러리를 포함해야 한다.</li>
<li>컴포저블 기능을 수행하고 UI 계층 구조를 자동으로 업데이트하는 사용자 정의 Kotlin 컴파일러 플러그인, Compose 컴파일러를 포함해야 한다.</li>
</ol>
<ul>
<li>Compose Application은 애플리케이션 데이터를 UI 계층으로 변환하는 Composable한 함수로 구성되어있다.</li>
<li>@Composable 어노테이션을 추가해 컴포저블한 함수를 만들 수 있다. 기본적으로 Compose는 사용자 정의 Kotlin 컴파일러 플러그인을 사용하므로 기본 데이터가 변경되면 업데이트 가능한 UI 계층을 생성하기 위해 작성 가능한 기능을 다시 호출할 수 있다.</li>
</ul>
<h2 id="실행"><a href="#실행" class="headerlink" title="실행"></a>실행</h2><p>Compose는 아직 pre-alpha 단계다. 그래서 다른 라이브러리처럼 간단하게 dependency를 추가해서 사용할 수 없다. 대신에 오픈 소스를 가져와서 직접 빌드해야 한다.</p>
<ol>
<li>repo</li>
</ol>
<ul>
<li>AOSP(Android Open Source Project)에서는 repo라는 툴을 사용해 버전 관리를 한다. Git과 비슷하지만, 안드로이드에 좀 더 적합하게 만들었다고 한다.</li>
<li>다음 명령어를 통해 repo를 설치하면 된다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; repo</span><br><span class="line">$ chmod a+x repo</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>source</li>
</ol>
<ul>
<li>초기화 및 소스 코드의 Sync를 맞춘다.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ repo init -u https://android.googlesource.com/platform/manifest -b androidx-master-dev</span><br><span class="line">$ repo sync -j8 -c</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li>시작</li>
</ol>
<ul>
<li>소스를 내려받고 <code>/frameworks/support/ui</code> 위치로 이동해서 안드로이드 스튜디오를 실행하면 된다. 평소에 사용하는 버전이 아니라 지정된 버전을 사용해야 하기 때문에 <strong>studiow</strong>를 통해 안드로이드 스튜디오를 실행하면 된다고 한다.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd androidx-master-dev/frameworks/support/ui</span><br><span class="line">$ ./studiow</span><br></pre></td></tr></table></figure>

<h2 id="API-Annotations"><a href="#API-Annotations" class="headerlink" title="API - Annotations"></a>API - Annotations</h2><ol>
<li>Composable</li>
</ol>
<ul>
<li>이 어노테이션을 붙인 함수는 Compose의 기본이 되는 Composable Widget으로써 기능한다.</li>
<li>반환 타입을 따로 정의하지 않는다.</li>
<li>코틀린 컴파일러 플러그인을 통해서 구현된다. 따라서 컴파일 전과 후의 코드는 완전히 다르고, 우리가 일반적으로 알던 코틀린의 실행 흐름과 다르게 동작할 수 있다.</li>
</ul>
<ol start="2">
<li>Model</li>
</ol>
<ul>
<li>위젯에서 사용되는 데이터를 정의할 수 있다.</li>
<li>이 모델이 변경될 경우 위젯이 다시 렌더링된다.</li>
</ul>
<h2 id="API-Effects"><a href="#API-Effects" class="headerlink" title="API - Effects"></a>API - Effects</h2><p>Effect는 위젯을 그리는 단계에서 어떠한 코드를 실행하고 싶을 때 사용한다. 이해하기 위해서 Compose의 실행 흐름을 이해할 필요가 있다</p>
<p><strong>Execution Flow</strong></p>
<p>1) Composition Phase</p>
<ul>
<li>이 단계에서는 어떤 위젯을 그릴 것인지 선언한다. 선언적 프로그래밍 패러다임에는 <strong>지연 실행</strong>이라는 개념이 있는데, 최대한 실제 실행을 뒤로 미루는 것을 말한다. 이렇게 화면에 렌더링을 한다라는 실제 실행을 하기 이전에 어떻게 그릴 것인가를 정의하는 단계이다.</li>
</ul>
<p>2) Execution Phase</p>
<ul>
<li>Compostion Phase에서 정의했던 Component의 그래프를 화면에 렌더링하는 단계이다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Model</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>(<span class="keyword">val</span> number: <span class="built_in">Int</span>=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">increment</span><span class="params">()</span></span>: Counter =</span><br><span class="line">        Counter(number + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CounterWidget</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = Counter()</span><br><span class="line">    Text(text = <span class="string">"Counter : <span class="subst">$&#123;counter.value&#125;</span>"</span>)</span><br><span class="line">    Button(onClick = &#123;counter = counter.increment()&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>CounterWidget에는 counter라는 로컬 변수, 즉 상태가 존재한다. Text에서는 그것을 보여주고 Button에서는 그 값을 업데이트하고 있다. @Model로 모델 클래스임을 명시했으니 모든게 완벽하다. 버튼을 누르면 값이 증가하는 동작을 실행할 것 같지만 그렇지 않다.</p>
<p>앞서 @Composable 어노테이션을 이야기할 때, 코드가 일반적인 코틀린의 실행 흐름과는 다르게 동작할 수 있다고 언급했었다. <code>Compose의 위젯들은 일종의 Context 위에서 실행된다.</code> 따라서 위젯에서 필요한 데이터 역시 이 Context 위에 올라가 있어야 한다. 이를 도와주는게 <strong>Effect</strong>라는 것을 사용하면 가능하다.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Model</span></span><br><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span></span>(<span class="keyword">val</span> number: <span class="built_in">Int</span>=<span class="number">0</span>)&#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">increment</span><span class="params">()</span></span>: Counter =</span><br><span class="line">        Counter(number + <span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Composable</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">CounterWidget</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> counter = +memo&#123; Counter() &#125;</span><br><span class="line">    Text(text = <span class="string">"Counter : <span class="subst">$&#123;counter.value&#125;</span>"</span>)</span><br><span class="line">    Button(onClick = &#123;counter = counter.increment()&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>이전의 코드에서 memo Effect와 해당 Effect를 resolve하는 +(unaryPlus) 연산자 오버로딩 함수를 붙여주면 제대로 동작함을 확인할 수 있다.</p>
<ul>
<li>Effect의 이름<ul>
<li>Effect는 개념적으로 리턴 값을 가지고 있는 Composable 함수이고 이게 Compose의 실행 흐름에 일종의 효과를 적용하는 것과 비슷해서 Effect라고 지은 것으로 추측된다.</li>
</ul>
</li>
</ul>
<h2 id="Defined-Effects"><a href="#Defined-Effects" class="headerlink" title="Defined Effects"></a>Defined Effects</h2><ul>
<li>몇 가지 미리 정의되어 있는 Effect들이 존재하며 다음과 같다.</li>
<li>실제 사용 예는 대부분 실행 단계에서 필요한 어떤 값을 가져오기 위한 목적으로 쓴다.</li>
</ul>
<ol>
<li>Memo</li>
</ol>
<ul>
<li>단순히 어떤 실행 블록을 기억하는 역할을 한다.<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">memo</span><span class="params">(calculation: () -&gt; <span class="type">T</span>)</span></span> = effectOf&lt;T&gt;&#123;</span><br><span class="line">    context.remember(calculation)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>calculation 코드 블록에서 반환하는 클래스에 @Model이 붙어있지 않으면 Composition이 다시 이루어져도 이 코드 블록은 재실행되지 않는다.</p>
<ol start="2">
<li>State</li>
</ol>
<ul>
<li>memo와 비슷하지만, 단순히 어떤 코드 블록을 기억하는 목적이 아니라 위젯에서 사용할 Local State의 개념을 가지고 있는 Effect이다.</li>
<li>State는 Compose의 모델 클래스이고, 단순히 어떤 값을 wrapping하고 있는 클래스다.</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">state</span><span class="params">(<span class="keyword">init</span>: () -&gt; <span class="type">T</span>)</span></span> = memo &#123; State(<span class="keyword">init</span>()) &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Model</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">State</span>&lt;<span class="type">T</span>&gt; <span class="keyword">internal</span> <span class="keyword">constructor</span></span>(value: T) : Framed &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Lifecycle Effects</li>
</ol>
<ul>
<li>그 외 3 가지 Composition의 라이프사이클에 관련된 Effect가 존재한다.</li>
<li>onActive : Composition이 처음 실행될 때 호출되고, 그 이후로는 호출되지 않는다.</li>
<li>onDispose : 해당 위젯이 더 이상 화면에서 보이지 않을 때 호출된다.</li>
<li>onCommit : Compostion이 실행될 때마다 호출된다.</li>
</ul>
<h2 id="선언형-프로그래밍과-명령형-프로그래밍"><a href="#선언형-프로그래밍과-명령형-프로그래밍" class="headerlink" title="선언형 프로그래밍과 명령형 프로그래밍"></a>선언형 프로그래밍과 명령형 프로그래밍</h2><ul>
<li><p>명령형 프로그래밍</p>
<ul>
<li>프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 방식</li>
<li>알고리즘을 명시하고 목표는 명시하지 않는다.<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> container = binding.container</span><br><span class="line">container.removeAllViews()</span><br><span class="line">containter.setBackgroundColor(Color.BLUE)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>원하는 상태를 만들기 위해 명령문을 사용한다. 위의 코드는 container에게 모든 뷰를 제거, 백그라운드 색상을 지정하는 등의 명령을 내린다. </p>
</li>
<li><p>제어 흐름이 명확하다는 장점이 있지만, 반대로 어떤 상태에 도달하려는 것인지 명확하지 않다.</p>
</li>
</ul>
<ul>
<li><p>선언형 프로그래밍</p>
<ul>
<li>제어 흐름이 아니라 어떤 상태를 원하는지 서술한다.<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> State(</span><br><span class="line">	backgroundColor = Color.RED,</span><br><span class="line">	children = [</span><br><span class="line">		createNewButton()</span><br><span class="line">	]</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>이런 방식이 제대로 동작하기 위해서는 이전 상태와 다음 상태를 비교하고 전환을 수행하는 기능을 프레임워크가 제공해야 한다. 리액트가 이런 방식으로 동작한다고 한다. 상태를 비교하고 상태가 다를 경우 해당 부분만 렌더링한다.</p>
</li>
</ul>
<h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul>
<li><a href="https://developer.android.com/jetpack/compose" target="_blank" rel="noopener">Google Developer</a></li>
<li><a href="https://pluu.github.io/blog/android/2019/05/19/jetpack-compose/" target="_blank" rel="noopener">Android Studio Jetpack Compose &amp; Sample App</a></li>
<li><a href="https://source.android.com/setup/build/downloading#installing-repo" target="_blank" rel="noopener">How to install Repo</a></li>
<li><a href="https://velog.io/@tura/android-jetpack-jetpack-compose-part-1-concepts-backgrounds" target="_blank" rel="noopener">@tura velog</a></li>
</ul>

        </div>
        <footer class="article-footer">
            



    <a data-url="http://victorywoolee/victorywoolee.github.io/2019/10/05/Android-Compose/" data-id="ck1x0mhkt0005ni3r4w31r4pr" class="article-share-link"><i class="fa fa-share"></i>Share</a>
<script>
    (function ($) {
        $('body').on('click', function() {
            $('.article-share-box.on').removeClass('on');
        }).on('click', '.article-share-link', function(e) {
            e.stopPropagation();

            var $this = $(this),
                url = $this.attr('data-url'),
                encodedUrl = encodeURIComponent(url),
                id = 'article-share-box-' + $this.attr('data-id'),
                offset = $this.offset(),
                box;

            if ($('#' + id).length) {
                box = $('#' + id);

                if (box.hasClass('on')){
                    box.removeClass('on');
                    return;
                }
            } else {
                var html = [
                    '<div id="' + id + '" class="article-share-box">',
                        '<input class="article-share-input" value="' + url + '">',
                        '<div class="article-share-links">',
                            '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
                            '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
                            '<a href="http://pinterest.com/pin/create/button/?url=' + encodedUrl + '" class="article-share-pinterest" target="_blank" title="Pinterest"></a>',
                            '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google" target="_blank" title="Google+"></a>',
                        '</div>',
                    '</div>'
                ].join('');

              box = $(html);

              $('body').append(box);
            }

            $('.article-share-box.on').hide();

            box.css({
                top: offset.top + 25,
                left: offset.left
            }).addClass('on');

        }).on('click', '.article-share-box', function (e) {
            e.stopPropagation();
        }).on('click', '.article-share-box-input', function () {
            $(this).select();
        }).on('click', '.article-share-box-link', function (e) {
            e.preventDefault();
            e.stopPropagation();

            window.open(this.href, 'article-share-box-window-' + Date.now(), 'width=500,height=450');
        });
    })(jQuery);
</script>

        </footer>
    </div>
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "BlogPosting",
        "author": {
            "@type": "Person",
            "name": "Victory Woo"
        },
        "headline": "[Android] Compose",
        "image": "http://victorywoolee/victorywoolee.github.io",
        "keywords": "Android Jetpack Compose",
        "genre": "Android",
        "datePublished": "2019-10-05",
        "dateCreated": "2019-10-05",
        "dateModified": "2019-10-06",
        "url": "http://victorywoolee/victorywoolee.github.io/2019/10/05/Android-Compose/",
        "description": "왜??선언적 프로그래밍이 UI 프로그래밍에 있어서 부상하고 있는 이유는 갈수록 복잡해지고 다양해지는 UI/UX 때문이라고 할 수 있다. 특히 애니메이션 같은 부분은 명령형으로 처리하기 매우 까다롭다. 
가장 중요한 뷰의 상태라는 것에만 신경쓰고, 상세한 부분들은 프레임워크가 알아서 해주기를 기대하는 것이다.
기존의 안드로이드 UI 시스템에는 다음과 같은 문",
        "wordCount": 1679
    }
</script>

</article>

    <section id="comments">
    
        
    <div id="disqus_thread">
        <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
    </div>

    
    </section>



                        </div>
                    </section>
                    <aside id="sidebar">
    <a class="sidebar-toggle" title="Expand Sidebar"><i class="toggle icon"></i></a>
    <div class="sidebar-top">
        <p>follow:</p>
        <ul class="social-links">
            
                
                <li>
                    <a class="social-tooltip" title="facebook" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-facebook"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="github" href="https://github.com/victorywoolee" target="_blank" rel="noopener">
                        <i class="icon fa fa-github"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="weibo" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-weibo"></i>
                    </a>
                </li>
                
            
                
                <li>
                    <a class="social-tooltip" title="rss" href="/" target="_blank" rel="noopener">
                        <i class="icon fa fa-rss"></i>
                    </a>
                </li>
                
            
        </ul>
    </div>
    
        
<nav id="article-nav">
    
        <a href="/2019/10/09/Chap4-2/" id="article-nav-newer" class="article-nav-link-wrap">
        <strong class="article-nav-caption">newer</strong>
        <p class="article-nav-title">
        
            [Kotlin] 뻔하지 않은 프로퍼티와 생성자
        
        </p>
        <i class="icon fa fa-chevron-right" id="icon-chevron-right"></i>
    </a>
    
    
        <a href="/2019/10/04/CleanCode08/" id="article-nav-older" class="article-nav-link-wrap">
        <strong class="article-nav-caption">older</strong>
        <p class="article-nav-title">[CleanCode] 8장</p>
        <i class="icon fa fa-chevron-left" id="icon-chevron-left"></i>
        </a>
    
</nav>

    
    <div class="widgets-container">
        
            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">categories</h3>
        <div class="widget">
            <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Clean-Code/">Clean Code</a><span class="category-list-count">6</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/ETC/">ETC</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Kotlin/">Kotlin</a><span class="category-list-count">11</span></li></ul>
        </div>
    </div>


            
                

            
                
    <div class="widget-wrap">
        <h3 class="widget-title">recents</h3>
        <div class="widget">
            <ul id="recent-post" class="no-thumbnail">
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/ETC/">ETC</a></p>
                            <p class="item-title"><a href="/2019/10/19/Compile-Build/" class="title">[ETC] Compile, Build</a></p>
                            <p class="item-date"><time datetime="2019-10-19T03:12:59.000Z" itemprop="datePublished">2019-10-19</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Kotlin/">Kotlin</a></p>
                            <p class="item-title"><a href="/2019/10/13/Chap5-5/" class="title">[Kotlin] 수신 객체 지정 람다</a></p>
                            <p class="item-date"><time datetime="2019-10-13T07:59:27.000Z" itemprop="datePublished">2019-10-13</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Kotlin/">Kotlin</a></p>
                            <p class="item-title"><a href="/2019/10/13/Chap5-4/" class="title">[Kotlin] 자바 함수형 인터페이스 활용</a></p>
                            <p class="item-date"><time datetime="2019-10-13T06:33:19.000Z" itemprop="datePublished">2019-10-13</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Kotlin/">Kotlin</a></p>
                            <p class="item-title"><a href="/2019/10/13/Chap5-3/" class="title">[Kotlin] 지연(Lazy) 계산 컬렉션 연산</a></p>
                            <p class="item-date"><time datetime="2019-10-13T04:46:39.000Z" itemprop="datePublished">2019-10-13</time></p>
                        </div>
                    </li>
                
                    <li>
                        
                        <div class="item-inner">
                            <p class="item-category"><a class="article-category-link" href="/categories/Kotlin/">Kotlin</a></p>
                            <p class="item-title"><a href="/2019/10/12/Chap5-2/" class="title">[Kotlin] 컬렉션 함수형 API</a></p>
                            <p class="item-date"><time datetime="2019-10-12T08:31:25.000Z" itemprop="datePublished">2019-10-12</time></p>
                        </div>
                    </li>
                
            </ul>
        </div>
    </div>

            
                
    <div class="widget-wrap widget-list">
        <h3 class="widget-title">archives</h3>
        <div class="widget">
            <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">15</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a><span class="archive-list-count">19</span></li></ul>
        </div>
    </div>


            
        
    </div>
</aside>

                </div>
            </div>
        </div>
        <footer id="footer">
    <div class="container">
        <div class="container-inner">
            <a id="back-to-top" href="javascript:;"><i class="icon fa fa-angle-up"></i></a>
            <div class="credit">
                <h1 class="logo-wrap">
                    <a href="/" class="logo"></a>
                </h1>
                <p>&copy; 2019 Victory Woo</p>
                <p>Powered by <a href="//hexo.io/" target="_blank">Hexo</a>. Theme by <a href="//github.com/ppoffice" target="_blank">PPOffice</a></p>
            </div>
            <div class="footer-plugins">
              
    


            </div>
        </div>
    </div>
</footer>

        
    
    <script>
    var disqus_shortname = 'hexo-theme-hueman';
    
    
    var disqus_url = 'http://victorywoolee/victorywoolee.github.io/2019/10/05/Android-Compose/';
    
    (function() {
    var dsq = document.createElement('script');
    dsq.type = 'text/javascript';
    dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>




    
        <script src="/libs/lightgallery/js/lightgallery.min.js"></script>
        <script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>
        <script src="/libs/lightgallery/js/lg-pager.min.js"></script>
        <script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>
        <script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>
        <script src="/libs/lightgallery/js/lg-zoom.min.js"></script>
        <script src="/libs/lightgallery/js/lg-hash.min.js"></script>
        <script src="/libs/lightgallery/js/lg-share.min.js"></script>
        <script src="/libs/lightgallery/js/lg-video.min.js"></script>
    
    
        <script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>
    
    



<!-- Custom Scripts -->
<script src="/js/main.js"></script>

    </div>
</body>
</html>
