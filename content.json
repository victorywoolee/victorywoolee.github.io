{"meta":{"title":"VictoryWoo","subtitle":"VictoryWoo's Blog","description":null,"author":"Victory Woo","url":"http://victorywoolee/victorywoolee.github.io","root":"/"},"pages":[],"posts":[{"title":"[CleanCode] 13장","slug":"CleanCode13","date":"2019-11-30T04:55:29.000Z","updated":"2019-11-30T06:41:38.509Z","comments":true,"path":"2019/11/30/CleanCode13/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/11/30/CleanCode13/","excerpt":"","text":"동시성이 필요한 이유는??동시성은 결합(Coupling)을 없애는 전략이다. 즉, 무엇과 언제를 분리하는 전략이다. 여기서 말하는 무엇과 언제를 분리하면 애플리케이션의 구조와 효율이 극적으로 나아진다. 구조적인 관점에서 프로그램은 거대한 루프 하나가 아니라 작은 협력 프로그램 여럿으로 보인다. 따라서 시스템을 이해하기가 쉽고 문제를 분리하기도 쉽다. 하지만, 이러한 동시성을 구현하는 것은 쉬운 일이 아니다. 왜냐하면 프로그래머가 고려해야 할 사항이 많기 때문이다. 개념적으로는 쉬워보이지만 그렇지 않다. 그리고 동시성은 필요한 상황이 있지만, 미신과 오해가 존재한다. 미신과 오해 동시성을 항상 성능을 높여준다.동시성은 때로 성능을 높여준다. 대기 시간이 길어서 여러 스레드가 프로세서를 공유할 수 있거나 여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능이 높아진다. 어느 쪽도 일상적으로 발생하는 상황은 아니다. 동시성을 구현해도 설계는 변하지 않는다.단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다. 일반적으로 무엇과 언제를 분리하면 시스템 구조가 크게 달라진다. 웹 또는 EJB 컨테이너를 사용하면 동시성을 이해할 필요가 없다.실제로는 컨테이너가 어떻게 동작하는지, 어떻게 동시 수정, 데드락 등과 같은 문제를 피할 수 있는지를 알아야만 한다. 이제 아래의 설명은 동시성과 관련된 타당한 생각 몇 가지이다. 동시성은 다소 부하를 유발한다. 성능 측면에서 부하가 걸리며, 코드도 더 짜야 한다. 동시성은 복잡하다. 간단한 문제라도 동시성은 복잡하다. 일반적으로 동시성 버그는 재현하기 어렵다. 그래서 진짜 결함으로 간주되지 않고 일회성 문제로 여겨 무시하기 쉽다. 동시성을 구현하려면 근본적인 설계 전략을 재고해야 한다. 난관동시성을 구현하기 어려운 이유가 무엇일까? 간단하게 코드로 살펴보도록 하자. 1234567class X&#123; private int lastIdUsed; public int getNextId()&#123; return ++lastIdUsed; &#125;&#125; X로부터 인스턴스를 생성하고 lastIdUsed 필드를 42로 설정한 다음 두 스레드가 해당 인스턴스를 공유한다고 가정해보자. 이제 두 스레드가 getNextId()를 호출한다. 이렇게 되면 한 스레드가 값을 변경하면 다른 스레드는 그 변경된 값을 가져가게 된다. 그리고 이때 두 스레드가 같은 변수를 동시에 참조하면 같은 값을 받게 되는 상황이 생긴다. 이러한 상황이 자주 발생하는 것은 아니지만, 잘못된 결과를 일부 내놓기 때문에 문제가 된다. 동시성 방어 원칙이와 같은 동시성을 방어하기 위한 원칙이 있다. 1.단일 책임 원칙 메소드, 클래스, 컴포넌트를 변경할 이유는 단 하나여야 한다. 동시성은 복잡성 하나만으로도 따로 분리할 이유가 충분하다. 즉, 동시성 관련 코드는 다른 코드와 분리해야 한다. 2.자료 범위를 제한하라 공유 객체를 사용하는 코드 내 임계 영역을 synchronized 키워드로 보호하라고 권장한다. 이런 임계 영역의 수를 줄이는 기술이 중요하다. 공유 자료를 수정하는 위치가 많을수록 다음의 가능성이 커진다. 보호할 임계 영역을 빠뜨린다. 그래서 공유 자료를 수정하는 모든 코드를 망가뜨린다. 모든 임계 영역을 올바로 보호했는지 확인하느라 똑같은 노력과 수고를 반복한다. 그렇지 않아도 찾아내기 어려운 버그가 더욱 찾기가 어려워진다. 자료를 캡슐화하라. 공유 자료를 최대한 줄여라. 3.자료 사본을 사용하라. 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 좋다. 어떤 경우에는 객체를 복사해 읽기 전용으로 사용하는 방법이 가능하다. 어떤 경우에는 각 스레드가 객체를 복사해 사용한 후 한 스레드가 해당 사본에서 결과를 가져오는 방법도 가능하다. 4.스레드는 가능한 독립적으로 구현하라. 자신만의 세상에 존재하는 스레드를 구현하라. 즉, 다른 스레드와 자료를 공유하지 않는다. 각 스레드는 클라이언트 요청 하나를 처리한다. 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장한다. 그러면 각 스레드는 세상에 자신만 있는 듯이 돌아갈 수 있다. 다른 스레드와 동기화할 필요가 없기 때문이다. 실행 모델을 이해해보자.동시성과 관련된 개념을 보기 위해서는 스레드와 관련된 개념을 이해할 필요가 있다. 한정된 자원 : 다중 스레드 환경에서 사용하는 자원으로, 크기나 숫자가 제한적이다. 데이터베이스 연결, 길이가 일정한 읽기, 쓰기 버퍼 등이 예다. 상호 배제 : 한 번에 한 스레드만 공유 자료나 공유 자원을 사용할 수 있는 경우를 가리킨다. 기아 현상 : 한 스레드나 여러 스레드가 굉장히 오랫동안 혹은 영원히 자원을 기다린다. 예를 들어, 항상 짧은 스레드에게 우선 순위를 준다면, 짧은 스레드가 지속적으로 이어질 경우 긴 스레드가 기아 상태에 빠진다. 데드락 : 여러 스레드가 서로가 끝나기를 기다린다. 모든 스레드가 각기 필요한 자원을 다른 스레드가 점유하는 바람에 어느 쪽도 더 이상 진행하지 못한다. 라이브락 : 락을 거는 단계에서 각 스레드가 서로를 방해한다, 스레드는 계속해서 진행하려 하지만, 공명으로 인해 굉장히 오랫동안 혹은 영원히 진행하지 못한다.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"동시성","slug":"동시성","permalink":"http://victorywoolee/victorywoolee.github.io/tags/동시성/"},{"name":"Concurrent","slug":"Concurrent","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Concurrent/"}]},{"title":"[Kotlin] 위임 프로퍼티","slug":"Chap7-5","date":"2019-11-24T05:19:15.000Z","updated":"2019-11-24T06:43:57.422Z","comments":true,"path":"2019/11/24/Chap7-5/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/11/24/Chap7-5/","excerpt":"","text":"위임 프로퍼티(delegated property)를 사용하면 값을 뒷받침하는 필드에 단순히 저장하는 것보다 더 복잡한 방식으로 작동하는 프로퍼티를 쉽게 구현할 수 있다. 또한 그 과정에서 접근자 로직을 매번 재구현할 필요도 없다. 이런 특성의 기반에는 위임이 있다. 위임은 객체가 직접 작업을 수행하지 않고 다른 도우미 객체가 그 작업을 처리하게 하는 디자인 패턴이다. 이때 작업을 처리하는 도우미 객체를 위임 객체(delegate)라고 부른다. 위임 프로퍼티123class Foo&#123; var p : Type by Delegate()&#125; p 프로퍼티는 접근자 로직을 다른 객체에게 위임한다. 위의 코드에서는 Delegate 클래스의 인스턴스를 위임 객체로 사용한다. by 뒤에 있는 식을 계산해서 위임에 쓰일 객체를 얻는다. 컴파일러는 숨겨진 도우미 프로퍼티를 만들고 그 프로퍼티를 위임 객체의 인스턴스로 초기화한다. p 프로퍼티는 바로 그 위임 객체에게 자신의 작업을 위임한다. 아래 코드를 통해서 쉽게 이해할 수 있다. 123456789class Foo &#123; // 컴파일러가 생성한 도우미 프로퍼티이다. private val delegate = Delegate() var p: Type // p 프로퍼티를 위해 컴파일러가 생성한 접근자는 delegate의 getValue, setValue 메소드를 호출한다. set(value: Type) = delegate.setValue(..., value) get() = delegate.getValue(...)&#125; Delegate 클래스를 단순화하면 아래와 같다. 12345678910111213141516class Delegate &#123; operator fun getValue(...) &#123; ... &#125; operator fun setValue(..., value) &#123; ... &#125;&#125;class Foo &#123; var p: Type by Delegate() // by 키워드는 프로퍼티와 위임 객체를 연결한다. &#125;val foo = Foo()val oldValue = foo.p// foo.p라는 프로퍼티 호출은 내부에서 delegate.getValue()를 호출한다.foo.p = newValue// 프로퍼티 값을 변경하는 문장은 내부에서 delegate.setValue(..., newValue)를 호출한다. by lazy()를 사용한 프로퍼티 초기화 지연지연 초기화는 객체의 일부분을 초기화하지 않고 남겨뒀다가 실제로 그 부분의 값이 필요할 경우 초기화할 때 흔히 쓰이는 패턴이다. 초기화 과정에서 자원을 많이 사용하거나 객체를 사용할 때마다 꼭 초기화하지 않아도 되는 프로퍼티에 대해 지연 초기화 패턴을 사용할 수 있다. 이메일을 불러오기 전에는 null을 저장하고 불러온 다음에는 이메일 리스트를 저장하는 _emails 프로퍼티를 추가해서 지연 초기화를 구현한 클래스를 보자. 1234567891011121314class Person(val name: String)&#123; // 데이터를 저장하고 emails의 위임 객체 역할을 한다. private var _emails: List&lt;Email&gt;? = null val emails: List&lt;Email&gt; get() &#123; // 최초 접근 시 이메일을 가져온다. if(_emails == null)&#123; _emails = loadEmails(name) &#125; // 저장해둔 데이터가 있으면 그 데이터를 반환. return _emails!! &#125;&#125; 위에서는 뒷받침하는 프로퍼티라는 기법을 사용한다. _emails라는 프로퍼티는 값을 저장하고 다른 프로퍼티인 emails는 _emails라는 프로퍼티에 대한 읽기 연산을 제공한다. _emails는 널이 될 수 있는 타입인 반면에 emails는 널이 될 수 없는 타입이므로 프로퍼티를 두 개 이상 사용해야 한다. 이런 기법을 자주 사용하므로 잘 알아두는 편이 낫다. 하지\b만, 이렇게 만드는 것은 성가신 일이면서 스레드 안전한 방법이 아니다. 그래서 코틀린에서는 위임 프로퍼티라는 방법을 제공한다. 위임 프로퍼티는 데이터를 저장할 때 쓰이는 뒷받침하는 프로퍼티와 값이 오직 한 번만 초기화됨을 보장하는 게터 로직을 함께 캡슐화해준다. lazy라는 함수를 사용하면 된다. 12345class Person(val name: String)&#123; val emails by lazy &#123; loadEmails(name) &#125;&#125; lazy 함수는 코틀린 관례에 맞는 시그니처의 getValue 메소드가 들어있는 객체를 반환한다. 따라서 lazy를 by 키워드와 함께 사용해 위임 프로퍼티를 만들 수 있다. lazy 함수의 인자는 값을 초기화할 때 호출할 람다이다. lazy 함수는 기본적으로 스레드 안전하다. 하지만 필요에 따라 동기화에 사용할 락을 lazy 함수에 전달할 수도 있고, 다중 스레드 환경에서 사용하지 않을 프로퍼티를 위해 lazy 함수가 동기화를 하지 못하게 막을 수도 있다. 위임 프로퍼티 컴파일 규칙위임 프로퍼티가 어떤 방식으로 동작하는지 정리해보자. 12345class C &#123; var prop: Type by MyDelegate()&#125;val c = C() 컴파일러는 MyDelegate 클래스의 인스턴스를 감춰진 프로퍼티에 저장하며 그 감춰진 프로퍼티를 라는 이름으로 부른다. 또한 컴파일러는 프로퍼티를 표현하기 위해 KProperty 타입의 객체를 사용한다. 이 객체를 라고 부른다. 컴파일러는 다음 코드를 생성한다. 123456class C &#123; private val &lt;delegate&gt; = MyDelegate() var prop: Type get() = &lt;delegate&gt;.getValue(this, &lt;property&gt;) set(value: Type) = &lt;delegate&gt;.setValue(this, &lt;property&gt;, value)&#125; 컴파일러는 모든 프로퍼티 접근자 안에 getValue, setValue 호출 코드를 생성해준다. 프로퍼티를 사용하면 에 있는 getValue나 setValue 함수가 호출된다. val x = c.prop –&gt; val x = .getValue(c, )c.prop = x –&gt; .setValue(c, , x) 위임 프로퍼티와 관련된 내용을 깊게 보면 조금 어려운 부분이 있다. 사용할 때는 별 생각 없이 사용하면 되지만, 구현 내용을 들여다보고 확인해보면 이해되지 않는 부분도 존재한다.. 다음에 보충하도록 하자! 요약 코틀린에서는 정해진 이름의 함수를 오버로딩함으로써 표준 수학 연산자를 오버로딩할 수 있다. 하지만 직접 새로운 연산자를 만들 수는 없다. 비교 연산자는 equals나 compareTo 메소드로 변환된다. 클래스에 get, set, contains라는 함수를 정의하면 그 클래스의 인스턴스에 대해 []와 in 연산을 사용할 수 있고, 그 객체를 코틀린 컬렉션 객체와 비슷하게 다룰 수 있다. 미리 정해진 관례를 따라 rangeTo, iterator 함수를 정의하면 범위를 만들거나 컬렉션과 배열의 원소를 이터레이션할 수 있다. 구조 분해 선언을 통해 한 객체의 상태를 분해해서 여러 변수에 대입할 수 있다. 함수가 여러 값을 한꺼번에 반환해야 하는 경우 구조 분해가 유용하다. 데이터 클래스에 대한 구조 분해는 거저 사용할 수 있지만, 커스텀 클래스의 인스턴스에서 구조 분해를 사용하려면 componentN 함수를 정의해야 한다. 위임 프로퍼티를 통해 프로퍼티 값을 저장하거나 초기화하거나 읽거나 변경할 때 사용하는 로직을 재활용할 수 있다. 위임 프로퍼티는 프레임워크를 만들 때 아주 유용하다. 표준 라이브러리 함수인 lazy를 통해 지연 초기화 프로퍼티를 쉽게 구현할 수 있다. Delegates.observable 함수를 사용하면 프로퍼티 변경을 관찰할 수 있는 관찰자를 쉽게 추가할 수 있다. 맵을 위임 객체로 사용하는 위임 프로퍼티를 통해 다양한 속성을 제공하는 객체를 유연하게 다룰 수 있다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Kotlin/"},{"name":"Delegate","slug":"Delegate","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Delegate/"},{"name":"위임 프로퍼티","slug":"위임-프로퍼티","permalink":"http://victorywoolee/victorywoolee.github.io/tags/위임-프로퍼티/"}]},{"title":"[Kotlin] 구조 분해 선언과 Component 함수","slug":"Chap7-4","date":"2019-11-24T04:56:35.000Z","updated":"2019-11-24T05:20:32.570Z","comments":true,"path":"2019/11/24/Chap7-4/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/11/24/Chap7-4/","excerpt":"","text":"구조 분해 선언을 사용하면 복합적인 값을 분해해서 여러 다른 변수를 한꺼번에 초기화할 수 있다. 데이터 클래스의 경우 주 생성자에 들어있는 프로퍼티에 대해서 컴파일러가 자동으로 ComponentN 함수를 만들어준다. 1234567891011data class Point(x: Int, y: Int)&#123; ...&#125;val p = Point(10,20)val (x,y) = pprintln(x)-&gt; 10println(y)-&gt; 20 유용한 기능이며, 데이터 클래스가 아닌 다른 클래스에서는 이런 함수를 어떻게 구현하는지 살펴보면 다음과 같다. operator 키워드를 사용해 함수를 선언한다. 이는 코틀린의 관례 중 하나이다. 1234class Point(val x: Int, val y: Int)&#123; operator fun component1() = x operator fun component2() = y&#125; 구조 분해 선언은 함수에서 여러 값을 반환할 때 유용하다. 여러 값을 한꺼번에 반환해야 하는 함수가 있다면 반환해야 하는 모든 값이 들어갈 데이터 클래스를 정의하고 함수의 반환 타입을 그 데이터 클래스로 바꾼다. 구조 분해 선언 구문을 사용하면 이런 함수가 반환하는 값을 쉽게 풀어서 여러 변수에 넣을 수 있다. 1234567891011121314data class NameComponents(val name: String, val extension: String)fun splitFilename(fullName: String): NameComponents &#123; val result = fullName.split('.', limit = 2) return NameComponents(result[0], result[1])&#125;val (name, ext) = splitFilename(\"example.kt\")println(name)-&gt; exampleprintln(ext)-&gt; kt 배열이나 컬렉션에 대해서도 ComponentN() 함수가 있음을 안다면 더 유용하게 사용할 수 있다. 특히, 크기가 정해진 컬렉션을 다루는 경우 구조 분해가 더 유용하다. 무한히 ComponentN 함수를 선언할 수는 없으므로 이런 구문을 무한정 사용할 수는 없다. 그럼에도 불구하고 여전히 컬렉션에 대한 구조 분해는 유용하다 코틀린 표준 라이브러리에서는 맨 앞의 다섯 원소에 대한 ComponentN을 제공한다. 구조 분해 선언과 루프특히 맵의 원소에 대해 이터레이션할 때 구조 분해 선언이 유용하다. 다음 코드를 보자. 1234567891011fun printEntries(map: Map&lt;String, String&gt;)&#123; for((key, name) in map)&#123; println(\"$key -&gt; $name\") &#125;&#125;val map = mapOf(\"Oracle\" to \"Java\", \"JetBrains\" to \"Kotlin\")printEntries(map)Oracle -&gt; JavaJetBrains -&gt; Kotlin 코틀린 표준 라이브러리에는 맵에 대한 확장 함수로 iterator가 들어있다. 그 iterator는 맵 원소에 대한 이터레이터를 반환한다. 따라서 자바와 달리 코틀린에서는 맵을 직접 이터레이션할 수 있다. 또한 코틀린 라이브러리는 Map.Entry에 대한 확장 함수로 component1과 component2를 제공한다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Kotlin/"},{"name":"구조분해 선언","slug":"구조분해-선언","permalink":"http://victorywoolee/victorywoolee.github.io/tags/구조분해-선언/"}]},{"title":"[Kotlin] 타입 시스템 - 타입2","slug":"Chap6-4","date":"2019-11-23T09:22:02.000Z","updated":"2019-11-23T11:08:36.375Z","comments":true,"path":"2019/11/23/Chap6-4/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/11/23/Chap6-4/","excerpt":"","text":"Any, Any? 타입자바에서 Object가 최상위 타입이듯 코틀린에서는 Any 타입이 모든 널이 될 수 없는 타입의 조상 타입이다. 코틀린에서는 자바와 다르게 Any가 Int 등의 원시 타입을 포함한 모든 타입의 조상 타입이다. 유의해야 할 점은 Any가 널이 될 수 없는 타입인 것이다. 널이 들어갈 수 없으며 코틀린에서 널을 포함하는 모든 값을 대입할 변수를 선언하려면 Any? 타입을 사용해야 한다. 내부에서 Any 타입은 java.lang.Object에 대응한다. 자바 메소드에서 Object를 인자로 받거나 반환하면 코틀린에서는 Any로 그 타입을 취급한다.(물론 더 정확히 말하자면 널이 될 수 있는지 여부를 알 수 없으므로 플랫폼 타입인 Any!로 취급한다.) 코틀린의 모든 클래스에는 toString, equals, hashCode라는 세 메소드가 들어있으며 이는 Any에 정의된 메소드를 상속한 것이다. wait, notify는 사용할 수 없는데, 이를 사용하려면 java.lang.Object 타입으로 캐스팅해야 한다. UnitUnit 타입은 자바의 void 타입과 같은 기능을 한다. 관심을 가질만한 내용을 전혀 반환하지 않는 함수의 반환 타입으로 Unit을 쓸 수 있다. 1234567fun f(): Unit&#123; ...&#125;fun f() &#123; ...&#125; 코틀린의 Unit이 자바의 void와 다른 점은 무엇일까? Unit은 모든 기능을 갖는 일반적인 타입이며, void와 달리 Unit 타입을 인자로 쓸 수 있다. Unit 타입에 속한 값은 단 하나뿐이며 그 이름도 Unit이다. Unit 타입의 함수는 Unit 값을 묵시적으로 반환한다. 이 두 특성은 제네릭 파라미터를 반환하는 함수를 오버라이드하면서 반환 타입으로 Unit을 쓸 때 유용하다. 123456789interface Processor&lt;T&gt;&#123; fun process(): T&#125;class NoResultProcessor: Processor&lt;Unit&gt;&#123; override fun process()&#123; &#125;&#125; Unit을 반환하지만, 타입을 지정할 필요가 없다. 그리고 return을 명시할 필요도 없다.(컴파일러가 묵시적으로 return Unit을 넣어준다.) 코틀린에서 Void가 아닌 Unit이라는 이름으로 골랐는지 궁금할 수 있다. 함수형 프로그래밍에서 전통적으로 Unit은 단 하나의 인스턴스만 갖는 타입을 의미해왔고 바로 그 유일한 인스턴스의 유무가 자바 void와 코틀린 Unit을 구분하는 가장 큰 차이다. Nothing 타입 : 이 함수는 결코 정상적으로 끝나지 않는다.코틀린에는 결코 성공적으로 값을 돌려주는 일이 없으므로 ‘반환 값’이라는 개념 자체가 의미 없는 함수가 일부 존재한다. 예를 들어, 테스트 라이브러리들은 fail이라는 함수를 제공한다. fail은 특별한 메시지가 들어있는 예외를 던져서 현재 테스트를 실패시킨다. 다른 예로 무한 루프를 도는 함수도 결코 값을 반환하며, 정상적으로 끝나지 않는다. 그런 함수를 호출하는 코드를 분석하는 경우, 함수가 정상적으로 끝나지 않는다는 사실을 알면 유용하다. 이와 같은 경우를 표혀하기 위해 코틀린에는 Nothing이라는 특별한 반환 타입이 있다. 123456fun fail(message: String): Nothing&#123; throw IllegalStateException(message)&#125;fail(\"Error occurred\")-&gt; java.lang.IllegalStateException: Error occurred Nothing 타입은 아무 값도 포함하지 않는다. 따라서 Nothing은 함수의 반환 타입이나 반환 타입으로 쓰일 타입 파라미터로만 쓸 수 있다. 그 외의 다른 용도로 사용하는 경우 Nothing 타입의 변수를 선언하더라도 그 변수에 아무 값도 저장할 수 없으므로 아무 의미도 없다. Nothing을 반환하는 함수를 엘비스 연산자의 우항에 사용해서 전제 조건을 검사할 수 있다. 12val address = company.address ?: fail(\"no address\")println(address.city) 컴파일러는 Nothing이 반환 타입인 함수가 결코 정상 종료되지 않음을 알고 그 함수를 호출하는 코드를 분석할 때 사용한다. company.address가 널인 경우 엘비스 연산자의 우항에서 예외가 발생한다는 사실을 파악하고 address의 값이 널이 아님을 추론할 수 있다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Kotlin/"},{"name":"Type","slug":"Type","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Type/"}]},{"title":"[Kotlin] 타입 시스템 - 타입","slug":"Chap6-3","date":"2019-11-23T02:21:46.000Z","updated":"2019-11-23T09:22:36.335Z","comments":true,"path":"2019/11/23/Chap6-3/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/11/23/Chap6-3/","excerpt":"","text":"코틀린의 원시 타입코틀린은 원시 타입과 래퍼 타입을 구분하지 않는다. 원시 타입 : Int, Boolean 등 자바는 원시 타입과 참조 타입을 구분한다. 원시 타입 -&gt; 변수에 그 값이 들어간다. (int 등) 참조 타입 -&gt; 변수에 메모리 상의 객체 위치가 들어간다. 즉, 주소.(String 등) 원시 타입의 값을 더 효율적으로 저장하고 여기저기 전달할 수 있다. 하지만, 원시 타입에 대해 메소드를 호출하거나 컬렉션에 사용할 수 없다. 자바는 참조 타입이 필요한 경우 원시 타입을 감싸서 사용하는 래퍼 타입을 사용한다. 정수의 컬렉션을 사용하는 경우에는 Collection가 아닌 Collection를 사용한다. 반면, 코틀린은 원시 타입과 래퍼 타입을 구분하지 않고 항상 같은 타입을 사용한다. 12val i : Int = 1val list = listOf&lt;Int&gt;(1,2,3) 래퍼 타입을 따로 구분하지 않아 편리하다. 그러면 원시 타입과 참조 타입이 같다면 코틀린은 그들을 항상 객체로 표현하는 걸까? 그렇다면 너무 비효율적이다. 하지만, 그렇지 않다. 실행 시점에 숫자 타입은 가능한 한 가장 효율적인 방법으로 표현된다. 대부분의 경우 코틀린의 Int 타입은 자바 int 타입으로 컴파일된다. 이런 컴파일이 불가능한 경우는 컬렉션과 같은 제네릭 클래스를 사용하는 경우뿐이다. Int 타입을 컬렉션의 타입 파라미터로 넘기면 그 컬렉션에는 Int의 래퍼 타입에 해당하는 Integer 객체가 들어간다. Int와 같은 코틀린 타입에는 널 참조가 들어갈 수 없기 때문에 그에 상응하는 자바 원시 타입으로 컴파일 할 수 있다. 마찬가지로 반대로 자바 원시 타입의 값은 결코 널이 될 수 없으므로 자바 원시 타입을 코틀린에서 사용할 때도 널이 될 수 없는 타입으로 취급할 수 있다.(플랫폼 타입이 아님!) 널이 될 수 있는 원시 타입 : Int?, Boolean? null 참조를 자바의 참조 타입의 변수에만 대입할 수 있기 때문에 널이 될 수 있는 코틀린 타입은 자바의 원시 타입으로 표현할 수 없다. 따라서 코틀린에서 널이 될 수 있는 타입을 사용하면 그 타입은 자바의 래퍼 타입으로 컴파일 된다. 앞에서 언급한 대로 제네릭스 클래스의 경우, 래퍼 타입을 사용한다. 어떤 클래스의 타입 인자로 원시 타입을 넘기면 코틀린은 그 타입에 대해 박스 타입을 사용한다. 다음의 문장에서 null 값이나 null이 될 수 있는 타입을 전혀 사용하지 않았지만, 만들어지는 리스트는 래퍼인 Integer 타입으로 이뤄진 리스트이다. 1val list = listOf(1,2,3) 이렇게 컴파일하는 이유는 JVM에서 제네릭을 구현하는 방법 때문이다. JVM은 타입 인자로 원시 타입을 허용하지 않는다. 따라서 자바나 코틀린 모두에서 제네릭 클래스는 항상 박스 타입을 사용해야 한다. 원시 타입으로 이뤄진 대규모 컬렉션을 효율적으로 저장해야 한다면 원시 타입으로 이뤄진 효율적인 컬렉션을 제공하는 서드파티 라이브러리를 사용하거나 배열을 사용해야 한다. 숫자 변환코틀린에서는 숫자를 변환하는 방식이 자바와 다르다. 코틀린은 한 타입의 숫자를 다른 타입의 숫자로 자동 변환하지 않는다. 결과 타입이 허용하는 숫자의 범위가 원래 타입의 범위보다 넓은 경우조차도 자동 변환은 불가능하며 직접 변환 메소드를 호출해야 한다. 그래서 코틀린은 다양한 원시 타입에 대한 변환 함수를 제공한다. toByte(), toShort(), toChar() 등 양방향 변환 함수가 모두 제공됨. 코틀린은 산술 연산자에서도 자바와 똑같이 오버플로우가 발생할 수 있다. 하지만, 오버플로우를 검사하느라 추가 비용을 들이지는 않는다. 문자열을 숫자로 변환하는 함수 또한 제공한다. toInt, toByte, toBoolean 등이 존재한다. 이런 함수는 문자열의 내용을 각 원시 타입을 표기하는 문자열로 파싱한다. 파싱에 실패하면 NumberFormatException이 발생한다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Kotlin/"},{"name":"Type","slug":"Type","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Type/"}]},{"title":"[Android] CollapsingToolbarLayout","slug":"Android-CollapsingToolbarLayout","date":"2019-11-22T12:37:26.000Z","updated":"2019-11-22T12:49:04.361Z","comments":true,"path":"2019/11/22/Android-CollapsingToolbarLayout/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/11/22/Android-CollapsingToolbarLayout/","excerpt":"","text":"Android에서 CoordinatorLayout과 함께 사용하는 것 중 하나가 CollapsingToolbarLayout이다. 이번에는 이를 함께 사용하면서 겪은 이슈와 해결 방법을 공유한다. 이슈와 해결일단, 나는 레이아웃을 구성하진 않았고 기존에 구성되어 있는 레이아웃에서 작업을 진행했다. 전체적으로 CoordinatorLayout과 AppBarLayout, CollapsingToolbarLayout 등을 사용해서 구성되어 있었다. 일반적으로 이렇게 구성하는 이유는 어느 정도의 애니메이션을 해당 레이아웃 자체가 제공하기 때문이다. 그래서 이와 같은 레이아웃 구성을 한다. 최근에는 모션 레이아웃으로 이런 애니메이션을 쉽게 처리할 수 있다. 아무튼 xml 내에서 설정으로 애니메이션 효과를 얻을 수 있다는 장점이 있다. 필자는 이를 사용하면서 화면의 어떤 배너 클릭 시 스크롤 위치가 이동되는 기능을 구현해야 했다. 스크롤의 위치가 이동되는 기능은 구현했는데, CoordinatorLayout의 구성으로 인해서 스크롤이 이상하게 되는 이슈가 있었다. 그래서 분석을 해보니 CoordinatorLayout이 아닌 스크롤할 때 AppBarLayout이 collapse, expand되는 부분의 이슈임을 알게 되었다. 그래서 AppBarLayout의 모양이 expand되거나 collapse되도록 조정하는 것이 필요하다고 느꼈다. 스크롤의 위치가 이동될 때, appBarLayout.setExpanded(false)를 주어 접힌 모양을 만들었다. 생각보다 오래 걸리지 않았던 내용이다. 참고 Programmatically collapse or expand CollapsingToolbarLayout","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"UI","slug":"UI","permalink":"http://victorywoolee/victorywoolee.github.io/tags/UI/"},{"name":"CollapsingToolbarLayout","slug":"CollapsingToolbarLayout","permalink":"http://victorywoolee/victorywoolee.github.io/tags/CollapsingToolbarLayout/"}]},{"title":"[Android] Enum과 Typedef 어노테이션","slug":"Android-Enum","date":"2019-11-11T13:49:48.000Z","updated":"2019-11-11T14:09:43.400Z","comments":true,"path":"2019/11/11/Android-Enum/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/11/11/Android-Enum/","excerpt":"","text":"최근에 앱 개발을 하면서 값을 관리해야 하고 간단한 값이기도 해서 Enum을 사용하려 했다. 두 개의 키 값을 관리했지만, 추후 확장성을 고려했을 때 Enum이 좋지 않을 수도 있다는 의견을 받아서 찾아본 내용을 바탕으로 정리하려 한다. 이 글은 Enum 사용 시 주의할 점과 어노테이션을 통해 이러한 점을 보완할 수 있는 방법에 대해 정리했다. 안드로이드 앱 실행 시 메모리 할당Enum 사용 시 주의점을 알기 전에 먼저 안드로이드 앱 실행 시 메모리가 어떻게 할당되는지 간단히 알고 넘어가자. 앱을 실행시키면 안드로이드는 시스템 메모리 곁에 앱을 위한 메모리를 할당한다. 이렇게 할당된 메모리는 앱의 코드와 실행 중에 동적으로 항당하는 메모리를 위해 사용된다. 여기서 앱의 코드는 안드로이드 앱을 빌드할 때 생성되는 DEX 파일이다. Enum 사용 시 주의점 Enum은 앱의 코드(DEX) 크기와 런타임 메모리 사용량을 증가시킨다. 앱의 DEX 크기가 증가된다는 건 APK 파일도 커지고 앱이 실행되었을 때, 사용하는 메모리의 양도 그만큼 늘어난다는 걸 의미한다. 또한 Enum은 Integer나 String에 비해 더 많은 메모리를 런타임에 사용한다.","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Enum","slug":"Enum","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Enum/"},{"name":"Typedef","slug":"Typedef","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Typedef/"}]},{"title":"[Android] Coroutine을 위한 걸음마 #3","slug":"Coroutine-NextStep-3","date":"2019-11-05T14:30:18.000Z","updated":"2019-11-06T12:42:13.388Z","comments":true,"path":"2019/11/05/Coroutine-NextStep-3/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/11/05/Coroutine-NextStep-3/","excerpt":"","text":"코루틴에 대한 간단한 사용법을 알아보려 한다. 참고로 코틀린 1.3 버전부터는 종속성을 추가하지 않아도 된다. 코틀린에 코루틴이 포함되기 때문이다. 1.3 버전 이하를 사용한다면 명시적으로 종속성을 추가해주면 된다. 123def coroutineVersion = &apos;1.1.1&apos; implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:$coroutineVersion&quot; implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:$coroutineVersion&quot; kotlinx-coroutines-core : 코루틴의 기본 클래스들을 담고 있는 라이브러리kotlinx-coroutines-android : 안드로이드에서 추가적으로 사용할 수 있는 기능들을 확장시켜 놓은 것이다. 안드로이드에 종속적이지 않기 때문에 코루틴의 사용법을 알아볼 때, IntelliJ IDE를 사용했다. 따라서 예제 코드는 아래와 같은 형태를 띌 것이다. 123fun main()&#123; ...&#125; 하지만, 일반적인 블록이 아닌 runBlocking라는 메소드를 이용한 main 메소드를 만들 것이다. 123fun main() = runBlocking&lt;Unit&gt;&#123;&#125; runBlocking은 새로운 CoroutineScope을 만들어서 그 안에 있는 코드들을 실행시켜주는 메소드이다. 해당 블록에 있는 코루틴들이 모두 실행되고 종료될 때까지 반환하지 않는다. 그렇기 때문에 runBlocking은 실제 개발환경에서 쓰이는 메소드라기 보다는 이런 상황처럼 간단하게 코루틴을 테스트해보거나 Unit Test 같은 곳에서 쓰이기 위해서 만들어진 메소드라고 생각하면 된다. 우리가 일반적으로 main 함수를 만들면 코루틴 작업을 해주기 전에 main 함수가 반환을 해서 프로그램이 종료되버린다. 따라서 제대로 된 테스트가 어렵다. 그래서 runBlocking을 사용하는 것이다. main 함수도 원래 아무런 값도 리턴하지 않기 때문에 Unit을 리턴한다고 명시해주는 것이다. 123456fun main()&#123; CoroutineScope(Job()).launch&#123; delay(1000L) println(\"Hello\") &#125;&#125; 위의 코드는 1초 뒤에 “Hello”가 출력될 것 같지만, 그렇지 않다. 아무것도 출력되지 않고 종료된다. 그 이유는 코루틴이 생성되어 실행되고 있지만, 프로그램의 main 함수가 반환했기 때문에 코루틴 실행 결과를 제대로 볼 수 없는 것이다. 제대로 확인하기 위해서는 main 함수가 반환하기 전에 기다려주면 된다. 결과를 출력하기 위해 Thread를 사용했다. 12345678fun main()&#123; CoroutineScope(Job()).launch&#123; delay(1000L) println(\"Hello\") &#125; Thread.sleep(500)&#125; 또 다른 방법으로는 runBlocking을 사용하는 것이다. 123456fun main() = runBlocking&lt;Unit&gt;&#123; launch &#123; delay(1000L) println(\"Hello\") &#125;&#125; CoroutineScope 생성CoroutineScope 자체는 인터페이스이고, 마치 생성자처럼 보이게 하기 위해서 CoroutineScope이라는 전역 함수를 만들어 놓았다. 이 전역 함수로 CoroutineContext를 전달해 새로운 Scope을 만들 수 있다. CoroutineScope은 하나의 CoroutineContext를 갖고 있는 범위다. 우리는 CoroutineScope을 이용해서 launch나 async 등 여러 코루틴 실행 메소드를 호출할 수 있다. 하지만, 안드로이드 개발을 한다면 이런식으로 명시적으로 생성자를 이용해 CoroutineScope을 생성해줄 일은 드물 것이다. 그 이유는 다음과 같다. 뷰모델이나 스크린의 생명주기에 CoroutineScope을 연동해줘야 하기 때문에 구현을 이용하는 편이 더 직관적이다. 123456class Activity: AppCompatActivity, CoroutineScope&#123; private val job = Job() override val coroutineContext: CoroutineContext get() = job &#125; 위와 같이 CoroutineScope을 구현한 코드를 짜는 경우가 많다. 안드로이드 프레임워크에서 1번과 같이 안만들어도 viewModelScope과 같은 뷰모델과 생명주기가 연동된 CoroutineScope 같은 것들을 제공해준다. launch나 coroutineScope 등 메소드를 사용하면 자동으로 새로운 Scope이 만들어진다. 코루틴 실행그러면 이제 코루틴을 실행해보자. CoroutineScope을 이용해서 코루틴을 실행할 수 있으며, 여기서 코루틴을 실행한다는 것은 suspend 함수들을 실행할 수 있다는 것을 의미한다. 1. launch launch는 코루틴을 실행하고 결과값을 반환받지 않는다. 즉, fire-forget 방식이다. 시작하고 결과를 잊어버린다는 뜻이다. 그리고 실행시킨 Coroutine에 대한 Job 객체를 반환한다. Job 객체를 이용해 해당 코루틴이 모두 실행되기를 기다릴 수도 있고, 취소할 수도 있다. 즉, 특정 반환값을 반환할 수 없고 Job 객체를 반환한다. 새로운 코루틴을 생성해서 실행한다. 12345678910fun main() = runBlocking&lt;Unit&gt;&#123; launch &#123; printName() &#125;&#125;suspend fun printName()&#123; delay(500L) println(\"VictoryWoo!\")&#125; 실행이 잘 되는 것을 확인할 수 있다. runBlocking은 전달한 코드 블록이 종료될 때까지 main 함수가 종료되지 않게 도와주며 수신자가 CoroutineScope 객체인 람다식을 전달하기 때문에 바로 launch를 사용할 수 있다. launch로 실행시킨 코루틴을 이용해서 끝날 때까지 기다리는 것과 취소를 시켜보도록 하자. 1234567891011121314fun main() = runBlocking&lt;Unit&gt;&#123; val job = launch &#123; printName() &#125; println(\"I am waiting message!\")&#125;suspend fun printName()&#123; delay(500L) println(\"VictoryWoo!\")&#125;// 결과I am waiting message!VictoryWoo! suspend 함수에서 delay 메소드를 이용해 0.5초를 멈추고 main 함수는 계속 실행이 된다. 그리고 나서 launch에서 0.5초가 지난 뒤 printName() 함수를 실행한다. 그래서 결과가 정상적으로 출력된다. job의 join 메소드를 호출해보도록 하자. 1234567891011121314fun main() = runBlocking&lt;Unit&gt;&#123; val job = launch &#123; printName() &#125; job.join() println(\"I am waiting message!\")&#125;suspend fun printName()&#123; delay(500L) println(\"VictoryWoo!\")&#125; 그러면 job을 처리할 때까지 기다렸다가 job을 처리하고 나서 main() 함수의 남은 부분을 처리한다. job의 생명주기 cancel과 cancelJoin 메소드의 차이점을 코드를 통해서 알아보자. 1234567891011121314151617181920212223242526fun main() = runBlocking&lt;Unit&gt; &#123; val job = launch &#123; printMe() &#125; yield() job.cancelAndJoin() println(\"I am waiting Me\")&#125;suspend fun printMe() = try&#123; coroutineScope &#123; println(\"Start..\") kotlinx.coroutines.delay(Long.MAX_VALUE) &#125;&#125;catch (e: CancellationException)&#123; println(\"취소되었습니다.\")&#125;// 결과Start..취소되었습니다.I am waiting Me 코루틴은 취소될 때 CancellationException이라는 예외를 던진다. 위의 결과처럼 cancelAndJoin 메소드를 사용하면 코루틴이 취소되는 것을 기다렸다가 그 다음 명령 줄이 실행되기 때문에 “I am waiting Me” 이라는 문자열이 가장 나중에 출력된다. 그러면 cancelAndJoin -&gt; cancel 메소드로 변경해서 테스트해보자. 1234567891011121314151617181920212223242526fun main() = runBlocking&lt;Unit&gt; &#123; val job = launch &#123; printMe() &#125; yield() job.cancel() println(\"I am waiting Me\")&#125;suspend fun printMe() = try&#123; coroutineScope &#123; println(\"Start..\") kotlinx.coroutines.delay(Long.MAX_VALUE) &#125;&#125;catch (e: CancellationException)&#123; println(\"취소되었습니다.\")&#125;// 결과Start..I am waiting Me취소되었습니다. cancel 메소드로 변경하면 결과는 위와 같다. 코루틴이 취소될 때까지 기다리지 않고 main() 함수의 print문이 먼저 동작한다. 그리고 코루틴을 취소했을 때의 메시지가 출력된다. async launch와 다르게 결과값을 반환받을 수 있다. Job을 반환하는 launch와 다르게 Deferred라는 인터페이스 객체를 반환한다. Deferred 객체의 await() 메소드를 이용하면 async 블록에서 반환되는 값을 얻을 수 있다. 다음의 코드를 확인해보자. 1234567891011121314151617fun main() = runBlocking&lt;Unit&gt; &#123; val deferred: Deferred&lt;Int&gt; = async &#123; callMe() &#125; println(\"I am waiting result\") val result = deferred.await() println(\"Result = $result\")&#125;suspend fun callMe():Int&#123; delay(1000L) return 100&#125;// 결과I am waiting resultResult = 100 async에 대해 await() 메소드를 호출해야 결과값을 받을 수 있다. runBlocking main 함수나 테스트 코드에서 현재 쓰레드를 runBlocking으로 만든 코루틴이 끝날 때까지 멈추게 해주는 역할을 한다. withContext 새로운 CoroutineContext를 만들어서 새로운 코루틴을 실행시켜주는 역할을 한다. async{}.await{}의 대체제라고 볼 수 있다. 그렇기 때문에 값을 반환시켜줄 수 있다. 123456789101112fun main() = runBlocking&lt;Unit&gt; &#123; var result = downloadString() println(result)&#125;suspend fun downloadString() = withContext(Dispatchers.IO) &#123; kotlinx.coroutines.delay(1000) return@withContext \"Victory String!\"&#125;// 결과Victory String! 단순한 코드이다. main 함수 안의 코드는 Main Dispatcher에서 동작하고 downloadString() 함수는 Dispatchers.IO에서 실행되게 된다. 이렇듯 특정 작업이 실행될 쓰레드를 바꾸어주는 데도 유용하게 쓰일 수 있다. 어떻게 보면 RxJava의 스케줄러를 바꿔주는 것의 역할을 한다고 볼 수도 있다.","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Kotlin/"},{"name":"Coroutine","slug":"Coroutine","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Coroutine/"}]},{"title":"[Android] Coroutine을 위한 걸음마 #2","slug":"Coroutine-NextStep-2","date":"2019-11-03T11:55:09.000Z","updated":"2019-11-03T13:33:27.239Z","comments":true,"path":"2019/11/03/Coroutine-NextStep-2/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/11/03/Coroutine-NextStep-2/","excerpt":"","text":"코루틴을 공부하기 위한 다른 시리즈이다. 무슨 시리즈가 이렇게 많냐, 이게 뭐냐할 수도 있지만 필자가 이해하기 위해서 다양한 글을 참고해서 봤고, 이를 한 번에 정리하려 했지만 참고했던 글들이 다루는 내용이 조금씩 상이했고 집중하고 있는 분야가 달라서 이렇게 나눠서 작성한다. 아직까지 필자만의 개인적인 공간이지만, 추후에 공개될 때는 독자?들이 시리즈별로 나눠서 보기 편할 것이라 생각한다. Components사실 개념을 더 설명하고 정리한 뒤에 사용법을 알아보려 했지만, 기본적인 Coroutine의 사용법을 미리 숙지한 후, 개념을 설명하면서 코드를 함께 보는 것이 이해하기 수월할 것 같아서 이런 방식으로 진행하려 한다. 코틀린의 코루틴은 다음과 같은 구성요소들이 존재한다. CoroutineScope CoroutineContext Job Dispatcher 사실, CoroutineScope과 CoroutineContext, Job은 각기 하는 일은 다르지만, 모두 하나로 엮여있다고 생각하면 된다. 하나의 CoroutineScope 안에 CoroutineContext가 존재하며, 하나의 CoroutineContext에 하나의 Job이 존재한다. 이는 코루틴간의(엄밀히 말하면 Job들의) 부모-자식 관계로도 표현하기도 한다. 아래의 그림을 참고하자. 파란색 직사각형이 CoroutineScope을 의미하고, 파란색으로 채워진 직사각형은 CoroutineContext 그리고 회색 직사각형은 Job을 의미한다. 이에 대한 자세한 내용은 다음의 글을 참고하자! 참고한 부분은 빠른 시일 내에 포스팅할 예정이다. CoroutineScopeScope이라는 단어에서 알 수 있듯이, 코루틴이 실행되는 범위를 뜻한다. suspend라는 키워드는 suspend될 수 있는 함수 앞에 붙인다. 123suspend fun printMessage()&#123; println(\"suspend function!\")&#125; 이같은 suspend 함수는 아무 곳에서나 호출할 수 있는게 아니다. 실제로 아무 곳에서나 호출하려고 한다면 컴파일러가 에러를 알려준다. 그러면 에러를 확인해보면 “suspend 함수는 코루틴이나 다른 suspend 함수에서 호출해야 한다”고 한다. suspend 함수는 꼭 CoroutineScope이라는 어떠한 범위 안에서 실행되어야 한다. 그러면 왜 아무데서나 suspend 함수를 호출할 수 없게 만든것일까?? 실행될 코루틴들을 적절한 시점에 취소해주거나, 작업 순서를 파악하거나, 에러를 돌려받는 등 전체적으로 관리해주기 위해서 현재 코루틴이 실행되고 있는 범위를 파악할 수 있게 하기 위함이다. 이로 인해서 결국은 어떤 코루틴이 실행 중이고 작업이 완료되었고 등등의 상태를 파악하고 관리할 수 있다. 예륻 들어, Activity의 onCreate()에서 하나의 Scope을 만들어서 onDestroy()에서 그 Scope에 존재하는 모든 코루틴 메모리 관리를 위해 취소해주고 싶다고 해보자. 그러면 아무 곳에서나 코루틴을 막 호출하면 이 코루틴들이 어디서 작업을 수행하고 있는지에 대한 정보를 얻어오기가 힘들며 얻어올 수가 없을 수도 있다. 하지만, 이처럼 특정 Scope을 만들고 그 안에서 코루틴들을 돌리면 필요한 시점에 모두 취소시켜버릴 수가 있다. 이와 관련한 내용은 다음 포스팅에 더 자세히 다루겠다. CoroutineContextCoroutineContext는 CoroutineScope이 무조건 하나 가지고 있어야 하는 객체다. 이는 코루틴이 어떻게 실행될지에 대한 정보들을 담고있다. 이는 인터페이스로 정의되어 있다. Job이나 Dispatcher가 이 CoroutineContext.Element라는 인터페이스를 구현하고 CoroutineContext.Element 인터페이스는 CoroutineContext를 상속한다. 따라서 결국 Job이나 Dispatcher 같은 것들도 CoroutineContext라고 봐도 된다. 그러면 plus 연산자를 이용해 CoroutineContext들끼리 합치거나 get 연산자를 이용해 CoroutineContext.Element를 얻어올 수도 있다. 여기서 get 메소드에 Key 인자를 받는데 어떻게 CoroutineContext.Element를 상속하는 Key로 넣을 수 있냐고 물어본다면 Job이 companion object로 Key를 갖고 있어서이다. 여기서 중요하게 생각해야 할 것은 CoroutineContext 끼리 + 연산자를 이용해 합칠 수 있다는 것이다. CoroutineScope을 만들 때, CoroutineContext를 인자로 넣어줘야 한다. 1val scope = CoroutineScope(job + dispatcher) 그러면 위와 같이 쓰고 싶은 job과 쓰고 싶은 dispatcher를 조합해 원하는대로 코루틴을 동작시켜 줄 CoroutineScope을 만들 수 있다. JobJob은 코루틴들이 특정 Scope에서 실행되는 상태나 동작을 관리한다. Job은 여러가지 방법으로 얻을 수 있다. CoroutineContext의 get 메소드를 이용해서 얻을 수도 있다. 1coroutineContext[Job] 혹은 Scope의 launch 함수를 사용할 때 Job 객체를 반환하기도 한다. 123val job = scope.launch &#123; printMessage()&#125; Job이 가지고 있는 메소드에 대해서 간략하게 살펴보도록 하자. cancel : 이 Job에서 실행되고 있는 코루틴들과 이 Job의 자식 Job들에서 실행되고 있는 코루틴들을 모두 취소시켜버린다. 코루틴들이 부모-자식 관계를 이루는 것이 중요한 이유가 이것이다. 우리가 원하는 시점에 Scope을 취소함으로써 그 Scope에서 실행되던 모든 코루틴들이 취소될 수 있는 것이다. join : 쓰레드의 join처럼 이 Job 내의 코루틴들이 모두 실행되는 것을 기다린다. isActive : 해당 Job에서 작동하는 코루틴이 현재 실행 중인지를 판단한다. 이런 메소드들을 통해 볼 수 있듯이 Job 객체는 CoroutineContext 안에 존재하고, 코루틴의 작업들을 직접 관리하거나 상태를 살펴보는 역할을 한다. DispatcherDispatcher는 RxJava나 Thread에서 사용하는 개념인 스케줄러와 비슷하다. 실제로 코루틴을 동작시킬 주체가 어떤 쓰레드일지를 결정해준다. 다음과 같이 CoroutineScope의 인자인 CoroutineContext의 구성으로 넣을 수 있다. 3가지가 존재하며 이는 필자가 정리했던 [Coroutine Document #1]에도 나와있다. 다시 한 번 살펴보도록 하자. 1. Dispatcher.Main 해당 코루틴이 메인 쓰레드에서 동작하게 해준다. 보통 UI를 업데이트하거나 LiveData의 값을 변경해주는 작업을 할 때 쓰인다. 그리고 보통 suspend 함수의 호출은 Main Dispatcher에서 발생한다. 이게 무슨 뜻이냐면 Main Safety가 제대로 지켜진 코루틴 함수 설계라면 가장 부모 Scope 코루틴이 동작하는 쓰레드가 메인 쓰레드가 되어도 상관이 없기 때문이다. 1234567891011121314151617181920fun main()&#123; CoroutineScope(Dispatchers.Main).launch&#123; // Main networkDoSomething() computationDoSomething() // Main &#125;&#125;suspend fun networkDoSomething()&#123; withContext(Dispatchers.IO)&#123; // IO &#125;&#125;suspend fun computationDoSomething()&#123; withContext(Dispatchers.Default)&#123; // Default &#125;&#125; 위와 같은 코드여도 문제가 전혀 없다.withContext는 현재 실행되는 CoroutineContext를 교체해주는 역할을 한다. 2. Dispatchers.IO 네트워크 통신이나 데이터베이스에서 파일을 읽거나 쓰는 작업, 파일 입출력 등을 할 때 사용한다. 3. Dispatchers.Default 계산이나 집약적 작업을 할 때 사용하면 된다.","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Kotlin/"},{"name":"Coroutine","slug":"Coroutine","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Coroutine/"}]},{"title":"[Android] Coroutine을 위한 걸음마 #1","slug":"Coroutine-NextStep-1","date":"2019-11-03T11:40:24.000Z","updated":"2019-11-05T14:31:14.851Z","comments":true,"path":"2019/11/03/Coroutine-NextStep-1/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/11/03/Coroutine-NextStep-1/","excerpt":"","text":"이번 시리즈는 한글로 된 블로그를 참고해서 작성하는 시리즈이다. 이전 시리즈가 아직 끝나지 않았지만, 해당 시리즈를 시작했다. 이전에는 공식 문서에서 레퍼런스로 제공하는 블로그의 원본을 번역해서 작성했다. 아무래도 번역해서 작성하다 보니 정확한 의미 파악이 조금 어려웠고 이해가 안되는 부분도 많았다. 그래서 뭔가 개념이 잘 잡히지 않는 느낌이 있었다. 이런 부분을 보완하고자 한글 블로그를 보고 정리를 해서 걸음마라는 시리즈를 만들었다. 아무래도 이 시리즈를 먼저 보고 Document 시리즈를 보는게 나을 것이다. 코루틴코루틴은 코드의 비동기 실행을 도와주는 프로그래밍 패러다임이다. 마치 쓰레드처럼 말이다. 코루틴은 코틀린 언어에만 존재하는 개념이 아니다. 꽤 오래 전부터 존재했으며, 여러 프로그래밍 언어에서 코루틴을 구현해놓은 구현체가 있으며, 코틀린도 이를 1.3 버전부터 지원하기 시작했다. 각각의 언어에서 코루틴이라는 패러다임에 맞춰서 프레임워크를 제공해주기 위해 구현한 방식은 조금씩 다르다. 필자가 다루려는 코루틴은 코틀린이 JVM 위에서 동작하는 언어이기 때문에 결국 쓰레드를 이용해서 구현이 되어있다. 그래서 코틀린의 코루틴을 경량화된 쓰레드라고 부르기도 한다. 보통 프로그래밍 언어세ㅓ 함수 혹은 메소드는 두 가지 동작을 갖는다. 호출과 반환(invoke &amp; return)이다. 코루틴에서는 두 가지의 개념이 더 추가된다. suspend resume 함수 실행 도중에 함수가 일시 정지되었다가, 다시 실행된다. 이게 코루틴의 핵심 개념이라고 보면 된다. 실행 도중에 suspend된 함수는 상태가 저장되었다가, 필요할 때 다시 resume될 수 있다. 메인 쓰레드에서 fetchDocs() 함수를 호출하고 함수 내부에서 get() 메소드를 호출해서 suspend된다. 이때 메인 쓰레드는 다시 자유로워져서 다른 동작(터치 이벤트 수신 등)을 받을 수 있게 된다. 그리고 get() 메소드가 끝나서 다시 resume 하게 되면, 메인 쓰레드에서 그 데이터를 받아서 사용할 수 있다. 코루틴의 사용 목적1. Long running task 긴 작업을 할 때 메인 쓰레드를 멈추게 하지 않을 수 있다. 이 부분에 있어 백그라운드 쓰레드를 사용하는 것과 차이가 없다고 생각할 수 있다. 하지만, 그 방식이 조금 다르다. 2. Main-safety 메인 쓰레드에서 오래 걸리는 작업을 실행하는 코루틴 코드를 실행시켜도 상관이 없게 한다. 방금 전에는 메인 쓰레드에서는 오래 걸리는 작업을 피하라고 했다. 뭔가 상반된다. 보통 쓰레드에서는 별도의 쓰레드를 만들고, 그 안에서 오래 걸리는 작업을 실행시킨다. 그러나 코루틴 프레임워크를 사용하면 메인 쓰레드에서 오래 걸리는 작업을 실행시켜도 알아서 쓰레드 관리가 되어지기 때문에 그럴 필요가 없다. 즉, 쓰레드 관리가 더 쉬워진다.(이유는 코루틴이 내부적으로 알아서 적절한 쓰레드를 쓰기 때문이다.) 콜백 패턴을 제거할 코루틴 이 부분은 간단하게 넘어가도록 하겠다. 콜백 패턴은 좋은 패턴이지만, 복잡하다는 단점이 있다. 코루틴을 사용하면 콜백 패턴을 사용하지 않고 콜백 패턴의 장점을 취할 수 있다. 코루틴 vs 쓰레드쓰레드는 컴퓨터 공학에서 의미하는 그 쓰레드이다. 한 프로세스에 여러 개의 쓰레드가 존재할 수 있으며, 프로세스 내에서 자원을 공유한다. 이는 컴퓨터 공학에서 OS 과목을 들었다면 모두 알 내용이다. 그리고 요즘 하드웨어의 발전에 따라 멀티코어를 갖는 CPU들이 등장하며 멀티 프로세스 및 멀티 쓰레딩에 관한 성능이 중요해졌다. 앞서 코루틴의 목적 중 하나인 long running task에 있어서 쓰레드는 멀티 쓰레딩을 이용해서 여러 개의 쓰레드를 통해 동시에 작업을 진행시킨다. 사실 코틀린에서 코루틴이란 쓰레드를 더 효율적으로 사용하게 해주는 일종의 도구일 뿌닝다. 쓰레드는 진짜 말 그대로 하드웨어가 지원을 해주는 한, 동시에 여러 개의 작업이 실행된다. 혹은 한 번에 하나의 쓰레드만 실행이 가능한 하드웨어라고 해도, 쓰레드 하나하나를 만들 때 만들어진 쓰레드들이 스케줄러에 의해 번갈아가면서 실행이 된다. 그래서 한 번에 1000개의 동시 작업을 해주고 싶다면 1000개의 쓰레드를 만들어줘야 한다. 그러나 코루틴은 조금 다르다. 한 번에 1000개의 동시 작업을 해주고 싶다고 해도 10개 정도의 쓰레드 혹은 1개로도 해결할 수 있다. 즉, 한 개의 쓰레드를 계속 돌려 쓰는 것이다. 한 쓰레드에서 특정 작업이 suspend되면 그 시간에 다른 작업을 할 수 있기 때문이다. 그렇기 때문에 쓰레드와 달리 진짜로 동시에 실행되는 것이 아니라 순차적으로 실행이 되는 것이다. 123456789101112131415repeat(1000)&#123; launch(Dispatchers.Default)&#123; println(\"Thread : $&#123;Thread.currentThread().name&#125;\") delay(500) &#125;&#125;// 결과Thread : DefaultDispatcher-worker-4 @coroutine#99993Thread : DefaultDispatcher-worker-5 @coroutine#99992Thread : DefaultDispatcher-worker-1 @coroutine#99990Thread : DefaultDispatcher-worker-9 @coroutine#99988Thread : DefaultDispatcher-worker-12 @coroutine#99987Thread : DefaultDispatcher-worker-6 @coroutine#99982Thread : DefaultDispatcher-worker-2 @coroutine#99981 정상 동작하며, 약 12개의 쓰레드로 작업을 처리한다. 코루틴이 아닌 일반적인 방법으로 작업을 수행했다면, 1000개의 쓰레드를 생성하려다 메모리가 부족해서 터졌을 것이다.","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Kotlin/"},{"name":"Coroutine","slug":"Coroutine","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Coroutine/"}]},{"title":"[ETC] Jank","slug":"Jank","date":"2019-11-03T03:31:03.000Z","updated":"2019-11-03T03:52:58.252Z","comments":true,"path":"2019/11/03/Jank/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/11/03/Jank/","excerpt":"","text":"공부를 하던 중에 Jank라는 용어가 등장해서 도대체 뭐를 의미하는 것인지 궁금해서 찾아보는 포스팅이다. Jank이를 한국말로 간단하게 번역하면 화면이 버벅거리는 것을 뜻한다. 쟁크 프리(http://jankfree.org/)의 첫 페이지에 쟁크에 대한 설명이 나와있다. 최근의 브라우저는 단말의 주사율에 맞추어 화면의 컨텐츠를 그리려고 한다. 요즘 기기들의 대부분은 60Hz로 1초당 60번을 그린다. 화면이 동적으로 움직일 때(스크롤, 변환, 애니메이션 등) 주사율에 맞추어 화면을 그리기 위해서는 브라우저가 초당 60 프레임을 만들어야 한다. 쟁크(Jank)는 사이트나 앱이 주사율에 맞추지 못하고 더듬거리며 요동치거나 잠시 멈춘다는 것을 사용자가 보는 것을 말한다. 브라우저가 프레임을 만드는데 너무 많은 시간이 걸려서 쟁크가 생긴 것으로, 사이트나 앱에 대한 사용자 경험에 부정적인 영향을 미친다. 참고 http://jankfree.org/","categories":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/categories/ETC/"}],"tags":[{"name":"Jank","slug":"Jank","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Jank/"},{"name":"개발 용어","slug":"개발-용어","permalink":"http://victorywoolee/victorywoolee.github.io/tags/개발-용어/"}]},{"title":"[CleanCode] 12장","slug":"CleanCode12","date":"2019-11-03T02:17:39.000Z","updated":"2019-11-03T03:02:45.379Z","comments":true,"path":"2019/11/03/CleanCode12/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/11/03/CleanCode12/","excerpt":"","text":"창발적 설계로 깔끔한 코드를 구현하자우리는 켄트 백이 제시한 단순한 설계 규칙 네 가지가 소프트웨어 품질을 크게 높여준다고 믿는다. 켄트 백은 다음 규칙을 따르면 설계는 단순하다고 말한다. 아래 목록은 중요도 순이다. 모든 테스트를 실행한다. 중복을 없앤다. 프로그래머 의도를 표현한다. 클래스와 메소드 수를 최소로 줄인다. 1. 모든 테스트를 실행하라 테스트를 철저히 거쳐 모든 테스트 케이스를 항상 통과하는 시스템은 테스트가 가능한 시스템이다. 당연하지만 중요한 말이다. 테스트가 불가능한 시스템은 검증도 불가능하다. 검증이 불가능한 시스템은 절대 출시하면 안된다. 다행스럽게도, 테스트가 가능한 시스템을 만들려고 애쓰면 설계 품질이 더불어 높아진다. 크기가 작고 목적 하나만 수행하는 클래스가 나온다. SRP를 준수하는 클래스는 테스트가 훨씬 더 쉽다. 테스트 케이스가 많을수록 개발자는 테스트가 쉽게 코드를 작성한다. 따라서 철저한 테스트가 가능한 시스템을 만들면 더 나은 설계가 얻어진다. 결합도가 높으면 테스트 케이스를 작성하기 어렵다. 그러므로, 앞서와 마찬가지로 테스트 케이스를 많이 작성할수록 개발자는 DIP와 같은 원칙을 적용하고 의존성 주입(DI), 인터페이스, 추상화 등과 같은 도구를 사용해 결합도를 낮춘다. 따라서 설계 품질은 더욱 높아진다. 놀랍게도 ‘테스트 케이스를 만들고 계속 돌려라‘라는 간단하고 단순한 규칙을 따르면 시스템은 낮을 결합도과 높은 응집력이라는 객체 지향 방법론이 지향하는 목표를 저절로 달성한다. 즉, 테스트 케이스를 작성하면 설계 품질이 높아진다. 2. 리팩토링 테스트 케이스를 모두 작성했다면 이제 코드와 클래스를 정리해도 괜찮다. 구체적으로는 코드를 점진적으로 리팩토링해 나간다. 코드를 정리하면서 시스템이 깨질까 걱정할 필요가 없다. 왜냐하면 테스트 케이스가 있으니까! 리팩토링 단계에서는 소프트웨어 품질을 높이는 기법이라면 무엇이든 적용해도 괜찮다. 응집도를 높이고, 결합도를 낮추고 관심사를 분리하고 시스템 관심사를 모듈로 나누고, 함수와 클래스 크기를 줄이고, 더 나은 이름을 선택하는 등 다양한 기법을 동원한다. 또한, 이 단계는 단순한 설계 규칙 중 나머지 3개를 적용해 중복을 제거하고, 프로그래머 의도를 표현하고, 클래스와 메소드의 수를 최소로 줄이는 단계이기도 하다. 3. 중복을 없애라. 우수한 설계에서 중복은 커다란 적이다. 중복은 추가 작업, 추가 위험, 불필요할 복잡도를 뜻하기 때문이다. 중복은 여러가지 형태로 표출된다. 똑같은 코드는 당연히 중복이며, 비슷한 코드는 더 비슷하게 고쳐주면 리팩토링이 쉬워진다. 소규모 재사용은 시스템 복잡도를 극적으로 줄여준다. 소규모 재사용을 제대로 익혀야 대규모 재사용이 가능하다. 표현하라 자신이 이해하는 코드를 짜기는 쉽다. 코드를 짜는 동안에는 문제에 푹 빠져 코드를 구석구석 이해하니까. 하지만, 나중에 코드를 유지보수할 사람이 코드를 짜는 사람만큼이나 문제를 깊이 이해할 가능성을 희박하다. 소프트웨어 프로젝트 비용 중 대다수는 장기적인 유지보수에 들어간다. 코드를 변경하면서 버그의 싹을 심지 않으려면 유지보수 개발자가 시스템을 제대로 이해해야 한다. 하지만, 시스템이 점차 복잡해지면서 유지보수 개발자가 시스템을 이해하느라 보내는 시간은 점점 늘어나고 동시에 코드를 오해할 가능성도 점점 커진다. 그러므로 코드는 개발자의 의도를 분명히 표현해야 한다. 개발자가 코드를 명백하게 짤수록 다른 사람이 그 코드를 이해하기 쉬워진다. 그래야 결함이 줄어들고 유지보수 비용이 적게 든다. 우선, 좋은 이름을 선택한다. 이름과 기능이 완전히 딴판인 클래스나 함수로 유지보수 담당자를 놀라게 해서는 안된다. 둘째, 함수와 클래스 크기를 가능한 줄인다. 작은 클래스와 작은 함수는 이름 짓기도 쉽고, 구현하기도 쉽고, 이해하기 쉽다. 셋째, 표준 명칭을 사용한다. 예를 들어, 디자인 패턴은 의사소통과 표현력 강화가 주요 목적이다. 클래스가 COMMAND, VISITOR와 같은 표준 패턴을 사용해 구현된다면 클래스 이름에 패턴 이름을 넣어준다. 그러면 다른 개발자가 클래스 설계 의도를 이해하기 쉬워진다. 넷째, 단위 테스트 케이스를 꼼꼼히 작성한다. 테스트 케이스는 소위 ‘예제로 보여주는 문서‘다. 다시 말해, 잘 만든 테스트 케이스를 읽어보면 클래스 기능이 한 눈에 들어온다. 하지만 표현력을 높이는 가장 중요한 방법은 노력이다. 흔히 코드만 돌린 후 다음 문제로 직행하는 사례가 너무도 흔하다. 나중에 읽을 사람을 고려해 조금이라도 읽기 쉽게 만들려는 충분한 고민은 거의 찾기 어렵다. 하지만, 나중에 코드를 읽을 사람은 바로 자신일 가능성이 높다는 사실을 명심하자. 그러므로 자신의 작품을 조금 더 자랑하자. 하수와 클래스에 조금 더 시간을 투자하자. 더 나은 이름을 선택하고, 큰 함수를 작은 함수 여럿으로 나누고, 자신의 작품에 조금만 더 주의를 기울이자. 주의는 대단한 재능이다. 클래스와 메소드 수를 최소로 줄여라 중복을 제거하고, 의도를 표현하고 SRP를 준수한다는 기본적인 개념도 극단으로 치달으면 득보다 실이 많아진다. 클래스와 메소드 크기를 줄이자고 조그만 클래스와 메소드를 수없이 만드는 사례도 없지 않다. 그래서 이 규칙은 함수와 클래스 수를 가능한 줄이라고 제안한다. 목표는 함수와 클래스 크기를 작게 유지하면서 동시에 시스템 크기도 작게 유지하는 데 있다. 하지만 이 규칙은 간단한 설계 규칙 네 개 중 우선순위가 가장 낮다. 다시 말해, 클래스와 함수의 수를 줄이는 작업도 중요하지만, 테스트 케이스를 만들고 중복을 제거하고 의도를 표현하는 작업이 더 중요하다는 뜻이다. 결론경험을 대신할 단순한 개발 기법이 있을까? 당연히 없다. 하지만 이 책에서 소개하는 기법은 저자들이 수십년 동안 쌓은 경험의 정수다. 단순한 설계 규칙을 따른다면 (오랜 경험 후에야 익힐)우수한 기법과 원칙을 단 번에 활용할 수 있다.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"창발성","slug":"창발성","permalink":"http://victorywoolee/victorywoolee.github.io/tags/창발성/"}]},{"title":"[CleanCode] 11장","slug":"CleanCode11","date":"2019-11-03T01:38:05.000Z","updated":"2019-11-03T02:17:57.617Z","comments":true,"path":"2019/11/03/CleanCode11/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/11/03/CleanCode11/","excerpt":"","text":"이번 장은 이해하기가 조금 어려웠다. 그래서 뒷 부분에 나와있는 내용 중 몇몇을 추려서 작성할 것이다. 테스트 주도 시스템 아키텍처 구축 관점으로 (혹은 유사한 개념으로) 관심사를 분리하는 방식은 그 위력이 막강하다. 애플리케이션 도메인 논리를 POJO로 작성할 수 있다면, 즉 코드 수준에서 아키텍처 관심사를 분리할 수 있다면 진정한 테스트 주도 아키텍처 구축이 가능해진다. 아주 단순하면서도 멋지게 분리된 아키텍처로 소프트웨어 프로젝트를 진행해 결과물을 재빨리 출시한 후, 기반 구조를 추가하며 조금씩 확장해 나가도 괜찮다. 그렇다고 아무 방향 없이 프로젝트에 뛰어들어도 좋다는 소리는 아니다. 프로젝트를 시작할 때는 일반적인 범위, 목표, 일정은 물론이고 결과로 내놓을 시스템의 일반적인 구조도 생각해야 한다. 요약 : 최선의 시스템 구조는 각기 POJO(또는 다른) 객체로 구현되는 모듈화된 관심사 영역(도메인)으로 구성된다. 이렇게 서로 다른 영역은 해당 영역 코드에 최소한의 영향을 미치는 관점이나 유사한 도구를 사용해 통합한다. 이런 구조 역시 코드와 마찬가지로 테스트 주도 기법을 적용할 수 있다. 의사 결정을 최적화하라 모듈을 나누고 관심사를 분리하면 지엽적인 관리와 결정이 가능해진다. 가장 적합한 사람에게 책임을 맡기면 가장 좋다. 때때로 가낭흔 마지막 순간까지 결정을 미루는 방법이 최선이다. 최대한 정보를 모아 최선의 결정을 내리기 위해서다. 성급한 결정은 불충반한 지식으로 내린 결정이다. 요약 : 관심사를 모듈로 분리한 POJO 시스템은 기민함을 제공한다. 이런 기민함 덕택에 최신 정보에 기반해 최선의 시점에 최적의 결정을 내리기가 쉬워진다. 또한 결정의 복잡성도 줄어든다. 명백한 가치가 있을 때 표준을 현명하게 사용하라 표준을 사용하면 아이디어와 컴포넌트를 재사용하기 쉽고, 적절한 경험을 가진 사람을 구하기 쉬우며, 좋은 아이디어를 캡슐화하기 쉽고 컴포넌트를 엮기 쉽다. 하지만 때로는 표준을 만드는 시간이 너무 오래 걸려 업계가 기다리지 못한다. 어떤 표준은 원래 표준을 제정한 목적을 잊어버리기도 한다. 시스템은 도메인 특화 언어가 필요하다 DSL(Domain Sepecific Language)은 스크립트 언어나 표준 언어로 구현한 API를 가리킨다. DSL로 짠 코드는 도메인 전문가가 작성한 구조적인 산문처럼 읽힌다. 좋은 DSL은 도메인 개념과 그 개념을 구현한 코드 사이에 존재하는 의사소통 간극을 줄여준다. 효과적으로 사용한다면 DSL은 추상화 수준을 코드 관용구나 디자인 패턴 이상으로 끌어올린다. 그래서 개발자가 적절한 추상화 수준에서 코드 의도를 표현할 수 있다. 결론시스템 역시 깨끗해야 한다. 깨끗하지 못한 아키텍처는 도메인 논리를 흐리며 기민성을 떨어뜨린다. 도메인 논리가 흐려지면 제품 품질이 떨어진다. 버그가 숨어들기 쉬워지고 스토리를 구현하기 어려워지는 탓이다. 기민성이 떨어지면 생산성이 낮아져 TDD가 제공하는 장점이 사라진다. 모든 추상화 단계에서 의도는 명확히 표현해야 한다. 그러려면 POJO를 작성하고 관점 혹은 유사한 메커니즘을 사용해 각 구현 관심사를 분리해야 한다. 시스템을 설계하든 개별 모듈을 설계하든, 실제로 돌아가는 가장 단순한 수단을 사용해야 한다는 사실을 명심하자.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"시스템","slug":"시스템","permalink":"http://victorywoolee/victorywoolee.github.io/tags/시스템/"}]},{"title":"[Android] Coroutine Document #2","slug":"Coroutine-Part-2","date":"2019-11-02T14:05:20.000Z","updated":"2019-11-03T12:54:48.857Z","comments":true,"path":"2019/11/02/Coroutine-Part-2/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/11/02/Coroutine-Part-2/","excerpt":"","text":"이전 포스팅에 이어서 두 번째 시리즈이다. 직접 번역하는 것과 구글 번역기를 통해 번역된 내용을 기반으로 정리하고 있다. 그래서 정확하지 않은 부분이 있을 수 있다. 그렇다면 필자에게 알려주면 고맙겠다. Keeping track of coroutines1편 포스팅에서 코루틴이 해결하는 큰 문제를 알아봤다. 요약하면 코루틴은 두 가지 일반적인 프로그래밍 문제에 대한 훌륭한 솔루션이다. Long running tasks는 너무 오래 걸려서 메인 스레드를 차단한다. Main Safety는 메인 스레드로부터 suspend 함수가 호출될 수 있는 것을 확실하게 해준다. 이러한 문제를 해결하기 위해 코루틴은 suspend와 resume을 추가하여 기본적인 함수를 기반으로 한다. 그리고 특정 스레드의 모든 코루틴이 일시 중단되면(suspend) 스레드는 자유로워져 다른 작업을 수행할 수 있다. 그러나 코루틴 자체는 수행중인 작업을 추적하는데 도움이 되지 않는다. 많은 수의 코루틴(수백 또는 수천)을 가지고 있고 동시에 모두 정지시키는 것이 좋다. 그리고 코루틴은 비용이 저렴하지만, 파일을 읽거나 네트워크를 요청하는 것과 같이 수행하는 작업은 종종 비용이 많이 든다. 코드를 사용해 수동으로 천 개의 코루틴을 추적하는 것은 매우 어렵다. 모든 항목을 추적하고 수동으로 완료 또는 취소하도록 할 수 있지만, 이와 같은 코드는 지루하고 오류가 발생하기 쉽다. 그리고 코드가 완벽하지 않으면 코루틴을 잃어버릴 것이다. 이를 work leak이라 부른다. work leak은 작업 누출이라고 하며 메모리 누출과 비슷하지만, 더 나쁘다. 잃어버린 코루틴이다. 메모리 누수 외에도 작업 누수가 CPU, 디스크를 사용하거나 네트워크 요청을 시작하도록 자체적으로 resume될 수 있다. 유출된 코루틴은 메모리, CPU, 디스크를 낭비하거나 필요하지 않은 네트워크 요청을 시작할 수도 있다. 코루틴의 유출을 방지하기 위해 Kotlin은 Structured concurrency를 도입했다. Structured concurrency는 언어의 특징과 모범 사례들의 조합으로 따라한다면 코루틴에서 실행 중인 작업 모두를 추적하는 데 도움이 된다. 안드로이드에서는 Structured concurrency를 사용해 세 가지 작업을 수행할 수 있다. 더 이상 필요하지 않으면 작업을 취소할 수 있다. 실행 중인 동안 작업을 추적할 수 있다. 코루틴이 실패하면 에러 신호가 발생한다. 이제 이들 각각에 대해 알아보고 Structured concurrency이 어떻게 코루틴 및 유출 작업을 잃지 않도록 하는데 도움이 되는지 알아보자. Cancel work with scopes코틀린에서 코루틴은 CoroutineScope이라 불리는 곳에서 실행되어야만 한다. CoroutineScope은 코루틴 뿐 아니라 suspended된 코루틴도 추적한다. Part 1에서 언급한 Dispatchers와 달리 코루틴을 실행하지 않으면 추적하지 않아도 된다. 모든 코루틴을 추적하기 위해서 Kotlin은 CoroutineScope 없이 코루틴을 시작하는 것을 허용하지 않는다. 즉, 코루틴을 추적하려면 CoroutineScope으로 코루틴을 시작해야 한다는 의미이다. CoroutineScope은 초강력한 힘을 갖춘 경량 버전의 ExecutorService와 비슷하다고 생각할 수 있다. 그것은 Part 1에서 살펴본 일시 정지하고 다시 시작하는 새로운 코루틴을 시작할 수 있는 능력을 부여한다. CoroutineScope은 모든 코루틴을 추적하고 그 안에서 시작된 모든 코루틴을 취소할 수도 있다. 이것은 사용자가 떠날 때 화면에서 시작된 모든 것을 정리하기 원하는 Android 개발에 적합하다. 강조할 점은 CoroutineScope은 모든 코루틴을 추적하고 그 안에서 시작된 모든 코루틴을 취소할 수 있다는 것이다. Starting new coroutines어디에서나 suspend 함수를 호출할 수는 없다. suspend, resume 메커니즘을 사용하려면 일반 함수에서 코루틴으로 전환해야 한다. 코루틴을 시작하기 위한 두 가지 방법이 있으며, 그들을 서로 사용법이 다르다. launch : 빌더는 새로운 코루틴을 시작할 것이다. 그리고 이에 대해 망각한다. 이것이 의미하는 바는 호출자에게 결과를 반환하지 않는다는 것이다. async : 빌더는 새로운 코루틴을 시작할 것이다. 그리고 await이라는 suspend 기능으로 결과를 반환할 수 있다. 거의 대부분의 경우, 일반적인 함수에서 코루틴을 시작하는 방법에 대한 적절한 답은 launch를 사용하는 것이다. 일반 함수에서 await을 호출할 수 있는 방법이 없으므로(suspend 함수를 직접 호출할 수는 없음) 코루틴의 주요 항목으로 비동기를 사용하는 것은 별로 의미가 없다. 비동기를 사용하는 것이 적절한지는 추후에 살펴봐야 할 것이다. 대신 launch를 호출해서 코루틴을 시작하라면 CoroutineScope을 사용해야 한다. 12345scope.launch&#123; // This block starts a new coroutine in the scope. // It can call suspend functions fetchDocs()&#125; launch가 일반 함수에서 코루틴 세계로 코드를 가져오는 다리 역할을 한다고 생각할 수 있다. launch의 몸체 부분 안에서 suspend 함수를 호출하고 main safety를 만들 수 있다. 중요하게 생각할 것은 launch가 일반 함수에서 코루틴으로 갈 수 있도록 이어주는 다리라는 점이다. 주의 launch와 async의 큰 차이점은 예외를 처리하는 방법이다. aysnc는 결과 또는 예외를 얻기 위해 결국 await를 호출하므로 기본적으로 예외를 throw하지 않는다. 즉, 비동기를 사용하여 새로운 코루틴을 시작하면 예외가 자동으로 삭제된다. launch 및 async는 CoroutineScope에서만 사용할 수 있으므로 생성한 모든 코루틴은 항상 scope에 의해 추적된다. Kotlin은 추적되지 않은 코루틴을 만들 수 없으므로 work leak을 피할 수 있다. Start in the ViewModel만약에 CoroutineScope에서 시작된 모든 코루틴을 추적하고 launch를 사용해 새로운 코루틴을 생성한다면 launch를 호출하고 scope을 어디에 두어야 할까?? 그리고 scope에서 시작된 모든 코루틴을 취소하는 것이 언제 제일 합리적일까?? 이에 대한 의문이 생기고 궁금하다. 자, 필자는 안드로이드 개발자이기 때문에 안드로이드 개발 위주로 설명을 한다. Android에서는 종종 CoroutineScope을 사용자의 화면과 연결하는 것이 좋다. 이를 통해 더 이상 사용자와 관련이 없는 Activities, Fragments에 대해 코루틴 leak 또는 추가 작업을 수행하지 않아도 된다. 사용자가 화면을 벗어나면 화면과 관련된 CoroutineScope이 모든 작업을 취소할 수 있다. Structured concurrency는 scope이 취소될 때 모든 코루틴이 취소되도록 한다. 코루틴을 Android Architecture Components(이하 AAC)와 통합할 때 일반적으로 ViewModel에서 코루틴을 시작하려 한다. 이곳은 가장 중요한 작업이 시작된 이후의 자연스러운 장소이며, 모든 코루틴을 회전시키는 데 대해 걱정할 필요가 없다. ViewModel에서 코루틴을 사용하려면 lifecycle-viewmodel-ktx:2.1.0-alpha04.viewModelScope의 viewModelScope 확장 속성을 사용하여 AndroidX Lifecycle에서 릴리즈되고 현재는 알파 상태이다. 라이브러리가 현재 알파이므로 버그가 있을 수 있으며 최종 릴리즈 전에 API가 변경될 수 있다. 이 부분을 주의해야 한다. 12345678class MyViewModel(): ViewModel()&#123; fun userNeedsDocs()&#123; // start a new coroutine in a viewModel viewModelScope.launch&#123; fetchDocs() &#125; &#125;&#125; 위에서 본 viewModelScope는 이 ViewModel이 지워질 때(즉, onCleared() 콜백이 호출될 때) 시작된 모든 코루틴을 자동으로 취소한다. 문서를 모두 가져오지 않고 사용자가 앱을 닫은 경우에 일반적으로 올바른 동작이다. 취소하지 않는다면 요청을 완료하기 위해 배터리를 낭비하고 있을 것이다. 그리고 더 많은 safety를 위해 CoroutineScope은 자체적으로 전파된다. 따라서 시작한 코루틴이 다른 코루틴을 계속 시작하면 둘 다 동일한 범위에 있게 된다. 즉, 의존하는 라이브러리가 viewModelScope에서 코루틴을 시작하더라도 취소할 수 있는 방법이 있다. 주의 코루틴이 일시 중단될 때 CancellationException 예외를 발생시켜 코루틴을 협력적으로 취소한다. Throwable과 같은 최상위 예외를 포착하는 예외 처리기는 이 예외를 포착한다. 예외 처리기에서 예외를 사용하거나 일시 중단하지 않으면 코루틴이 반 취소된 상태로 유지된다. viewModel만큼 실행하기 위해 코루틴이 필요한 경우 viewModelScope를 사용하여 일반 함수에서 코루틴으로 전환해야 한다. 그런 다음 viewModelScope이 자동으로 코루틴을 취소하므로 누출을 만들지 않고 무한 루프를 작성하는 것이 좋다. 12345678910fun runForever()&#123; // start a new coroutine in the viewModel viewModelScope.launch&#123; // cancelled when the viewModel is cleared while(true)&#123; delay(1000) // do something every second &#125; &#125;&#125; viewModelScope을 사용하면 무한 루프를 포함한 모든 작어비 더 이상 필요하지 않을 때 취소되도록 할 수 있다. Keep track of work하나의 코루틴을 시작하는 것이 좋으며 실제로 필요한 모든 코드를 처리할 수 있다. 예를 들어, 코루틴을 시작하고 네트워크 요청을 하고 데이터베이스에 결과를 쓴다. 하지만, 때때로 좀 더 복잡해야 할 때도 있다. 코루틴에서 두 개의 네트워크 요청을 동시에 수행하려고 한다고 가정하면 더 많은 코루틴을 시작해야 한다. 그러면 더 많은 코루틴을 만들기 위해 suspend 함수는 coroutineScope이라는 빌더나 혹은 그의 사촌인 supervisorScope을 사용한다. 솔직히 이 API는 혼란스럽다. coroutineScope builder와 CoroutineScope은 이름에 하나의 문자 차이만 있음에도 불구하고 서로 다르다. 어느 곳에서나 새로운 코루틴을 시작하는 것은 잠재적인 work leak을 만드는 한 가지 방법이다. 호출자는 코루틴이 어떻게 작업을 추적할 수 없다면 새로운 코루틴에 대해 알지 못할 수 있다. 이를 해결하기 위해 structured concurrency가 도움이 된다. 즉, suspend 함수가 리턴될 때 모든 작업이 완료된다는 보장을 제공한다. 123456suspend fun fetchTwoDocs()&#123; coroutineScope&#123; launch &#123; fetchDocs(1) &#125; async &#123; fetchDocs(2) &#125; &#125;&#125; 이 예에서는 네트워크에서 동시에 두 개의 문서를 가져온다. 첫 번째는 launch로 시작된 코루틴에서 가져오며 fire and forget이라고도 하며 즉, 결과를 호출자에게 반환하지 않는다. 두 번째는 async와 함께 가져온 문서다. 그래서 문서를 호출자에게 반환한다. 이 예제는 두 문서 모두에 비동기를 사용하기 때문에 조금 이상하다. 그러나 필요한 것에 따라 launch 및 async를 혼합하고 일치시킬 수 있음을 보여주고자 한 것이다. coroutineScope 및 supervisorScope을 사용하면 suspend 함수에서 코루틴을 안전하게 시작할 수 있다. 그러나 이 코드는 새로운 코루틴을 명시적으로 기다리지 않는다. 코루틴이 실행되는 동안 fetchTwoDocs가 반환되는 것처럼 보인다. structured concurrency를 만들고 work leaks를 피하기 위해서 fetchTwoDocs와 같은 suspend 함수가 반환될 때, 모든 작업이 완료되도록 확실하게 해야 한다. 즉, fetchTwoDocs가 반환되기 전에 시작한 두 코루틴이 모두 완료되어야 한다. Kotlin은 coroutineScope 빌더를 사용해 fetchTwoDocs에서 작업이 누출되지 않도록 한다. coroutinScope 빌더는 그 안에서 시작된 모든 coroutine이 완료될 때까지 그 자체를 일시 중단한다. 이 때문에 coroutineScope 빌더에서 시작된 모든 코루틴이 완료될 때까지 fetchTwoDocs에서 결과를 반환할 수 있는 방법이 없다. Lots and lots of work1,2개의 코루틴을 추적하는 방법을 살펴봤는데, 이제는 1000개의 코루틴을 추적해보려고 한다. 위의 예제는 1000개의 네트워크 요청을 동시에 만드는 것을 보여주고 있다. 실제 안드로이드 코드에서는 권장하지 않는 방식이다. 왜냐하면 앱이 많은 리소스를 필요로하기 때문이다. 이 코드에서 coroutineScope 빌더 내에서 시작해 1000개의 코루틴을 시작한다. gif를 통해 상황이 어떻게 연결되는지 확인할 수 있다. suspend 함수를 사용하기 때문에 어딘가에서 일부 코드는 CoroutineScope을 사용해 코루틴을 생성해야 한다. 우리는 그 CoroutineScope에 대해 아무것도 모른다. viewModelScope 또는 다른 곳에서 정의된 다른 CoroutineScope일 수 있다. 호출 범위가 무엇이든 상관없이 coroutineScope 빌더는 이를 작성하는 새 범위의 상위로 사용한다. 그런 다음 coroutineScope 블록 내에서 launch는 새로운 범위 내에서 코루틴을 시작한다. launch로 시작된 코루틴이 완료되면 새로운 범위가 코루틴을 추적한다. 마지막으로 coroutineScope 내에서 시작된 모든 코루틴이 완료되면 loadLots는 자유롭게 리턴된다. Note scope과 코루틴 간의 부모-자식 관계는 Job 객체를 사용해 생성된다. 그러나 종종 코루틴과 scope 사이의 관계를 그 수준으로 뛰어 들지 않고 생각할 수 있다. 기억해야 하는 것은 coroutineScope과 supervisorScope은 자식 코루틴들이 완료될 때까지 기다릴 것이라는 사실이다. 같은 말을 반복하는 것 같지만, 중요해서 그렇다고 생각한다. 많은 일이 있지만, 중요한 것은 coroutineScope 또는 supervisorScope를 사용해 suspend 함수에서 안전하게 코루틴을 시작할 수 있다는 것이다. 새로운 코루틴이 시작되더라도 새로운 코루틴이 완료될 때까지 항상 호출자를 일지 중지하기 때문에 실수로 누수가 발생하지 않는다. 그리고 또 멋진 점이 있는데 coroutineScope이 자식 scope을 생성한다는 것이다. 그래서 부모의 scope이 취소되면 모든 새 코루틴으로 취소가 전달된다. 예를 들어, 호출자가 viewModelScope인 경우 사용자가 화면을 벗어나면 1000개의 코루틴이 모두 자동으로 취소된다. 이는 깔끔하다. 에러에 대한 설명으로 넘어가기 전에 supervisorScope과 coroutineScope에 대해 마지막으로 살펴보는 것이 좋을 것 같다. 주요 차이점은 다음과 같다. coroutineScope : 자식 중 어느 것이라도 실패할 때마다 coroutineScope은 취소될 것이다. 따라서 하나의 네트워크 요청이 실패하면 다른 모든 요청이 즉시 취소된다. supervisorScope : 요청이 실패하더라도 다른 요청을 계속하기 위해서는 이를 사용할 수 있다. 다른 자식 중 하나가 실패해도 다른 자식을 취소하지 않는다. Signal errors when a coroutine fails코루틴에서 일반 함수와 마찬가지로 예외가 발생하여 오류가 생긴다. suspend 함수의 예외는 resume 하여 호출자에게 다시 발생한다. 일반 함수와 마찬가지로 오류를 처리하려고 시도하거나 제한하지 않고 원하는 경우, 다른 스타일로 오류 처리를 수행하도록 추상화를 작성할 수도 있다. 그러나 코루틴에서 오류가 손실될 수 있는 상황이 있다. 123456789val unrelatedScope = MainScope()// example of a lost errorsuspend fun lostError()&#123; // async without structured concurrency unrelatedScope.async&#123; throw InAsyncNoOneCanHearYou(\"except\") &#125;&#125; 위 코드는 Structured concurrency 없이 새로운 코루틴을 시작하는 관련 없는 코루틴 범위를 선언한다. 처음에는 Structured concurrency이 유형과 프로그래밍 방식의 조합이며 suspend 함수에 관련되지 않은 코루틴 범위를 도입하는 것이 Structured concurrency의 프로그래밍 방식을 따르지 않는다는 것을 기억해야 한다. 사실 이 부분은 무엇을 말하려는 건지 이해가 잘 가지 않는다. async는 결국 예외를 다시 던질 곳에서 await를 호출한다고 가정하기 때문에 이 코드에서 오류가 손실된다. 그러나 호출 대기를 절대하지 않으면 예외는 참을성 있게 기다리는 동안 영원히 저장된다. Structured concurrency는 코루틴 오류가 발생했을 때 호출자 또는 scope에게 통지되도록 보장한다. 만약 위 코드에서 Structured concurrency를 사용한다면 에러는 정확하게 호출자에게 던져진다. 1234567suspend fun foudError()&#123; coroutineScope&#123; async&#123; throw StructuredConcurrencyWill(\"throw\") &#125; &#125;&#125; coroutineScope은 모든 하위 항목이 완료될 때까지 기다리므로 실패시 알람을 받을 수도 있다. coroutineScope으로 시작된 코루틴에서 예외가 발생하면 coroutineScope은 이를 예외로 호출할 수 있다. supervisorScope 대신 coroutineScope을 사용하고 있기 때문에 예외가 발생하면 다른 모든 자식들도 즉시 취소된다. Using structured concurrency이 포스팅에서 structured concurrency을 소개하고 작업 누출을 피하기 위해 코드가 Android ViewModel에 잘 맞는지 보았다. 또한, suspend 함수를 쉽게 추론하는 방법에 대해서도 이야기 해봤다. 결과를 반환하고 돌아오기 전에 작업을 완료하고 표면에 있는 예외 처리를 통해 오류를 알리는 것이다. 대신 구조화되지 않은 동시성을 사용하면 호출자가 알지 못하는 코루틴이 실수로 작업을 유출하기 쉽다. 이 작업은 취소할 수 없으며 예외가 다시 발생한다고 보장할 수 없다. 이로 인해 코드가 더욱 놀라워지고 모호한 버그가 발생할 수 있다. 새로운 관련되지 않은 CoroutineScope을 도입하거나 GlobalScope이라는 전역 범위를 사용하여 구조화되지 않은 동시성을 만들 수 있지만, 호출 벙뮈보다 오래 살기 위해 코루틴이 필요한 경우는 드물지만 unstructured concurrency를 고려해야 한다. 그런 다음 unstructured 코루틴을 추적하고 오류를 처리하며 좋은 취소 스토리를 갖도록 구조를 직접 추가하는 것이 좋다. structured concurrency에 대한 경험이 있는 경우 structured concurrency에 익숙해져야 한다. 구조와 보증은 suspend 함수와의 상호작용을 보다 안전하고 쉽게 만든다. 코드를 보다 쉽게 읽고 덜 놀라게 만들 수 있으므로 structured concurrency을 최대한 많이 사용하는 것이 좋다. 이 포스팅의 도입부에서 structured concurrency이 우리를 위해 해결하는 세 가지를 나열했고, 다음과 같다. 더 이상 필요하지 않으면 작업을 취소해라. 실행 중인 동안 작업을 추적해라. 코루틴이 실패하면 에러를 나타내라. structured concurrency은 우리에게 우리의 코드에 대한 보장을 제공하는 것을 달성한다. structured concurrency에 대한 보장은 다음과 같다. scope이 취소되면 모든 코루틴이 취소된다. suspend 함수가 리턴할 때 모든 작업이 완료된다. 코루틴 오류가 발생하면 호출자 또는 scope에 알린다. structured concurrency 보장을 통해 코드를 보다 안전하고 쉽게 추론할 수 있으며 누출 작업을 피할 수 있다. 이번 포스팅에서는 structured concurrency에 관해서 많은 이야기가 있었다. 아직까지 뭔가 이해가 잘 안되지만, 조금씩 더 보면서 이해하려 노력해봐야겠다. 참고 Coroutines on Android (part II): Getting started","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Coroutine","slug":"Coroutine","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Coroutine/"},{"name":"Basic","slug":"Basic","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Basic/"}]},{"title":"[Android] Coroutine Document #1","slug":"Coroutine-Part-1","date":"2019-11-01T14:32:25.000Z","updated":"2019-11-03T12:54:54.076Z","comments":true,"path":"2019/11/01/Coroutine-Part-1/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/11/01/Coroutine-Part-1/","excerpt":"","text":"Coroutine Intro 시리즈를 통해서 개략적으로 알아보고 제대로 접근하려 했는데, 뭐 아는게 없으니 개략적으로 접근하기도 어렵다. 그냥 처음부터 제대로 접근하는 편이 나을 것 같아 괜찮은 글을 번역하면서 정리하려고 한다. 이 시리즈가 끝나면 공식 문서에 대해서 정리하려고 계획 중이다. 한 번에 이해하기 어렵다보니 여러 글들을 참고해서 정리하고 이해하는 게 필자한테 도움이 더 될 것 같아서다. 그리고 실제 코드에 적용하면서 내 것으로 만들도록 노력할 것이다. 해당 글은 아래의 블로그를 참고해서 작성한 정리 글이다.Coroutines on Android (part I): Getting the background 코루틴은 어떤 문제를 해결할까? 코틀린 코루틴은 안드로이드에서 비동기 코드를 단순화하는데 사용할 수 있는 새로운 스타일의 동시성에 관한 것을 도입했다. 코틀린 1.3에서 코루틴이 새롭게 밝혀졌지만, 코루틴의 개념은 프로그래밍 언어가 시작된 이래 계속 존재했었다. 코루틴을 사용한 첫 언어는 Simula였다. 지난 몇년 동안 코루틴은 인기가 높아졌으며 지금은 JavaScript, C#, Python, Ruby 등과 같은 인기 있는 프로그래밍 언어에 포함되었다. Kotlin 코루틴은 대규모 응용 프로그램을 구축하는데 사용된 기존 개념을 기반으로 한다. Android에서 코루틴을 다음 두 가지 문제에 대한 훌륭한 해결책이라고 할 수 있다. 즉, 코루틴의 사용 목적이라고 해석할 수도 있다. 1. Long running tasks 웹 페이지를 가져오거나 API와 상호 작용하기 위해서는 네트워크 요청을 해야 한다. 마찬가지로 데이터베이스에서 데이터를 읽거나 디스크에서 이미지를 로드하는 것은 파일을 읽는 것이다. 이런 종류들을 Long running tasks라 부른다. 즉, 너무 오랜 시간이 걸려서 앱이 정지하고 오래 걸리는 작업들을 기다려야 하는 것이다. Android에서 모든 앱에는 UI 처리 및 사용자 상호 작용 조정을 담당하는 기본 스레드가 존재한다. 이 스레드에서는 너무 많은 작업이나 시간이 오래 걸리는 작업이 발생하면 앱이 중단되거나 느려져 바람직하지 않은 사용자 경험이 발생한다. 그래서 기본적으로 장시간 실행되는 작업은 시간이 오래 걸려 메인 스레드를 차단한다. Long running tasks는 메인 스레드를 차단하지 않고 완료되어야 한다. 그래서 애플리케이션은 정지된 애니메이션, 터치 이벤트에 느리게 반응하는 등의 모습을 보여주어서는 안된다. 2. Main safety 메인 스레드에서 suspend 함수가 호출되는 것을 보장해준다. 즉, 메인 쓰레드에서 오래 걸리는 작업을 실행하는 코루틴 코드를 실행시켜도 되게끔 하는 것이다. 위에서는 메인 쓰레드에서 오래 걸리는 작업을 피하라고 했는데 이와 상충되는 의견일 수 있다. 보통 쓰레드에서는 별도의 쓰레드를 만들고 그 안에서 오래 걸리는 작업을 실행시킨다. 그러나 코루틴 프레임워크를 사용하면 메인 쓰레드에서 오래 걸리는 작업을 실행시켜도 알아서 쓰레드 관리가 되어지기 때문에 그럴 필요가 없다. 즉, 쓰레드 관리가 더 쉬워진다.(이유는 코루틴이 내부적으로 알아서 적절한 쓰레드를 쓰기 때문이다.) 자, 그럼 정리하면 코루틴이 달성하려는 목적은 두 가지로 요약할 수 있다. 먼저, 시간이 오래 걸리는 작업을 메인 쓰레드에서 수행해도 메인 쓰레드가 멈추지 않게 할 수 있다. 그리고 두 번째로 메인 쓰레드에서 오래 걸리는 작업을 실행하는 코루틴 코드를 실행시켜도 상관이 없게 할 수 있다. 메인 스레드에서 네트워크 요청을 수행하기 위해 사용하는 일반적인 패턴은 콜백 패턴이다. 이는 훌륭한 패턴 중 하나이다. 콜백 패턴은 나중에 코드를 다시 호출하는 데 사용할 수 있는 라이브러리에 대한 핸들을 제공한다. 1234567class viewModel: ViewModel()&#123; fun fetchDocs()&#123; get(\"developer.android.com\")&#123; result -&gt; show(result) &#125; &#125;&#125; 위의 코드에서 메인 스레드에서 get()을 호출했더라도 다른 스레드를 사용해 네트워크 요청 작업을 수행한다. 그런 다음 네트워크로부터 결과를 사용할 수 있게 되면 기본 스레드에서 콜백이 호출될 것이다. 이는 Long running tasks를 처리하는 훌륭한 방법이며, Retrofit과 같은 라이브러리는 메인 스레드를 차단하지 않고도 네트워크 요청을 할 수 있도록 도와준다. 이게 가능한 이유는 Retrofit 내부에서 스레드를 관리 및 사용하기 때문이다. Using coroutines for long running tasks코루틴은 위에서 살펴봤던 fetchDocs와 같은 시간이 오래 걸리는 작업을 관리하는데 사용되는 코드를 단순화 하는 방법을 제공할 수 있다. 그러면 코루틴이 어떻게 이처럼 시간이 오래 걸리는 작업을 위한 코드를 단순화하는지 알아보고 이를 기존 코드에 적용해보자. 123456789101112// Dispatchers.Mainsuspend fun fetchDocs()&#123; // Dispatchers.Main val result = get(\"developer.android.com\") // Dispatchers.Main show(result)&#125;suspend fun get(url: String) = withContext(Dispatchers.IO)&#123; ...&#125; 위의 코드는 기존의 콜백과는 무언가 조금 다르다. 그러면 위의 코드를 보고 드는 의문은 뭐가 있을까?? 이 코드는 메인 스레드를 차단하지 않는가? 네트워크 요청을 기다리거나 차단하지 않고 get에서 어떻게 결과를 반환하는가? 코루틴은 이 코드를 실행하고 메인 스레드를 차단하지 않는 방법을 제공한다. 코루틴은 두 가지 새로운 연산을 추가함으로써 기존의 함수들을 기반으로 한다. 코루틴은 호출과 반환이외에도 suspend와 resume을 추가한다. suspend : 현재 코루틴 실행을 일시 중지하고 모든 지역 변수를 저장 resume : 일시 정지된 곳에서부터 suspended된 코루틴을 지속한다. 이 기능은 Kotlin에 의해 함수의 suspend 키워드에 의해 추가된다. 그리고 다른 suspend 함수에서 suspend 함수를 호출하거나 새로운 코루틴을 시작하기 위해서 launch와 같은 코루틴 빌더를 사용할 수도 있다. 콜백을 대체하기 위해서 suspend와 resume을 함께 사용한다. 이 말이 어떤 의미인지 이해하기 위해서 위에서 살펴봤던 예제를 다시 생각해보자. get은 네트워크 요청을 시작하기 전에 코루틴을 일시 정지(suspend)한다. get 함수는 여전히 메인 스레드에서 네트워크 요청을 실행한다. 그런 다음 네트워크 요청이 완료되면 콜백을 호출해 메인 스레드에 알리는 것 대신에 일시 정지된 코루틴을 다시 시작할 수 있다.(resume) 위의 gif를 보면서 확인해보자. fetchDocs의 실행 방식을 살펴보면 suspend의 작동 방식을 확인할 수 있다. 코루틴이 일시 중단될 때마다 현재 스태 프레임(Kotlin이 실행중인 함수와 변수를 저장 및 추적하기 위해 사용하는 장소)은 나중에 복사 및 저장된다. 다시 시작되면 스택 프레임이 저장된 위치에서 다시 복사되고 다시 실행되기 시작한다. 애니메이션 도중 메인 스레드의 모든 코루틴이 일시 중단되면 메인 스레드는 자유롭게 화면을 업데이트하고 사용자 이벤트를 처리할 수 있다. 동시에 suspend, resume을 깔끔하게 callbacks을 대체한다. 여기서 강조할 점은 메인 스레드의 모든 코루틴이 일시 정지되면 메인 스레드는 다른 작업을 자유롭게 수행할 수 있다는 점이다. blocking 네트워크 요청과 비슷한 간단한 순차적 코드를 작성했지만, 코루틴은 코드를 원하는 방식으로 정확하게 실행하고 메인 스레드를 차단하지 않는다. Main-safety with coroutinesKotlin 코루틴에서 잘 작성된 suspend 함수들은 항상 메인 스레드에서 호출하는 것이 안전하다. 그 함수들이 무엇을 하든 그 함수들은 항상 어떤 스레드가 그들(함수)을 호출하도록 허용해야 한다. 위의 의미를 다시 한번 정리하면, suspend 함수들은 어떤 스레드에서라도 호출될 수 있도록 허용이 되야 한다는 것이다. 음, 아직까지 크게 와닿지 않는다. 더 살펴보자. 위와 같은 의미를 가진다하더라도 안드로이드 앱에서는 메인 스레드에서 수행하기에는 너무 느린 작업이 많이 존재한다. 예를 들면, 네트워크 요청, JSON 구문 분석, 데이터베이스에서 읽기 또는 쓰기, 심지어 큰 목록을 불러오는 것도 있다. 이 중 하나라도 사용자가 jank(화면 버벅임 현상)을 볼 수 있을 정도로 느리게 실행될 가능성이 있으면 메인 스레드 밖에서 실행해야 한다. 이는 우리가 안드로이드 개발을 하면서 비동기 작업을 수행하기 위해서 알고 있었던 사실 중 하나이다. 그렇기 때문에 이해하기가 그리 어렵지는 않다. suspend를 사용한다고 해서 Kotlin이 백그라운드 스레드에서 함수를 실행하도록 지시하는 것은 아니다. 코루틴이 메인 스레드에서 실행될 것이라고 명확하고 자주 말해야 한다. 왜냐하면 우리가 까먹기 때문이다. 실제로 UI 이벤트에 대한 응답으로 코루틴을 시작할 때 Dispatchers.Main.immediate를 사용하는 것이 좋다. 이렇게 하면 Main-Safety가 필요한 Long running task를 수행하지 않으면 결과가 사용자의 바로 다음 프레임에서 사용할 수 있기 때문이다. 다시 한 번 짚고 넘어가야 할 것은 코루틴은 메인 스레드에서 실행되며 suspend가 백그라운드를 의미하지 않는다는 것이다. 메인 스레드 Main-safe에 비해 너무 느리게 작동하는 함수를 만들기 위해서 Kotlin 코루틴에게 Default 또는 IO dispatcher에서 작업을 수행하도록 지시할 수 있다. 코틀린에서는 모든 코루틴이 메인 스레드에서 실행될 때에도 dispatcher에서 실행되도록 해야 한다. 그리고 코루틴은 스스로 정지할 수 있으며 dispatcher는 스스로 resume하는 방법을 알고 있다. 코루틴이 실행되는 곳을 지정하기 위해 Kotlin은 스레드 디스패치에 사용할 수 있는 3개의 Dispatcher를 제공한다. 1. Dispatchers.Main 안드로이드의 Main Thread UI와 상호 작용을 한다. 가벼운 작업을 수행한다. suspend 함수를 호출한다. UI 함수를 호출한다. LiveData를 업데이트한다. 2. Dispatchers.IO 메인 스레드에서 디스크 및 네트워크 IO 작업에 최적화되었다. 데이터베이스에서 파일을 읽거나 쓸 수 있고 네트워크 작업을 할 수 있다. 3. Dispatchers.Default 메인 스레드에서 CPU 집약적인 작업에 최적화되었다. 리스트를 정렬하거나 JSON을 파싱하거나, DiffUtils과 같은 작업을 수행한다. 만약 suspend 함수, RxJava 또는 LiveData를 사용하면 Room이 자동으로 Main-Safety를 제공한다. Retrofit 및 Volley와 같은 네트워킹 라이브러리는 자체적으로 스레드를 관리하며 Kotlin 코루틴과 함께 사용할 때 코드에서 명시적인 Main-Safety를 요구하지 않는다. 위의 예시를 계속해서 발전시켜보자. Dispatchers를 사용해 get 함수를 정의해보자. get() 함수 본문 내에서 withContext(Dispatchers.IO)를 호출하여 IO Dispatcher에서 실행될 블록을 만든다. 그러면 해당 블록에 넣은 코드는 항상 IO Dispatcher에서 실행된다. withContext 자체는 suspend 함수이기 때문에 코루틴을 사용하여 Main Safety을 제공한다. 아래의 간단한 코드와 주석을 통해서 다시 이해해보자. 123456789101112131415// Dispatchers.Mainsuspend fun fetchDocs()&#123; // Dispatchers.Main val result = get(\"developer.android.com\") // Dispatchers.Main show(result)&#125;// Dispatchers.Mainsuspend fun get(url: String) = withContext(Dispatchers.IO)&#123; // Dispatchers.IO // perform blocking network IO here &#125; // Dispatchers.Main 코루틴을 사용하면 세밀한 제어로 스레드 디스패치를 수행할 수 있다. withContext를 사용하면 결과를 반환하기 위해 콜백을 도입하지 않고도 코드가 실행되는 스레드를 제어할 수 있으므로 데이터베이스에서 파일을 읽거나 네트워크 요청을 수행하는 것과 같은 작은 함수에 적용할 수 있다. 따라서 Main을 포함한 모든 디스패처에서 모든 함수를 안전하게 호출할 수 있도록 withContext를 사용하는 것이 좋다. 이렇게하면 호출자가 함수를 실행하는데 어떤 스레드가 필요한지 생각할 필요가 없다. 위 예제에서 fetchDocs는 메인 스레드에서 실행되지만, 백그라운드에서 네트워크 요청을 수행하는 get() 함수를 안전하게 호출할 수 있다. 코루틴이 suspend와 resume을 지원하기 때문에 withContext 블록이 완료되는 즉시 메인 스레드의 코루틴이 결과와 함께 재시작된다. 다시 강조하지만, 잘 작성된 suspend 함수는 항상 메인 스레드에서 호출하는 것이 안전하다. 모든 suspend 함수를 기본적으로 Main safe하게 사용하는 것이 좋다. 디스크, 네트워크에 닿거나 너무 많은 CPU를 사용하는 작업을 수행하는 경우, withContext를 사용하여 메인 스레드에서 안전하게 호출해야 한다. 이는 Retrofit 및 Room과 같은 라이브러리를 기반으로 따르는 패턴이다. 만일 코드 베이스 전체에서 이 스타일을 따르는 경우, 코드가 훨씬 단순해지고 스레딩 문제를 응용 프로그램 논리와 혼용하지 않아도 된다. 일관성 있게 따라가면 코루틴은 메인 스레드에서 자유롭게 실행되며 간단한 코드로 네트워크 또는 데이터베이스 요청을 할 수 있으며 사용자에게 화면 버벅임과 같은 jank가 표시되지 않도록 한다. Performance of withContext(withContext의 성능)withContext는 Main safety를 제공하기 위해 콜백 또는 RxJava만큼 빠르다. 그리고 상황에 따라서 콜백으로 가능한 것 이상의 withContext 호출로 최적화할 수도 있다. 만약, 함수가 데이터베이스를 10번 호출할 경우, Kotlin에게 10개의 호출 주위에 있는 withContext를 한 번만 전환하도록 지시할 수 있다. 그런 다음 데이터베이스 라이브러리가 withContext를 반복적으로 호출하더라도 동일한 디스패처에 유지되고 빠른 경로를 따른다. 또한, Dispatchers.Default와 Dispatchers.IO 간 전환은 가능할 때마다 스레드 전환을 피하도록 최적화되어 있다. What’s next이번 포스트에서 코루틴이 어떤 문제를 해결하는지 살펴보았다. 코루틴은 프로그래밍 언어에서 매우 오래된 개념으로 최근 네트워크와 상호 작용하는 코드를 더 간단하게 만들 수 있는 기능으로 인해 대중화되었다. 그리고 위에서도 계속 언급했던 두 가지 문제를 해결하는데 간략하게 정리하면 다음과 같다. 네트워크에서 읽기, 디스크 읽기, 대규모 JSON 결과 구문 분석과 같은 장기 실행 작업을 위한 코드를 단순화한다. 코드의 읽기 및 쓰기를 어렵게 하지 않으면서 메인 스레드를 실수로 차단하지 않도록 정확한 Main Safety를 수행한다. 참고 Coroutines on Android (part I): Getting the background","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Coroutine","slug":"Coroutine","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Coroutine/"},{"name":"Basic","slug":"Basic","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Basic/"}]},{"title":"Carousel","slug":"Carousel","date":"2019-11-01T14:16:27.000Z","updated":"2019-11-01T14:16:27.978Z","comments":true,"path":"2019/11/01/Carousel/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/11/01/Carousel/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"[Android] Coroutine 3. Intro","slug":"Android-Coroutine3","date":"2019-10-31T13:32:26.000Z","updated":"2019-11-01T14:13:46.760Z","comments":true,"path":"2019/10/31/Android-Coroutine3/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/31/Android-Coroutine3/","excerpt":"","text":"한글로 된 블로그를 보며 개념을 익히고 친숙해진 다음에 영어로 된 글과 공식 문서 내용을 공부하고 번역해 옮길 예정이다. 예비군을 다녀온 뒤라 지체된 감이 없지 않아 있는데, 시간을 내서 얼른 마무리 지어야 겠다. Coroutine코루틴은 두 가지 접근 방법을 통해 사용이 가능하다. 코루틴을 활용하는 데 있어 CoroutineScope이 interface로 정의되어 있다. 이 interface 정의를 통해 매번 원하는 형태의 CoroutineContext를 정의할 수 있고, Coroutines의 생명 주기를 관리할 수 있다. CoroutineScope을 상속받아 CoroutineScope과 GlobalScope 등에서 이를 활용하고 있다. 애플리케이션이 동작하는 동안 별도의 생명 주기를 관리하지 않고 사용할 수 있는 GlobalScope이 있다. 이는 안드로이드 앱이 처음 시작부터 종료할 때까지 하나의 CoroutineContext 안에서 동작하도록 할 수 있다. 이러한 CoroutineScope과 GlobalScope에 대해 알아보자. 필요할 때 선언하고, 종료하자.필요할 때 선언하고 종료하는 게 필요하다.현재 화면을 벗어나면 더 이상 통신을 할 필요가 없을 수 있다. 리스트를 갱신하기 위한 최신 데이터를 불러온다. 리스트를 불러오는 중 서버 응답이 느려 답답해진 사용자는 창을 닫아버린다. 이 경우는 백그라운드에서 계속 다운로드할 필요가 없다. 물론 캐싱을 하는 앱이라면 이후의 처리가 필요하므로 별도의 작업을 하겠지만, 지금은 그렇지 않다. 그래서 이 경우에는 굳이 GlobalScope을 활용해 이 작업을 살려둘 필요가 없다. 이럴 때는 매번 새롭게 생성하는 CoroutineScope을 활용함으로써 효율을 높일 수 있다. CoroutinScope의 내부 초기화 코드는 아래와 같다. 함수이며, 아래를 보면서 이해해보도록 하자. 123@Suppress(\"FuctionName\")public fun CoroutineScope(context: CoroutineContext): CoroutinScope = ContextScope(if( context[Job] !=null) context else context + Job()) 내부에 정의되어 있는 클래스는 ContextScope이라는 클래스를 초기화해서 사용하고 있다는 것을 알 수 있다. 123internal class ContextScope(context: CoroutineContext): CoroutineScope&#123; override val coroutineContext: CoroutineContext = context&#125; 결국 CoroutineScope은 CoroutineContext(Main - 안드로이드에서는 UI Thread 혹은 IO Thread)를 통해 원하는 형태로 초기화하는 하나의 block을 만들어 사용함을 알 수 있다. 앱이 동작하는 동안 사용해보자.앱이 동작하는 동안 사용할 수 있는 것은 GlobalScope이다. 앱을 사용하면서 장시간 동작해야 할 thread가 필요하다면 매번 생성하는 CoroutineScope보다는 최초 접근 시 만들어지는 GlobalScope이 효율적이다. 이러한 GlobalScope을 사용하더라도 안드로이드 환경에서는 백그라운드 잡이 또 필요하여 Work Manager을 활용해야 한다. 참고해볼 만한 자료 Location all the time with WorkManager!! WorkManager로 정기적인 백그라운드 작업 수행하기 Intro 1,2편에 이어서 3편은 Intro 부분에 대해서 간략히 알아보고 영어로 된 문서, 개념 관련 글을 찾아서 정리하려 했다. 하지만, 태환님의 블로그를 보면서 정리하던 도중 글의 수준이 갑자기 높아지는 것 같아서 이해하지 못하는 부분이 많이 생겼다. 그래서 현재 필자의 수준으로는 이해하기 어려운 부분이 많아 해당 시리즈는 접고 설명이 잘 나와 있는 외국 블로그를 번역해서 정리해보려고 한다.","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Corotine","slug":"Corotine","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Corotine/"},{"name":"비동기, 동기","slug":"비동기-동기","permalink":"http://victorywoolee/victorywoolee.github.io/tags/비동기-동기/"}]},{"title":"[Android] Coroutine 2. Intro","slug":"Android-Coroutine2","date":"2019-10-27T13:40:14.000Z","updated":"2019-10-31T13:17:25.818Z","comments":true,"path":"2019/10/27/Android-Coroutine2/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/27/Android-Coroutine2/","excerpt":"","text":"해당 글은 권태환님의 블로그를 참고하여 작성된 글입니다. 사실 RxJava는 안드로이드 개발에서 없어서는 안될 존재가 되었다. 많은 개발자들이 사용하고 있으며 다양한 라이브러리가 존재한다. 하지만, RxJava를 이해하는데 상당한 시간이 소요되며, 러닝커브도 꽤 높은 편이다. 그러면 다음의 코드를 보고 이해하기 위해서 필요한 개념이 무엇인지 알아보자. 123456789101112131415Flowable.range(0,10) .observeOn(Schedulers.io()) .subscribeOn(Schedulers.io()) .map&#123; it+1 &#125; .filter&#123; it &gt; 4 &#125; .observeOn(AndroidSchedulers.mainThread()) .subscribe( &#123; println(it) // UI에서 처리 &#125;,&#123; it.printStackTrace() // 오류 처리 &#125; ) RxJava에서 사전에 알아야 할 구문 Flowable : 리액티브 스트림을 구현하기 위한 패턴의 시작 subscribeOn : 리액티브 스트림에서 사용할 기본 스케줄러이며, observeOn으로 스케줄러를 교체하기 전까지 기본으로 사용한다. 주로 어떤 작업을 어느 스레드에서 할지 정한다. obvserveOn : 스케줄러의 변경이 필요하면 observeOn을 이용해 스케줄러 교체가 가능하다. 다음 observeOn이 오기 전까지 유효하다. 주로 어떤 작업의 결과를 어느 스레드에 반영할지 정한다. map : 스트림에서 넘어온 데이터를 변환한다. filter : 스트림에서 넘어온 데이터에 filter를 걸 수 있다. 조건의 결과 값이 true인 경우에만 다음 구문을 실행한다. subsrcibe : 모든 리액티브 스트림은 subscribe 정의가 없으면 동작하지 않는다. 즉, 구독을 해야 데이터를 발행하며 받을 수 있다. subscribe 정의에서는 onNext, onError, onCompleted을 제공한다. Schedulers.io() : RxJava에서 사용하는 스케줄러이며, AndroidSchedulers.mainThread()를 별도로 제공한다. Coroutine으로 작성한다면?12345678910CoroutineScope(Dispatchers.Default).launch&#123; (0..9).map&#123; it + 1 &#125; .filter&#123; it &gt; 4 &#125;.forEach&#123; launch(Dispatchers.Main)&#123; // UI 처리. println(it) // UI에서 출력한다. &#125; &#125;&#125; Corotine에서 알아야 할 것은? CoroutineScope : Coroutine을 동작하기 위해서 CoroutineScope을 정의할 수 있다. CoroutineScope은 기본 스케줄러를 함께 지정해야 하며, RxJava의 subscribeOn과 같다. launch : 코루틴으로 동작해야 할 코드 스콥을 지정한다. 이때, 이 스콥에서 사용할 스케줄러를 함께 지정할 수 있으며, 지정하지 않을 경우 CoroutineScope에서 지정한 스케줄러를 사용한다. Dispatchers : 코루틴에서 사용할 스케줄러를 정의하며, Default(Work Thread), Main(UI Thread) 등을 지정할 수 있다. RxJava보다 알아야 할 구문이 적어 이해하기는 쉽다. 처음에는 RxJava보다 이해하기 쉽지만 시간이 지날수록 RxJava 만큼의 학습 비용이 든다. 비교1. 코드의 첫 부분 RxJava RxJava는 용도별로 Reactive stream 형태를 제공한다. 아래와 같이 5가지를 제공하며, 이를 통해 스트림을 만들 수 있다. Flowable, Observable, Single, Completable, Maybe Coroutine Coroutine은 interface로 정의되어있으며, 모든 Scope은 CoroutineScope을 최상위로 두고 있다. 이를 활용한 GlobalScope을 함께 제공한다. RxJava처럼 subscribe 호출시 동작하도록 하려면 suspend로 함수 정의를 해둘 수 있는데, 단순 CoroutineScope은 즉시 실행 및 event 대기를 한다. launch의 return 결과인 job을 통해 일시 정지, 종료, 취소, 시작 등을 제어할 수 있다. CoroutineScope : 새로운 CoroutineScope을 생성할 수 있으며, 스케줄러를 함께 초기화해야 한다. CoroutineScope은 Activity의 생명주기에 따라 동작하도록 베이스 코드를 함께 사용하는 것을 추천하고 있다. GlobalScope : CoroutineScope을 상속받아 구현되어 있으며, object인 싱글톤으로 만들어져 있다. GlobalScope은 Application의 생명주기에 따라 동작해야 하며, 서비스와 같은 형태에서 사용하는 것을 추천한다. CoroutineScope, GlobalScope으로 객체를 생성하였다면, 코드 동작을 위한 액션을 지정해줘야 한다. launch : 일반적인 코루틴을 사용할 때 쓰며, launch에서 스케줄러를 지정하지 않으면 CoroutineScope의 스케줄러를 따르며, 지정할 경우 블록 안에서만 스케줄러에 따라 동작한다. async : async/await이 필요할 경우 사용할 수 있다. actor : actor를 사용할 경우 이벤트 전달이 가능하며, suspend에서 데이터 전달과 send와 기본 Thread에서 이벤트 전달이 가능한 offer 두 가지를 제공한다. 이를 Android에서는 OnClick에 함께 사용할 수 있다. 2. 스케줄러 교체 RxJava : RxJava는 기본적으로 전체 스트림에서 사용할 기본 subscribeOn과 매번 교체할 수 있는 observeOn을 제공한다. subscribeOn : Reactive-stream에서 기본적으로 사용할 스케줄러를 지정한다. observeOn으로 새로운 스케줄러를 지정하기 전까지 유지된다. observeOn : Reactive-stream의 진행 중 UI/Background Thread를 언제나 교체할 수 있다. observeOn으로 스케줄러를 지정하면 스케줄러가 변경되며, 이후 stream에서 이를 따른다. Coroutine : 코루틴은 CoroutineScope에서는 생성 시 Dispatchers를 지정하며, GlobalScope은 기본으로 EmptyCoroutineContext으로 지정되어 있다. 이 Dispatchers 정의는 RxJava의 subscribeOn과 동일하게 동작한다. 즉, 사용할 스케줄러를 지정하는 역할을 한다. 이후, RxJava의 observeOn과 동일한 행동을 원할 경우 launch()에서 새로운 Dispatches을 지정해주면 아래와 같이 지정할 수 있다. launch(Dispatches.Default) : Work 스레드를 사용해 동작한다. launch(Dispatches.Main) : Main 스레드를 사용해 동작한다. 위의 정의의 Dispatches 선택에 따라 UI/Background Thread의 형태를 지정할 수 있다. launch에서 Dispatches를 지정하지 않으면, 상위(CoroutineScope, GlobalScopr)의 기본 Dispatches에 따라 동작한다. 이 동작은 observeOn과 동일한 결과를 가지지만, RxJava처럼 이후 스트림까지 영향을 받지는 않는다. 3. Releas 하기 RxJava : subscribe가 호출되면 disposable을 반환한다. Disposable을 묶어서 Android의 생명주기의 onDestroy에서 disposable.clear를 호출해 기본 Reactive-stream을 종료할 수 있다. Coroutine : Job이 반환되거나, coroutineContext에 job을 함께 지정할 수 있는데 아래와 같이 할 수 있다. 123456789101112val job : Job = Job()val coroutineContext: CoroutineContext get() = DispatchersProvider.main + job// onDestroy에서 job을 cancel할 수 있다.override fun onDestroy()&#123; super.onDestroy() job.cancel()&#125; 참고 RxJava와 Kotlin Coroutines 비교해보기","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Corotine","slug":"Corotine","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Corotine/"},{"name":"비동기, 동기","slug":"비동기-동기","permalink":"http://victorywoolee/victorywoolee.github.io/tags/비동기-동기/"}]},{"title":"[Android] Coroutine 1. Intro","slug":"Android-Coroutine1","date":"2019-10-27T11:58:06.000Z","updated":"2019-10-27T13:40:02.402Z","comments":true,"path":"2019/10/27/Android-Coroutine1/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/27/Android-Coroutine1/","excerpt":"","text":"코루틴에 대해서 알아보려고 한다. 공부를 시작하면서 함께 작성할 포스팅이 될 예정이다.먼저, 공부 방법에 대해서 적어보려 한다. 먼저, 한글로 된 블로그로 어떤 개념이고 언제 사용하는지 감을 잡으려고 한다. 태환님 블로그 [날로먹는 Coroutine] #1 - Basic 그리고 공식 문서와 잘 정리된 해외 블로그의 글을 참고하려 한다. Kotlin Coroutines on Android (part I): Getting the background Coroutine 서브 루틴 개발을 하다 보면 중복 코드를 자연스럽게 함수로 만들어 호출해서 사용한다. 굳이 동일한 코드를 여러 장소에 두어 사용할 필요가 없고, 수정 시 수정 범위를 최소화하기 위해서이기도 하다. Frgment를 replace하는 함수를 만들어두고, replace가 필요한 여러 곳에서 활용이 가능하도록 만들 수 있다. 이런 형태를 Subroutine이라 부른다. 위키에 따르면 언어별로 부르는 용어가 다양한데, Java에서는 function이라 부른다. 결과적으로 서브루틴은 함수를 호출하고, 서브루틴의 모든 처리가 완료되어야 다음 줄의 코드를 실행할 수 있다. 코루틴 서브루틴의 확장 개념인 코루틴은 다음과 같은 장점을 가지고 있다. 여러 다른 지점에서 입력과 종료가 일어난다. 실행을 일시 중지하고 호출자 또는 다른 코루틴으로 이동할 수 있다. 호출자는 언제든 다시 코루틴을 실행시킬 수 있다. 단순하게 보면 Thread처럼 보일 수 있지만, Thread보다 훨씬 저렴한 비용으로 동작한다. Subroutine처럼 함수 형태로 코드를 작성해 가독성이 높다. Coroutine과 ThreadJava Thread는 하나의 프로세스에서 여러 개의 작업을 실행할 수 있지만 OS의 Native Thread에 직접 링크되어 동작하여 많은 시스템 자원을 사용한다. Thread간 전환 시에도 CPU의 상태 체크가 필요하므로 그만큼의 비용이 발생한다. 반면, Coroutine은 즉시 실행하는 게 아니며, Thread와 다르게 OS의 영향을 받지 않아 그만큼 비용이 들어가지 않는다. 그리고 개발자가 직접 루틴을 언제 실행할지, 언제 종료할지 모두 지정이 가능하다. 이렇게 생성한 루틴은 작업 전환 시에 시스템의 영향을 받지 않아 그에 따른 비용은 발생하지 않는다. 또한, suspension 포인트를 개발자가 지정하기 때문에 무작위로 종료할 순 없다. 다음은 Stack OverFlow에 달린 댓글에 대해서 번역해서 작성한 내용이다. 번역한 내용과 필자의 생각을 조금 덧붙여서 설명하겠다. 코틀린 코루틴은 다른 언어의 코루틴과 조금 다르다. 기본적으로 스택과 스택리스 두 가지 유형의 코루틴이 존재한다. 코틀린은 스택리스 코루틴을 구현한다. 즉, 코루틴 자체에는 스택이 없으며 코루틴이 수행할 수 있는 작업이 약간은 제한된다. 코루틴은 경량화된 스레드와 같다는 것은 무슨 의미일까? 코틀린의 코루틴은 스레드와 마찬가지로 다른 코루틴과 동시에 실행되는 일련의 동작을 나타낸다. 코틀린의 코루틴에 자체 스택이 없으며 기본 스레드에 매핑되지 않으며 프로세서에서 Context Switching이 필요하지 않음을 의미한다. 그래서 비용이 적게 든다. 차이점은 무엇일까? 스레드 : 선점형 멀티 태스킹(보통), 스레드는 해당 os의 기본 스레드에 직접 연결되며 os에 의해 관리된다. 그리고 상당한 양의 리소르를 소비한다. 특히, 스택에 많은 메모리를 소비한다. 그렇기 때문에 100k의 스레드를 만들 수 없다. 메모리가 부족할 수도 있다. 스레드 간 전환에는 OS 커널 디스패처가 포함되며 소비되는 CPU 주기 측면에서 꽤 비싼 작업이다. 코루틴 : 협력적으로 멀티 태스킹, 사용자가 관리한다. 순전히 사용자 수준의 언어 추상화이다. 기본 리소스를 연결하지 않으며 가장 간단한 경우 JVM 힙에서 비교적 작은 개체 하나만 사용한다. 그렇게 때문에 100k 코루틴을 쉽게 만들 수 있다. 코루틴 간 전환에는 OS 커널이 전혀 필요하지 않다. 일반 함수를 호출하는 것만큼 저렴할 수 있다. 코틀린의 코루틴은 실제로 병렬로(동시에) 실행되는가? 각 코루틴을 자체 스레드에서 실행하거나 모든 코루틴을 하나의 스레드 또는 일부 고정 스레드풀에서 실행할 수 있다. 코루틴은 실행되거나 중지될 수 있다. 일시 중지된 코루틴은 어느 특정 스레드와 연결되어 있지 않다. 하지만, 실행중인 코루틴은 일부 스레드에 연결되어 있다. (스레드를 사용하는 것이 OS 프로세르 내부에서 무언가를 실행하는 유일한 방법이다.) 다른 코루틴들 모두가 동일한 스레드에서 실행되는지 또는 다른 스레드에서 실행되는지는 온전히 코루틴을 사용하는 프로그래머의 손에 달려있다. 참고 Stack Overflow Kotlin Coroutines을 알아보고, 안드로이드에 library 적용하기","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Corotine","slug":"Corotine","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Corotine/"},{"name":"비동기, 동기","slug":"비동기-동기","permalink":"http://victorywoolee/victorywoolee.github.io/tags/비동기-동기/"}]},{"title":"[CleanCode] 10장","slug":"CleanCode10","date":"2019-10-27T03:53:02.000Z","updated":"2019-10-27T08:54:50.092Z","comments":true,"path":"2019/10/27/CleanCode10/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/27/CleanCode10/","excerpt":"","text":"클래스 체계 표준 자바 관례에 따르면, 가장 먼저 변수 목록이 나온다. 정적(static) 공개(public) 상수가 있다면 맨 처음에 나온다. 다음으로 정적 비공개 변수가 나오며, 이어서 비공개 인스턴스 변수가 나온다. 공개 변수가 필요한 경우는 거의 없다. 변수 목록 다음에는 공개 함수가 나온다. 비공개 함수는 자신을 호출하는 공개 함수 직후에 넣는다. 즉, 추상화 단계가 순차적으로 내려간다. 그래서 프로그램은 신문 기사처럼 읽힌다. 클래스는 작아야 한다. 클래스를 만들 때 첫 번째 규칙은 클래스는 작아야 한다는 것이다. 두 번째 규칙도 크기이다. 작아야 한다. 클래스가 맡은 책임을 기준으로 크기를 결정한다. 클래스 이름은 해당 클래스의 책임을 기술해야 한다. 실제로 작명은 클래스 크기를 줄이는 첫 번째 관문이다. 예를 들어, 클래스 이름에 Processor, Manager, Super 등과 같이 모호한 단어가 있다면 클래스에 여러 책임을 떠안겼다는 증거이다. 또한, 클래스 설명은 만일(if), 그리고(and), 하며(or), 하지만(but)을 사용하지 않고서 25단어 내외로 가능해야 한다. 1. 단일 책임 원칙 클래스나 모듈을 변경할 이유가 단 하나뿐이어야 한다는 원칙이다. SRP는 책임이라는 개념을 정의하며 적절한 클래스 크기를 제시한다. 클래스는 책임, 즉 변경할 이유가 단 하나이어야 한다. 책임, 즉 변경할 이유를 파악하려 애쓰다 보면 코드를 추상화하기도 쉬워진다. SRP는 객체 지향 설계에서 더욱 중요한 개념이지만, 이상하게도 클래스 설계자가 가장 무시하는 규칙 중 하나다. 소프트웨어를 돌아가게 만드는 활동과 소프트웨어를 깨끗하게 만드는 활동이 완전히 별개다. 우리는 두뇌 용량에 한계가 있어 깨끗하고 체계적인 소프트웨어보다 돌아가는 소프트웨어에 초점을 맞춘다. 올바른 태도이지만, 문제는 우리들 대다수가 프로그램이 돌아가면 일이 끝났다고 여기는 데 있다. 깨끗하고 체계적인 소프트웨어라는 다음 관심사로 전화하지 않는다. 프로그램으로 되돌아가 만능 클래스를 단일 책임 클래스 여럿으로 분리하는 대신 다음 문제로 넘어가버린다. 규모가 어느 수준에 이르는 시스템은 논리가 많고도 복잡하다. 이런 복잡성을 다루려면 체계적인 정리가 필요하다. 그래야 개발자가 무엇이 어디에 있는지 쉽게 찾느다. 그래야 변경을 가할 때 직접 영향이 미치는 컴포넌트만 이해해도 충분하다. 큼직한 다목적 클래스 몇 개로 이뤄진 시스템은 변경을 가할 때 당장 알 필요가 없는 사실까지 들이밀어 독자를 방해한다. 큰 클래스 몇 개가 아니라 작은 클래스 여럿으로 이뤄진 시스템이 더 바람직하다. 작은 클래스는 각자 맡은 책임이 하나며, 변경할 이유가 하나며, 다른 작은 클래스와 협력해 시스템에 필요한 동작을 수행한다. 2. 응집도 클래스는 인스턴스 변수의 수가 작아야 한다. 각 클래스 메소드는 클래스 인스턴스 변수를 하나 이상 사용해야 한다. 일반적으로 메소드가 변수를 더 많이 사용할수록 메소드와 클래스는 응집도가 더 높다. 모든 인스턴스 변수를 메소드마다 사용하는 클래스는 응집도가 가장 높다. 이처럼 응집도가 가장 높은 클래스는 가능하지도 바람직하지도 않다. 그렇지만 우리는 응집도가 높은 클래스를 선호한다. 응집도가 높다는 말은 클래스에 속한 메소드와 변수가 서로 의존하며 논리적인 단위로 묶인다는 의미기 때문이다. 12345678910111213141516171819202122public class Stack&#123; private int topOfStack=0; List&lt;Integer&gt; elements = new LinkedList&lt;Integer&gt;(); public int size()&#123; return topOfStack; &#125; public void push(int element)&#123; topOfStack++; elements.add(element); &#125; public int pop() throws PoppedWhenEmpty()&#123; if(topOfStack == 0) throw new PoppedWhenEmpty(); int element = elements.get(--topOfStack); elements.remove(topOfStack); return element; &#125;&#125; 위의 Stack 클래스는 응집도가 높다. size() 함수를 제외한 메소드가 모두 두 변수에 접근한다. 함수를 작게, 매개변수 목록을 짧게라는 전략을 따르다 보면 때때로 몇몇 메소드만이 사용하는 인스턴스 변수가 아주 많아진다. 이는 십중팔구 새로은 클래스로 쪼개야 한다는 신호다. 응집도가 높아지도록 변수와 메소드를 적절히 분리해 새로운 클래스 두세 개로 쪼개준다. 3. 응집도를 유지하면 작은 클래스 여럿이 나온다. 큰 함수를 작은 함수 여럿으로 나누기만 해도 클래스 수가 많아진다. 예를 들어, 변수가 많은 큰 함수가 하나 이싿. 큰 함수 일부를 작은 함수 하나로 빼내고 싶은데, 빼내려는 코드가 큰 함수에 정의된 변수 넷을 사용한다. 그렇다면 어떻게 해야 할까? 변수 네 개를 새 함수의 인수로 넘기는 것은 좋은 방법이 아니다. 네 변수를 클래스 인스턴스 변수로 승격한다면 새 함수는 인수가 필요없다. 그만큼 함수를 쪼개기 쉬워진다. 하지만, 클래스가 응집력을 잃는다. 몇몇 함수만 사용하는 인스턴스 벼수가 점점 더 늘어나기 때문이다. 몇몇 함수가 몇몇 변수만 사용한다면 독자적인 클래스로 분리해도 된다. 클래스가 응집력을 잃는다면 쪼개라. 이렇게 큰 함수를 작은 함수 여럿으로 쪼개다 보면 종종 작은 클래스 여럿으로 쪼갤 기회가 생긴다. 그러면서 프로그램에 점점 더 체계가 잡히고 구조가 투명해진다. 변경하기 쉬운 클래스 대다수 시스템은 지속적인 변경이 가해진다. 그리고 뭔가 변경할 때마다 시스템이 의도대로 동작하지 않을 위험이 따른다. 깨끗한 시스템은 클래스를 체계적으로 정리해 변경에 수반하는 위험을 낮춘다. 변경으로부터 격리 결합도가 낮다는 소리는 각 시스템 요소가 다른 요소로부터 그리고 변경으로부터 잘 격리되어 있다는 의미이다. 시스템 요소가 서로 잘 격리되어 있으면 각 요소를 이해하기 더 쉬워진다. 결합도를 최소로 줄이면 자연스럽게 또 다른 클래스 설계 원칙인 DIP(Dependency Inversion Principle)를 따르는 클래스가 나온다. 본질적으로 DIP는 클래스가 상세한 구현이 아니라 추상화에 의존해야 한다는 원칙이다.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"Class","slug":"Class","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Class/"},{"name":"클래스","slug":"클래스","permalink":"http://victorywoolee/victorywoolee.github.io/tags/클래스/"}]},{"title":"[CleanCode] 9장","slug":"CleanCode09","date":"2019-10-26T15:17:02.000Z","updated":"2019-10-27T03:52:27.894Z","comments":true,"path":"2019/10/27/CleanCode09/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/27/CleanCode09/","excerpt":"","text":"TDD의 중요성이 커지면서 이에 대해 관련 글도 많고 강연도 많아지고 있다. 하지만, TDD로 개발을 하는 것은 아무래도 조금 어려운 면이 있다. 중요하지만, 어렵고 쉽지 않다. 이번에 CleanCode 책을 통해서 TDD의 일부분을 알고 개발을 함에 있어서 도움을 얻고자 한다. TDD 법칙 세 가지 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다. 깨끗한 테스트 코드 유지하기 테스트 코드는 실제 코드 못지 않게 중요하다. 테스트 코드는 이류 시민이 아니다. 테스트 코드는 사고와 설계와 주의가 필요하다. 실제 코드 못지 않게 깨끗하게 짜야 한다. 1. 테스트는 유연성, 유지보수성, 재사용성을 제공한다. 테스트 코드를 깨끗하게 유지하지 않으면 결국은 잃어버린다. 그리고 테스트 케이스가 없으면 실제 코드를 유연하게 만드는 버팀목도 사라진다. 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 단위 테스트다. 테스트 케이스가 있으면 변경이 두렵지 않다. 테스트 케이스가 없다면 모든 변경이 잠정적인 버그다. 아키텍처가 아무리 유연하더라도, 설계를 아무리 잘 나눴더라도, 테스트 케이스가 없으면 개발자는 변경을 주저한다. 하지만, 테스트 케이스가 있다면 공포는 사라진다. 테스트 커버리지가 높을수록 공포는 줄어든다. 테스트 코드가 지저분하면 코드를 변경하는 능력이 떨어지며 코드 구조를 개선하는 능력도 떨어진다. 테스트 코드가 지저분할 수록 실제 코드도 지저분해진다. 결국 테스트 코드를 잃어버리고 실제 코드도 망가진다. 깨끗한 테스트 코드 깨끗한 테스트 코드를 만들려면 세 가지가 필요하다. 바로 가독성, 가독성, 가독성이다. 가독성은 실제 코드보다 테스트 코드에 더더욱 중요하다. 테스트 코드에서 가독성을 높이려면 명료성, 단순성, 풍부한 표현력이 필요하며, 테스트 코드는 최소의 표현으로 많은 것을 나타내야 한다. 테스트 코드는 본론에 돌입해 진짜 필요한 자료 유형과 함수만 사용한다. 그러므로 코드를 읽는 사람은 온갖 잡다하고 세세한 코드에 주눅 들고 헷갈릴 필요 없이 코드가 수행하는 기능을 재빨리 이해한다. 1. 도메인에 특화된 테스트 언어 흔히 쓰는 시스템 조작 API를 사용하는 대신 API 위에다 함수와 유틸리티를 구현한 후 그 함수와 유틸리티를 사용하므로 테스트 코드를 짜기도 읽기도 쉬워진다. 즉, 테스트를 구현하는 당사자와 나중에 테스트를 읽어볼 독자를 도와주는 테스트 언어다. 2. 이중 표준 실제 환경에서는 절대로 안되지만 테스트 환경에서는 전혀 문제 없는 방식이다. 대게 메모리나 CPU 효율과 관련 있는 경우다. 코드의 깨끗함과는 철저히 무관하다. 테스트 당 assert 하나 JUnit으로 테스트 코드를 짤 때는 함수마다 assert 문을 단 하나만 사용해야 한다. assert 문이 단 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠르다. assert 문이 여러 개인 테스트 함수는 테스트를 두 개로 쪼개 각자가 assert를 수행하면 된다. 책에서는 given-when-then이라는 관례를 사용했다. 그러면 테스트 코드를 읽기가 쉬워진다. 불행하게도 테스트를 분리함으로 인해서 중복되는 코드가 많아진다. TEMPLATE METHOD 패턴을 사용하면 중복을 제거할 수 있다. given/when 부분을 부모 클래스에 두고 then 부분을 자식 클래스에 두면 된다. 아니면 완전히 독자적인 테스트 클래스를 만들어 @Before 함수에 given/when 부분을 넣고 @Test 함수에 then 부분을 넣어도 된다. 1. 테스트당 개념 하나 테스트 함수마다 한 개념만 테스트하라는 규칙이 낫다. 이것저것 잡다한 개념을 연속으로 테스트하는 긴 함수는 피한다. 가장 좋은 규칙은 다음과 같다. 개념 당 assert 문 수를 최소로 줄여라. 테스트 함수 하나는 개념 하나만 테스트하라. FIRST 깨끗한 테스트는 다음 다섯 가지 규칙을 따른다. 1. Fast - 빠르게 테스트는 빨라야 한다. 테스트는 빨리 돌아야 한다. 테스트가 느리면 자주 돌리지 못해 초반에 문제를 찾아내기 힘들다. 2. Independent - 독립적으로 각 테스트는 서로 의존하면 안된다. 한 테스트가 다음 테스트가 실행될 환경을 준비해서는 안된다. 각 테스트는 독립적으로 그리고 어떤 순서로 실행해도 괜찮아야 한다. 테스트가 서로에게 의존하면 하나가 실패하면 나머지도 잇달아 실패하므로 원인을 진단하기 어려워지며 후반 테스트가 찾아내야할 결함이 숨겨진다. 3. Repeatable - 반복적으로 테스트는 어떤 환경에서도 반복 가능해야 한다. 실제 환경, QA 환경, 버스를 타고 집으로 가는 길에 사용하는 노트북 환경에서도 실행할 수 있어야 한다. 4. Self-Vaildationg - 자가 검증하는 테스트는 부울 값으로 결과를 내야 한다. 성공 아니면 실패다. 테스트가 스스로 성공과 실패를 가늠하지 않는다면 판단은 주관적이 되며 지루한 수작업 평가가 필요하게 된다. 5. Timely - 적시에 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다. 실제 코드를 구혀한 다음에 테스트 코드를 만들면 실제 코드가 테스트하기 어렵다는 사실을 발견할지도 모른다. 어떤 코드는 테스트하기 너무 어렵다고 판명날지도 모른다. 테스트가 불가능하도록 실제 코드를 설계할지도 모른다. 결론 테스트 코드는 실제 코드만큼 중요하다. 아니 실제 코드보다 더 중요할지도 모른다. 테스트 코드는 실제 코드의 유연성, 유지보수성, 재사용성을 보존하고 강화하기 때문이다. 테스트 코드는 지속적으로 깨끗하게 관리하자. 표현력을 높이고 간결하게 정리하자. 테스트 코드가 방치되어 망가지면 실제 코드도 망가진다. 테스트 코드를 깨끗하게 유지하자.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"TDD","slug":"TDD","permalink":"http://victorywoolee/victorywoolee.github.io/tags/TDD/"},{"name":"단위 테스트","slug":"단위-테스트","permalink":"http://victorywoolee/victorywoolee.github.io/tags/단위-테스트/"}]},{"title":"[Android] ViewPager","slug":"Android-ViewPager","date":"2019-10-26T07:53:54.000Z","updated":"2019-10-26T08:45:52.762Z","comments":true,"path":"2019/10/26/Android-ViewPager/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/26/Android-ViewPager/","excerpt":"","text":"이번 글은 Android의 ViewPager 전부에 관해 다루지 않고 특정 속성에 대해서 알아보려고 한다. ViewPager는 보통 Tab, Fragment와 함께 사용하여 탭 클릭 시 다른 화면으로 전환하기 위해서 사용하곤 한다. Fragment를 로드하는 상황에서 조금 더 효율적으로 로드하기 위해 사용하는 속성에 대해 알아보자. setOffscreenPageLimit필자는 ViewPager와 Fragment를 이용해서 좌우 Swipe가 가능한 화면을 구성해야 했다. 그리고 TabLayout도 함께 사용했다. 그리고 화면이 켜질 때 Fragment를 로드해야 한다. 그런데 이 화면을 개발하다가 이상한 에러를 만났다. 그래서 필자는 Google에 검색했고, setOffscreenPageLimit이라는 속성을 사용해 숫자를 설정하면 된다는 답변만을 확인하고 사용되는 Fragment의 개수가 7개이기 때문에 7로 설정을 했다. 에러가 나지 않고 필자가 원하는 동작을 하긴 했지만, 저 속성이 무엇을 의미하는지 몰라 찾아보기로 했다. ViewPager는 디폴트 값으로 현재 보이는 페이지 좌우만 생성해놓고 사용하는 구조이다. 즉, 1번, 2번, 3번의 탭이 존재한다면 1번 탭에 있을 경우에는 2번 탭을 미리 생성해놓는다. 그리고 2번 탭에 있는 경우는 1번과 3번 탭을 미리 생성해놓는다. 3번 탭으로 오게 되면 2번 탭은 미리 생성하고 사용하지만, 1번 탭은 파괴한다. 이유는 간단한데, 메모리를 효율적으로 사용하기 위함이다. 하지만, 유지해야 하는 페이지가 있는데, 이처럼 파괴된다면 원하는 앱을 구현하기 힘들다. 그래서 아래와 같은 속성을 사용하면 된다. setOffscreenPageLimit는 View의 계층 구조에서 좌우에 유지해야 하는 페이지의 수를 설정할 수 있다. 이를 초과하는 페이지는 필요할 때, 어댑터에 의해서 다시 그려지게 된다. 즉, 이 속성은 최적화되어 제공된다. 페이지에 지원하거나 지연 로딩 메커니즘이 필요한 필요한 페이지의 갯수를 미리 알고 있는 경우, 해당 속성을 사용해 설정을 조정하면 페이징 애니메이션 및 상호 작용을 매끄럽게 구성할 수 있다. 한 번에 모두 활성화할 수 있는 적은 수의 페이지(3~4)가 있는 경우, 해당 페이지 좌우로 새로 생성된 뷰 하위 트리의 레이아웃을 그리는데 소요되는 시간이 줄어들어 효율적이다. 특히 페이지의 레이아웃이 복잡한 경우 이 Limit을 낮게 유지해야 한다. 이 설정의 기본값은 1이며, 좌우로 1개씩 미리 로딩한다는 의미이다. setOffscreenPageLimit을 3으로 설정한다면 좌우로 3개의 페이지를 미리 로딩해놓는다. 즉, 7개의 탭이 있고 그 중에서 4번째 탭에 위치해 있다면 좌우로 3개씩 페이지를 미리 로딩해 놓는 것이다. 메모리가 넉넉하다면 이렇게 하면 좋지만, 그렇지 않다면 2 정도로 해서 좌우로 2개씩의 페이지를 유지하는 것이 적당해 보인다. 이외의 페이지는 필요할 때 어댑터에 의해서 그려진다고 위에서 설명하였다. 해당 속성을 사용해서 프래그먼트 혹은 페이지를 생성하는 데 있어서 메모리를 조금 더 효율적으로 사용할 수 있을 것이다. 마지막으로 setOffscreenPageLimit에 0을 넣으면 어떻게 될까? 0을 넣는다는 것은 좌우의 페이지를 로딩하지 않고 페이지를 선택할 때마다 로딩하는 것을 의미한다. 하지만, 이 코드가 동작할까?? 결과는 아니다. 0을 넣어도 디폴트 값으로 지정된 1로 동작하게 되어 좌우에 1개의 페이지를 로드하게 된다. setUserVisibleHint 다음 시간에.. 참고 Android Developer ViewPager 완전정복 중 일부","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"ViewPager","slug":"ViewPager","permalink":"http://victorywoolee/victorywoolee.github.io/tags/ViewPager/"},{"name":"Fragment","slug":"Fragment","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Fragment/"}]},{"title":"[Android] descendantFocusability 속성","slug":"Android-descendantFocusability","date":"2019-10-26T07:29:48.000Z","updated":"2019-10-26T07:49:05.632Z","comments":true,"path":"2019/10/26/Android-descendantFocusability/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/26/Android-descendantFocusability/","excerpt":"","text":"안드로이드 개발을 하면서 xml을 사용해 레이아웃을 작성하는 것이 일반적이다. 그 중에서도 ScrollView나 NestedScrollView는 꽤 자주 사용한다. 그렇지 않은 개발자들도 있겠지만, 뭐 스크롤이 필요한 화면에서는 거의 필수적일 것이다. 필자도 ScrollView를 자주 사용하는데, 이를 사용하면서 겪은 이슈와 이를 해결한 방법에 대해 공유하려고 한다. 그렇게 깊은 내용도 아니고 많은 내용도 아니기 때문에 가볍게 읽기 좋다. ScrollView 먼저, ScrollView의 특징 중 하나는 자식을 하나만 가질 수 있다는 것이다. 그래서 LinearLayout, ConstraintLayout과 같은 ViewGroup을 자식으로 가지게 하고 그 자식 안에서 뷰를 구성한다. 필자도 이와 같은 일반적인 방법으로 뷰를 구성했고, 실행을 해봤는데 포커스가 다른 곳에 잡혀 화면의 최상단이 아닌 중간에 잡히는 경우가 있었다. 이는 뷰의 포커스를 부모가 가지는게 아니라 부모가 가진 자식이 포커스를 빼앗기 때문에 생기는 이슈였다. descendantFocusability라는 속성은 뷰가 포커스를 가질 때, ViewGroup과 그 자식들의 관계를 정의할 수 있는 속성이다. 그리고 다음의 상수 값을 가져야 한다고 문서에 정의되어 있다. afterDescendants(1) : ViewGroup은 해당 하위 항목이 없는 경우에만 포커스를 받는다. beforeDescendants(0) : ViewGroup은 하위 항목보다 먼저 포커스를 받는다. blocksDescendants(2) : ViewGroup은 하위 항목이 포커스를 받는 것을 차단한다. 문서를 통해서 원하는 속성이 3번째인 blocksDescendants이라는 것을 알 수 있다. 이를 통해서 ViewGroup의 하위 자식들이 포커스를 받지 않게 한다면 화면에 들어왔을 때, 최상단이 아닌 중간에 포커스가 잡히는 이슈를 해결할 수 있을 것이다. 이 속성은 ScrollView의 자식인 ViewGroup에 명시적으로 속성을 정의하면 된다. 최근 들어, 어떤 문제에 직면했을 때 해결하기 위한 답은 문서가 먼저라는 것을 느끼고 있다. 어느 사람의 블로그 글 보다는 문서를 더 중요하게 봐야겠다. 참고 Android Developer","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"descendantFocusability","slug":"descendantFocusability","permalink":"http://victorywoolee/victorywoolee.github.io/tags/descendantFocusability/"}]},{"title":"[Kotlin] 타입 시스템 - 널 가능성2","slug":"Chap6-2","date":"2019-10-20T11:09:51.000Z","updated":"2019-11-23T02:22:58.567Z","comments":true,"path":"2019/10/20/Chap6-2/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/20/Chap6-2/","excerpt":"","text":"letlet을 이용해 널이 될 수 있는 식을 쉽게 다룰 수 있다. let 함수는 안전한 호출 연산자와 함께 사용하는 것이 일반적인 방법이다. 흔한 경우는 널이 될 수 있는 값을 널이 아닌 값만 인자로 받는 함수에게 넘기는 경우이다. 1234567fun sendEmailTo(email: String)&#123;&#125;val emial: String? = \"\"sendEmailTo(email)-&gt; Type mismatch 에러 발생. 이 함수에게 널이 될 수 있는 타입의 값은 넘길 수 없다. 넘기기 전에 널인지 검사하는 과정이 있어야 한다. 123if(email !=null)&#123; sendEmailTo(email)&#125; let 함수를 통해 전달해보자. let 함수는 자신의 수신 객체를 인자로 전달받은 람다에게 넘긴다. 널이 될 수 있는 값에 대해 안전한 호출 구문을 사용해 let을 호출하되 널이 될 수 없는 타입을 인자로 받는 람다를 let에 전달한다. 이렇게 함으로써 널이 될 수 있는 타입을 널이 될 수 없는 타입의 값으로 바꿔서 람다에게 전달하게 된다. 여러 값이 널인지 검사해야 한다면 let을 중첩시켜 처리할 수도 있다. 하지만, let을 중첩시켜 처리하면 코드가 복잡해져서 알아보기 어려워진다. let 함수의 장점 중 하나가 가독성인데, 중첩시키면 가독성이 떨어진다. 이럴 경우에는 일반적인 if를 사용해 모든 값을 한 번에 검사하는 편이 낫다. 나중에 초기화할 프로퍼티코틀린에서 클래스 안의 널이 될 수 없는 프로퍼티를 생성자 안에서 초기화하지 않고 특별한 메소드 안에서 초기화할 수는 없다. 일반적으로는 생성자 안에서 모든 프로퍼티를 초기화해야 한다. 게다가 프로퍼티 타입이 널이 될 수 없는 타입이라면 반드시 널이 아닌 값으로 그 프로퍼티를 초기화 해야 한다. 하지만, 널이 될 수 있는 타입을 사용하면 모든 프로퍼티 접근에 널 검사 혹은 !!를 사용해야 한다. 하지만, 이렇게 접근하는 것은 나쁘다. 코드가 못생겨진다. 이를 해결하기 위해 나온 것인 나중에 초기화 하는 방법인 lateinit이다. 이를 통해 프로퍼티를 나중에 초기화할 수 있다. 즉, 초기화하지 않고 널이 될 수 없는 타입을 선언할 수 있다. 널이 될 수 없는 타입은 생성자 안에서 반드시 널이 아닌 값으로 초기화 해야 한다. 널이 될 수 있는 타입은 널로 초기화를 할 수 있지만, 프로퍼티에 접근할 때, 널에 대한 검사 혹은 !!를 사용해야 한다. 나중에 초기화하는 프로퍼티는 항상 var이어야 한다. val 프로퍼티는 final 필드로 컴파일되기 때문에 반드시 생성자 안에서 초기화해야 한다. 따라서 생성자 밖에서 초기화해야 하는 나중에 초기화하는 프로퍼티는 항상 var이어야 한다. 하지만, 나중에 초기화 하는 프로퍼티가 널이 될 수 없는 타입이라고 해도 반드시 생성자 안에서 초기화할 필요는 없다. 나중에 초기화하는 프로퍼티에 초기화 전에 접근을 하면 초기화가 되지 않았다는 예외를 만나게 되니 조심해야 한다. 널이 될 수 있는 타입의 확장널이 될 수 있는 타입에 대한 확장 함수를 정의하면 null을 더 쉽게 다룰 수 있다. 이를 통해서 널이 될 수 있는 변수에 대해서 널에 대한 검사 혹은 !!를 호출하지 않고도 사용할 수 있다. 대표적으로 정의된 함수는 String? 타입에 대한 isNullOrBlank() 함수이다. 12345678910fun verifyUserInput(input: String?)&#123; if(input.isNullOrBlank())&#123; println(\"Please Fill Input.\") &#125;&#125;verifyUserInput(\" \")-&gt; Please Fill Input.verifyUserInput(null)-&gt; Please Fill Input. 위에서는 안전한 호출 연산자 ?.를 사용하지 않았다. 그럼에도 불구하고 예외가 발생하지 않았다. 이유는 String? 타입에 대한 정의된 확장 함수를 호출했기 때문이다. isNullOrBlank() 123fun String?.isNullOrBlank(): Boolean&#123; return this == null || this.isBlank()&#125; 타입 파라미터의 널 가능성이와 관련된 내용은 9장 제네릭에서 다룰 것이지만, 간단하게 보고 넘어간다.코틀린에서는 함수나 클래스의 모든 타입 파라미터는 기본적으로 널이 될 수 있다. 널이 될 수 있는 타입을 포함하는 어떤 타입이라도 타입 파라미터를 대신할 수 있다. 따라서 타입 파라미터 T를 클래스나 함수 안에서 타입 이름으로 사용하면 이름 끝에 물음표가 없더라도 T가 널이 될 수 있는 타입이다. 123456fun &lt;T&gt; printHashCode(t: T)&#123; println(t?.hashCode())&#125;printHashCode(null)-&gt; null 위의 경우 타입 파라미터 T에 대해 추론한 타입은 널이 될 수 있는 Any? 타입이다. t 파라미터의 타입 이름 T에는 물음표가 붙어있지 않지만, t는 null을 받을 수 있다. 타입 파라미터가 널이 아님을 확실히 하려면 널이 될 수 없는 타입 상한을 지정해야 한다. 이는 직접적으로 널이 될 수 없는 타입을 지정하는 것이다. 12345678fun &lt;T: Any&gt; printlnHashCode(t: T)&#123; println(t.hashCode())&#125;printHashCode(null)-&gt; Type parameter boudn for 'T' is not satisfiedprintHashCode(42)-&gt; 42 널 가능\b성과 자바자바에서도 널에 대한 정보를 표시할 수 있다. @Nullable, @NotNull과 같은 어노테이션을 사용하면 된다. 그러면 이런 정보를 바탕으로 코틀린에서 사용할 때, 참고해서 널에 대한 정보를 확인할 수 있다. 플랫폼 타입 코틀린이 널 관련 정보를 알 수 없는 타입을 말한다. 그 타입을 널이 될 수 있는 타입으로 처리해도 되고 널이 될 수 없는 타입으로 처리해도 된다. 자바의 타입은 코틀린에서 플랫폼 타입으로 변한다. 플랫폼 타입은 널이 될 수 있는 타입이나 널이 될 수 없는 타입 모두로 사용할 수 있다. 이는 직접 선언할 수 있는게 아니고 자바 코드에서 가져온 타입만 플랫폼 타입이 될 수 있다. IDE나 컴파일러 오류 메시지에서 확인할 수 있다. 자바의 코드를 코틀린에서 사용할 때, 널에 대한 처리는 온전히 사용자가 부담해야 한다. 널이 아님을 확신할 수 있다면 널에 대한 추가 검사가 필요 없지만 예외가 발생할 수도 있다는 것을 염두에 둬야 한다. 그렇다면 코틀린은 왜 플랫폼 타입을 도입했을까??? 모든 자바 타입을 널이 될 수 있는 타입으로 다루면 더 안전하지 않을까?? 물론 그래도 된다. 하지만, 모든 타입을 널이 될 수 있는 타입으로 다루면 결코 널이 될 수 없는 값에 대해서 불필요한 널 검사가 들어간다. 특히 제네릭을 다룰 때 확실히 드러난다. 모든 자바 ArrayList을 코틀린에서 ArrayList?처럼 다루면 이 배열의 원소에 접근할 때마다 널 검사를 수행하거나 안전한 캐스트를 수행해야 한다. 하지만, 이런 식으로 처리하면 널 안전성으로 얻는 이익보다 검사에 드는 비용이 훨씬 더 커진다. 또한 모든 타입의 값에 대해 항상 널 검사를 작성하는 것은 너무 성가신 일이다. 그래서 코틀린 설계자들은 자바의 타입을 가져온 경우 프로그래머에게 그 타입을 제대로 처리할 책임을 부여하는 실용적인 접근 방법을 택했다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Kotlin/"},{"name":"Type","slug":"Type","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Type/"}]},{"title":"[Kotlin] 타입 시스템 - 널 가능성","slug":"Chap6-1","date":"2019-10-19T14:20:47.000Z","updated":"2019-10-20T11:09:41.761Z","comments":true,"path":"2019/10/19/Chap6-1/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/19/Chap6-1/","excerpt":"","text":"코틀린은 자바와 달리 널에 대해서 민감하게 반응한다. 그래서 널이 될 수 있는 타입과 널이 될 수 없는 타입이 나눠져 있으며, 널과 관련한 문법을 제공해 개발자로 하여금 널과 관련된 처리를 하는데 편의성을 제공해준다. 이로 인해 가독성 또한 좋아진다. 널 가능성 널 가능성은 NullPointerException 오류(NPE)를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성이다. 코틀린을 비롯한 최신 언어에서 null에 대한 접근 방법은 가능한 한 이 문제를 실행 시점에서 컴파일 시점으로 옮기는 것이다. 널이 될 수 있는지 여부를 타입 시스템에 추가함으로써 컴파일러가 여러 가지 오류를 컴파일 시 미리 감지해서 실행 시점에 발생할 수 있는 예외의 가능성을 줄일 수 있다. 1. 널이 될 수 있는 타입 널이 될 수 있는 타입을 지원한다. 널이 될 수 있는 타입은 프로그램 안의 프로퍼티나 변수에 null을 허용하게 만드는 방법이다. 예시를 통해 이해해보자. 다음은 자바로 짜여진 함수다. 123int strLen(String s)&#123; return s.lenght();&#125; 위 함수에 인자로 null을 넘기면 NPE가 발생한다. s가 널인지 검사를 해야할까?? 이 부분에 대해 생각해보면서 코틀린으로 작성된 함수를 보자. 123fun strLen(s: String) = s.length()fun strLen(s: String?) = s?.length() 위 함수에 대해서는 null이거나 널이 될 수 있는 인자를 넘기는 것은 금지되며, 넘길 경우 NPE가 발생한다. strLen 함수의 파라미터 s의 타입은 String이며, 항상 String의 인스턴스여야 한다. 이때, 컴파일러는 널이 될 수 있는 값을 strLen에게 인자로 넘기지 못하게 막는다. 따라서 strLen 함수가 실행 시점에 NPE을 발생시키지 않으리라 장담할 수 있다. String?, Int? 등 어떤 타이이든 타입 이름 뒤에 ?를 붙이면 그 타입의 변수나 프로퍼티에 null을 참조를 저장할 수 있다는 뜻이다.?가 없는 타입은 그 변수가 null 참조를 저장할 수 없다는 뜻이다. 모든 타입은 기본적으로 널이 될 수 없으며, 뒤에 ?가 붙어야 널이 될 수 있다. 널이 될 수 있는 타입의 변수가 있다면 그에 대해 수행할 수 있는 연산이 제한된다. 널이 될 수 있는 타입인 변수에 대해 변수.메소드()처럼 메소드를 직접 호출할 수 없다. (널에 대한 검사 혹은 널이 될 수 있는 값에 대한 처리가 필요.) 널이 될 수 있는 값을 널이 될 수 없는 타입의 변수에 대입할 수 없다. 널이 될 수 있는 타입의 값을 널이 될 수 없는 파라미터를 받는 함수에 전달할 수 없다. 널이 될 수 있는 타입은 널을 검사할 때 사용될 수 있으며, 이는 뒤쪽에서 알아보도록 하자. 2. 타입의 의미 자바의 String 타입의 변수에는 String과 null이 모두 들어갈 수 있다. 이 두 종류의 값은 완전히 다르다. 두 종류의 값에 대해 실행할 수 있는 연산도 완전히 다르다. 실제로 String이 들어있는 변수에 대해서는 String 클래스에 정의된 모든 메소드를 호출할 수 있다. 하지만, null이 들어있는 경우에는 사용할 수 있는 연산이 많지 않다. 이는 자바의 타입 시스템이 널을 제대로 다루지 못한다는 뜻이다. 변수에 선언된 타입이 있지만, 널 여부를 추가로 검사하기 전에는 그 변수에 대해 어떤 연산을 수행할 수 있을지 알 수 없다. 코틀린의 널이 될 수 있는 타입과 널이 될 수 없는 타입을 구분하면 각 타입의 값에 대해 어떤 연산이 가능할지 명확히 이해할 수 있고, 실행 시점에 예외를 발생시킬 수 있는 연산을 판단할 수 있다. 따라서 그런 연산을 아예 금지시키고 위 문제에 대한 종합적인 해법을 제공한다. 주의 : 실행 시점에 널이 될 수 있는 타입이나 널이 될 수 없는 타입의 객체는 같다. 널이 될 수 있는 타입은 널이 될 수 없는 타입을 감싼 래퍼 타입이 아니다. 모든 검사는 컴파일 시점에 수행된다. 따라서 코틀린에서는 널이 될 수 있는 타입을 처리하는 데 별도의 실행 시점 부가 비용이 들지 않는다. 3. 안전한 호출 연산자 ?. null 검사와 메소드 호출을 한 번의 연산으로 수행한다. 호출하려는 값이 null이 아니라면 ?.은 일반 메소드 호출처럼 작동한다. 호출하려는 값이 null이면 이 호출은 무시되고 null이 결과 값이 된다. ?. 연산자 사용 예시 1234567891011// ?. 연산자를 사용하지 않고 if문을 사용했을 경우.if(s == null)&#123; s.toUpperCase()&#125;else&#123; null&#125;// ?. 연산자를 사용했을 경우.// allCaps는 널이 될 수 있는 타입이다.val allCaps = s?.toUpperCase() 주의해야 할 점은 안전한 호출의 결과 타입도 널이 될 수 있는 타입이라는 것이다. 메소드 호출뿐 아니라 프로퍼티를 읽거나 쓸 때도 안전한 호출을 사용할 수 있다. 널이 될 수 있는 중간 객체가 여럿 있다면 한 식 안에서 안전한 호출을 연쇄해서 함께 사용하면 편하다. 자바에서 널 검사가 들어간 호출을 코틀린에서는 훨씬 간결하게 처리할 수 있다. 이로 인해 불필요한 if문의 사용을 줄일 수 있다. 4. 엘비스 연산자 ?: null 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있다. 엘비스 연산자는 이항 연산자로 좌항을 계산한 값이 널인지 검사한다. 좌항 값이 널이 아니면 좌항 값을 결과로 하고, 좌항 값이 널이면 우항 값을 결과로 한다. 123fun foo(s: String?)&#123; val t: String = s ?: \"\"&#125; s가 널이면 빈 문자열을 t의 결과로 한다는 의미이다. 어떻게 보면 엘비스 연산자는 널을 특정 값으로 바꿔주는 역할을 하기도 한다. 엘비스 연산자를 객체가 널인 경우 널을 반환하는 안전한 호출 연산자와 함께 사용해서 객체가 널인 경우에 대비한 값을 지정하는 경우도 많다. 1234567fun strLenSafe(s: String?): Int = s?.length ?: 0println(strLenSafe(\"abc\"))println(strLenSafe(null))// 결과30 코틀린에서는 return이나 throw 등의 연산도 식이다. 따라서 엘비스 연산자의 우항에 return, throw 등의 연산을 넣을 수 있고, 엘비스 연산자를 더욱 편하게 사용할 수 있다. 이런 패턴은 함수의 전제 조건을 검사하는 경우에 유용하다. 5. 안전한 캐스트: as? 코틀린의 타입 캐스트 연산자인 as는 자바 타입 캐스트와 마찬가지로 대상 값을 as로 지정한 타입으로 바꿀 수 없으면 ClassCastException이 발생한다. as? 연산자는 어떤 값을 지정한 타입으로 캐스트한다. 값을 대상 타입으로 변환할 수 없으면 null을 반환한다. 타입 캐스트 연산자는 값을 주어진 타입으로 변환하려 시도하고 타입이 맞지 않으면 null을 반환한다. 안전한 캐스트는 일반적으로 캐스트를 수행한 뒤에 엘비스 연산자를 함께 사용하는 패턴이 일반적이다. 123456789101112131415161718192021222324class Person(val firstName: String, val lastName: String)&#123; override fun equals(o: Any?): Boolean&#123; // 타입이 일치하지 않으면 false를 반환한다. val otherPerson = o as? Person ?: return false // 안전한 캐스트를 하고 나면 otherPerson이 Person 타입으로 스마트 캐스트 된다. return otherPerson.firstName =- firstName &amp;&amp; otherPerson.lastName == lastName &#125; override fun hashCode(): Int&#123; return firstName.hashCode() * 37 + lastName.hashCode() &#125;&#125;val p1 = Person(\"Lee\", \"Seungwoo\")val p2 = Person(\"Lee\", \"Seungwoo\")// == 연산자는 equals()를 호출한다.println(p1 == p2)println(p1.equals(42))// 결과truefalse 타입을 캐스트한 다음에 해당 변수가 null을 반환하지 않으면 컴파일러는 어떤 값이 해당 타입이 맞다고 판단을 해서 자동으로 타입 캐스트를 진행한다. 이를 스마트 타입 캐스트라고 한다. 6. 널 아님 단언: !! 널이 될 수 있는 타입의 값을 다룰 때 사용할 수 있다. !!을 통해 어떤 값이든 널이 될 수 없는 타입으로 강제로 바꿀 수 있다. 실제 널에 대해서 !!를 적용하면 NPE가 발생한다. !!를 널에 대해 사용해서 발생하는 예외의 Stack trace에는 어떤 파일의 몇 번째 줄인지에 대한 정보는 들어있지만 어떤 식에서 예외가 발생했는지에 대한 정보가 들어있지 않다. 어떤 값이 널이었는지 확실히 하기 위해 여러 !! 단언문을 한 줄에 함께 쓰는 일을 피하는 것이 좋다. 12person.company!!.address!!.country// 이런식으로 코드를 작성하는 것을 피해야 한다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Kotlin/"},{"name":"Type","slug":"Type","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Type/"}]},{"title":"[ETC] Method 이름","slug":"Method-Name","date":"2019-10-19T04:28:36.000Z","updated":"2019-10-19T04:51:52.489Z","comments":true,"path":"2019/10/19/Method-Name/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/19/Method-Name/","excerpt":"","text":"개발을 하면서 메소드 이름을 그냥 내가 이해하기 쉬운 방향으로 작성을 했던 경향이 있었다. 이렇게 하는 방식이 나쁘지는 않다. 왜냐하면 혼자 프로젝트를 할 때는 상관이 없기 때문이다. 하지만, 이 프로젝트를 유지보수 하거나 다른 사람과 함께 하는 경우에는 이야기가 달라진다. 최근에 회사에서 기능을 구현하면서 메소드를 작성하는데 필자의 이런 특성이 나왔다. 그래서 다른 사람들이 함수가 무엇을 하는지 파악하기 힘들어했고, 네이밍을 보았을 때 함수는 한 가지 일을 하는데, 구현을 들여다보니 여러가지 일을 하는 경우도 많았다. 그래서 최대한 생각을 해보고 작성하도록 노력하고 있으며, 도움이 될만한 글을 참고하고자 했다. 기초적인 메소드 이름 만드는 법 일반적으로 메소드 이름을 동사 + 명사형 이름으로 만들 것을 권장하고 있다. 다음과 같다. getData(), setData(), calculateData() 하지만, 아래 내용을 이해한다면 이보다 더 나은 메소드 명을 작성할 수 있을 것이다. 객체는 수동적이다. 객체는 외부에서 메소드를 호출해주지 않으면 아무 일도 하지 않는다. 왜냐하면 객체는 수동적이기 때문이다. 따라서 메소드 명칭은 수동적인 객체에게 무언가를 시키는 형태의 이름이 되어야 한다. 즉, 객체에게 명령하는 형식의 이름이어야 한다. 메소드 명칭 = 명령형 동사 + 목적어 단순히 동사 + 명사형으로 생각하지 않는게 좋다. 예를 들어, getData()라는 메소드의 명칭은 “데이터를 가지고 온다”라는 의미로 해석할 수도 있지만, 좀 더 명확하게는 “데이터를 내놔!”이다. 이렇게 해석하는 것이 좋은 이유는 객체를 구현할 때 좀 더 구현을 정확하게 할 수 있기 때문이다. 객체를 구현할 때, getData() 메소드를 구현하면서 “데이터를 가지고 온다.”라고 해석하고 구현하기 시작하면 구현이 꼬이기 시작한다. 반대로 객체가 “데이터를 내놔!”라는 명령을 받았을 때, 해야 할 일을 getData() 메소드에 구현하면 된다고 생각하고 구현을 시작하면 구현이 명료해진다. 참고 좋은 메소드 이름 만드는 법","categories":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/categories/ETC/"}],"tags":[{"name":"Method 이름","slug":"Method-이름","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Method-이름/"},{"name":"좋은 이름 짓기","slug":"좋은-이름-짓기","permalink":"http://victorywoolee/victorywoolee.github.io/tags/좋은-이름-짓기/"}]},{"title":"[Android] TabLayout","slug":"Android-TabLayout","date":"2019-10-19T04:24:13.000Z","updated":"2019-10-26T07:49:04.812Z","comments":true,"path":"2019/10/19/Android-TabLayout/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/19/Android-TabLayout/","excerpt":"","text":"TabLayout Tip! 안드로이드에서 탭 레이아웃은 자주 사용되는 위젯이다. 그만큼 다양한 기능을 제공한다. 그래서 이번에 탭 레이아웃을 쓰면서 겪은 기능들을 정리하고자 한다. 1. tabIndicatorFullWidth 이는 탭 레이아웃의 인디케이터의 width를 설정할 수 있는 속성이며, true / false 값을 설정할 수 있다. 탭 레이아웃의 인디케이터는 탭 아이템의 크기만큼 차지하며 아무런 설정을 하지 않는다면 꽉 차게 나온다. 하지만, 디자인 스펙이 꽉 차는 것이 아닌 탭 아이템의 텍스트나 아이콘만큼만 width를 차지하도록 하고 싶을 경우에 해당 속성을 사용하면 된다. support library 28 이상을 쓴다면 tabIndicatorFullWidth의 속성을 false로 주면 된다. 그렇지 않다면 직접 코드로 인디케이터의 width를 설정해주어야 한다. 2. tabContentStart 이 속성을 몰랐다면 정말 오랜 시간 동안 삽질을 했을 것이다. 운이 좋게 스택 오버플로우에서 원하던 답변을 찾았고, 적용해본 결과 정상적으로 작동함을 확인했다. 다음과 같은 화면을 보자. 위 화면에서 Animals for adoption이라는 타이틀과 탭 레이아웃의 첫 번째 탭인 CATS가 왼쪽 라인이 동일한 위치로 맞추고 싶은 경우가 있을 것이다. 대부분의 디자인 스펙은 필자가 이야기한 것을 통일성 있게 맞추기 위해 디자인을 해서 개발자에게 알려줄 것이다. 그렇다면 어떻게 첫 번째 탭의 위치를 타이틀과 같은 위치로 맞출 수 있을까? 방법은 두 가지로 보이지만, 필자는 한 가지 방법만 시도해봤다. 그게 바로 위의 방법이다. tabContentStart를 이용해서 첫 탭의 위치를 왼쪽에서부터 얼만큼 떨어트릴지 정할 수 있다. 이 속성을 통해서 첫 탭을 원하는 위치에 맞게 지정할 수 있으며, 탭 간의 간격도 원하는대로 설정할 수 있다. 참고 Stack Overflow","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"TabLayout","slug":"TabLayout","permalink":"http://victorywoolee/victorywoolee.github.io/tags/TabLayout/"}]},{"title":"[ETC] Compile, Build","slug":"Compile-Build","date":"2019-10-19T03:12:59.000Z","updated":"2019-10-19T04:00:10.131Z","comments":true,"path":"2019/10/19/Compile-Build/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/19/Compile-Build/","excerpt":"","text":"간단한 개념을 정리하기 위한 공간입니다.Android Studio나 IntelliJ 같은 IDE를 많이 사용하고 실행 과정을 자동으로 처리해줘 편하게 해주기 때문에 컴파일과 빌드에 대한 차이점을 잊고 살았다. 최근에 갑자기 떠올라서 관련 개념을 정리하려고 한다. Compile 개발자가 작성한 소스 코드를 바이너리 코드로 변환하는 과정을 말한다. 목적 파일이 생성된다. 즉, 컴퓨터가 이해할 수 있는 기계어로 변환하는 작업이다. 이런 작업을 해주는 프로그램을 컴파일러라고 한다. 자바의 경우, JVM에서 실행 가능한 바이트 코드 형태의 클래스 파일이 생성된다. Link 프로젝트에서 개발을 진행하다 보면 여러 소스 파일을 작성한다. 예를 들어, A 소스 파일에서 B 소스 파일에 존재하는 함수를 호출하는 경우가 있다. 이때, A와 B 소스 파일을 각각 컴파일만 하면 A가 B에 존재하는 함수를 찾지 못하기 때문에 호출할 수 없다. 따라서 A와 B를 연결해주는 작업이 필요하고, 이런 작업을 링크라고 한다. static link(정적 링크) : 컴파일된 소스 파일을 연결해서 실행 가능한 파일을 만드는 것. dynamic link(동적 링크) : 프로그램 실행 도중 프로그램 외부에 존재하는 코드를 찾아서 연결하는 작업. 자바의 경우, JVM이 프로그램 실행 도중 필요한 클래스를 찾아서 클래스 패스에 로드해주는데 이는 동적 링크의 예다. Build 소스 코드 파일을 실행 가능한 소프트웨어 산출물로 만드는 일련의 과정을 말한다. 빌드의 단계 중 컴파일이 포함이 되어 있다. 컴파일은 빌드의 부분 집합이라 할 수 있다. 빋르 과정을 도와주는 도구를 빌드 툴이라고 한다. 빌드 툴 빌드 툴이 제공하는 기능은 다음과 같다. 전처리, 컴파일, 패키징, 테스팅, 배포 빌드 툴의 예 : Ant, Maven, Gradle 등 정리 우리는 소스 코드를 작성하고 파일로 저장한다. 저장한 소스 파일을 컴파일러를 이용해 컴파일하고 목적 파일을 생성한다. 컴파일러가 생성한 목적 파일들을 링커를 이용해 링크(연결)시킨다. 결과로 실행 가능한 목적 파일이 생성된다. 링커는 실행 가능한 목적 파일을 생성한다. 컴파일러가 생서하는 파일과 링커가 생성하는 파일의 차이는 생성한 목적 파일이 실행 가능하느냐의 차이에 있다. 컴파일과 링크의 과정을 합쳐 Build(빌드)라고 하고, 이때 사용되는 프로그램을 빌더라고 한다. 참고 컴파일과 빌드 차이점 컴파일 &amp; 링크 &amp; 빌드","categories":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/categories/ETC/"}],"tags":[{"name":"compile","slug":"compile","permalink":"http://victorywoolee/victorywoolee.github.io/tags/compile/"},{"name":"build","slug":"build","permalink":"http://victorywoolee/victorywoolee.github.io/tags/build/"},{"name":"Development","slug":"Development","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Development/"}]},{"title":"[Kotlin] 수신 객체 지정 람다","slug":"Chap5-5","date":"2019-10-13T07:59:27.000Z","updated":"2019-10-13T09:00:33.766Z","comments":true,"path":"2019/10/13/Chap5-5/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/13/Chap5-5/","excerpt":"","text":"이번에는 with과 apply에 대해서 알아본다. 매우 유용하며 코틀린 람다의 독특한 기능을 이해할 수 있다. 이 기능은 바로 수신 객체를 명시하지 않고 람다의 본문 안에서 다른 객체의 메소드를 호출할 수 있게 하는 것이다. 그런 람다를 수신 객체 지정 람다라고 부른다. 기존에 필자가 알고 있던 이 함수들은 범위 지정 함수라고 알고 있었고 with, apply, let, run과 같은 함수들이 있었다. 이번에 with과 apply는 책의 내용과 필자가 알고 있는 내용을 종합해서 정리하며 나머지 함수들도 정리할 예정이다. with 객체의 이름을 반복하지 않고 그 객체에 대해 다양한 연산을 수행할 수 있다. with() 함수를 사용하면 위의 기능을 사용할 수 있다. 인자로 받은 객체를 이어지는 블록(람다)의 수신 객체로 만든다. 그래서 람다 본문에서는 this를 사용해 수신 객체에 접근할 수 있다. 또한, this를 생략하고 수신 객체의 프로퍼티나 메소드에 접근하는 것도 가능하다. 블록(람다)의 값을 반환한다. 12345678910fun alphabet(): String&#123; val sb = StringBuilder() return with(sb)&#123; for(letter in 'A'..'Z')&#123; this.append(letter) &#125; append(\"\\n Now I know the alphabet! \") this.toString() &#125;&#125; 메소드를 호출하려는 수신 객체를 지정한다. 그리고 블록 안에서 원하는 함수나 프로퍼티에 접근할 수 있다. this를 명시해서 앞에서 지정한 수신 객체의 메소드를 호출하거나 this를 생략하고 호출할 수도 있다. 그리고 람다는 값을 반환할 수도 있다. Tip - 메소드 이름 충돌with에게 인자로 넘긴 객체의 클래스(위의 코드에서는 StringBuilder)와 with을 사용하는 코드가 들어있는 클래스 안(위의 코드에는 없지만 alphabet() 함수를 포함하는 클래스)에 이름이 같은 메소드가 있으면 어떤 일이 생길까? 이와 같은 경우 this 참조 앞에 레이블을 붙이면 호출하고 싶은 메소드를 명확하게 정의할 수 있다. alphabet 함수가 OuterClass의 메소드라고 하자. StringBuilder가 아닌 바깥쪽 클래스 즉, OuterClass에 정의된 toString()을 호출하고 싶다면 다음 구문을 사용하면 된다.this@OuterClass.toString() apply with 함수와 비슷한 역할을 한다. 주로 객체의 인스턴스를 만들면서 즉시 프로퍼티 중 일부를 초기화해야 하는 경우에 사용되며, with과의 차이점은 apply에게 전달된 객체(즉, 수신 객체)를 반환한다는 점이다. apply는 확장 함수로 정의되어 있다. apply의 수신 객체가 전달받은 람다의 수신 객체가 된다. 코틀린에서는 어떤 클래스가 정의돼 있는 라이브러리의 특별한 지원 없이도 그 클래스 인스턴스에 대해 apply를 활용할 수 있다. apply는 수신 객체 자체를 반환한다. 123456fun alphabet() = StringBuilder().apply&#123; for(letter in 'A'..'Z')&#123; append(letter) &#125; append(\"\\n Now I know the alphabet! \")&#125;.toString() 이처럼 수신 객체 지정 람다는 DSL(Domain Specific Language)을 만들 때 매우 유용한 도구이다. DSL에 대해서는 추후에 알아볼 예정이다. 요약 람다를 사용하면 코드 조각을 다른 함수에게 인자로 넘길 수 있다. 람다가 함수 인자인 경우 괄호 밖으로 람다를 빼낼 수 있고, 람다의 인자가 단 하나뿐인 경우 인자 이름을 지정하지 않고 it이라는 디폴트 이름으로 사용할 수 있다. 람다 안에 있는 코드는 그 람다가 들어있는 바깥 함수의 변수를 읽거나 쓸 수 있다. ::을 통해 멤버 참조를 사용할 수 있으며, 메소드, 생성자, 프로퍼티의 이름 앞에 붙여 쓸 수 있다. 이런 참조를 람다 대신 다른 함수에게 넘길 수 있다. filter, map, all, any 등의 함수를 사용하면 컬렉션에 대한 대부분의 연산을 직접 원소를 이터레이션하지 않고 수행할 수 있다. 시퀀스를 사용하면 중간 결과를 담는 컬렉션을 생성하지 않고도 컬렉션에 대한 여러 연산을 조합할 수 있다. 함수형 인터페이스(추상 메소드가 단 하나뿐인 SAM 인터페이스)를 인자로 받는 자바 함수를 호출할 경우, 람다를 함수형 인터페이스 인자 대신 넘길 수 있다. 수신 객체 지정 람다를 사용하면 람다 안에서 미리 정해둔 수신 객체의 메소드를 직접 호출할 수 있다. with 함수를 사용하면 어떤 객체에 대한 참조를 반복해서 언급하지 않으면서 그 객체의 메소드를 호출할 수 있다. 그리고 이어지는 블록 즉, 람다를 반환한다. apply 함수를 사용하면 어떤 객체라도 빌더 스타일의 API를 사용해 생성하고 초기화할 수 있다. 그리고 수신 객체를 반환한다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"},{"name":"수신 객체 지정 람다","slug":"수신-객체-지정-람다","permalink":"http://victorywoolee/victorywoolee.github.io/tags/수신-객체-지정-람다/"},{"name":"with, apply","slug":"with-apply","permalink":"http://victorywoolee/victorywoolee.github.io/tags/with-apply/"}]},{"title":"[Kotlin] 자바 함수형 인터페이스 활용","slug":"Chap5-4","date":"2019-10-13T06:33:19.000Z","updated":"2019-10-13T07:58:02.238Z","comments":true,"path":"2019/10/13/Chap5-4/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/13/Chap5-4/","excerpt":"","text":"추상 메소드가 단 하나만 있는 인터페이스를 함수형 인터페이스 또는 SAM 인터페이스라고 한다. SAM은 단일 추상 메소드라는 뜻이다. 자바 API에는 Runnable이나 Callable과 같은 함수형 인터페이스와 그런 함수형 인터페이스를 활용하는 메소드가 많다. 코틀린은 함수형 인터페이스를 인자로 취하는 자바 메소드를 호출할 때 람다를 넘길 수 있게 해준다. 따라서 코틀린 코드는 무명 클래스 인스턴스를 정의하고 활용할 필요가 없어 깔끔하고 코틀린다운 코드로 남아있을 수 있다. 자바 8 이전에는 setOnClickListener 메소드에게 인자로 넘기기 위해 무명 클래스의 인스턴스를 만들어서 사용해야만 했다. 123456button.setOnClickListener(new OnClickListener&#123; @Override public void onClick(View v)&#123; ... &#125;&#125;) 같은 구현에 대해서 코틀린에서는 무명 클래스 인스턴스 대신 람다를 넘길 수 있다. 1button.setOnClickListener&#123; view -&gt; ... &#125; 위의 코드가 동작하는 이유는 OnClickListener에 추상 메소드가 단 하나만 있기 때문이다. 관련된 개념과 용어는 서론에서 언급했다. 코틀린은 함수형 인터페이스를 인자로 취하는 자바 메소드를 호출할 때 람다를 넘길 수 있게 해준다. 따라서 코틀린 코드는 무명 클래스 인스턴스를 정의하고 활용할 필요가 없어서 깔끔하고 코틀린다운 코드를 작성할 수 있다. 주의코틀린 함수를 사용할 때는 코틀린 컴파일러가 코틀린 람다를 함수형 인터페이스로 변환해주지 않는다. 코틀린에는 함수 타입이 존재한다. 따라서 코틀린에서 함수를 인자로 받을 필요가 있는 함수는 함수형 인터페이스가 아니라 함수 타입을 인자 타입으로 사용해야 한다. 코틀린은 람다와 무명 객체 사이에 차이가 존재한다. 아래 코드를 보면서 확인해보자. 12345postponeComputation(1000, object : Runnable&#123; override fun run()&#123; println(42) &#125;&#125;) 위의 코드는 객체 식을 함수형 인터페이스 구현으로 넘긴다. 이렇게 객체를 명시적으로 선언하는 경우 메소드를 호출할 때마다 새로운 객체가 생성된다. 1postponeComputation(1000) &#123; println(42) &#125; 위와 같은 람다는 다르다. 람다에 대응하는 무명 객체를 전역으로 만들고 메소드를 호출할 때마다 반복 사용한다. 명시적인 object 선언을 하면서 람다와 동일한 코드를 작성하라면 Runnable 인스턴스를 변수에 저장하고 메소드를 호출할 때마다 그 인스턴스를 사용하게 하면 된다. 1234val runnable = Runnable &#123; println(42) &#125;fun handleComputation()&#123; postponeComputation(1000, runnable)&#125; 람다가 주변 영역의 변수를 포획한다면 매 호출마다 같은 인스턴스를 사용할 수 없다. 그런 경우 컴파일러는 매번 주변 영역의 변수를 포획한 새로운 인스턴스를 생성해준다. 향후에는 별도의 클래스를 만들지 않고 자바 8부터 도입된 람다 기능을 활용한 바이트 코드를 만들어낼 계획이라고 한다. SAM 생성자 람다를 함수형 인터페이스의 인스턴스로 변환할 수 있게 컴파일러가 자동으로 생성한 함수이다. 컴파일러가 자동으로 람다를 함수형 인터페이스 무명 클래스로 바꾸지 못하는 경우 SAM 생성자를 사용할 수 있다. SAM 생성자의 이름은 사용하려는 함수형 인터페이스의 이름과 같다. 함수형 인터페이스의 인스턴스를 반환하는 메소드를 만들고 싶다면, 람다를 직접 반환할 수 없다. 왜냐하면 리턴시 인터페이스에 대한 정보가 없기 때문에 반환하고픈 람다를 SAM 생성자로 감싸야 한다. 함수형 인터페이스의 인스턴스를 변수에 저장해서 사용하고 싶은 경우에도 SAM 생성자를 사용할 수 있다. 람다를 저장하는 방식과 유사한 방법이다. 1234567891011val listener = OnClickListener &#123; view -&gt; val text = when(view.id)&#123; R.id.btn1 -&gt; \"First btn\" R.id.btn2 -&gt; \"Second btn\" else -&gt; \"Unknown btn\" &#125; toast(text)&#125;btn1.setOnClickListener(this)btn2.setOnClickListener(this) 위\u001d의 방식은 SAM 생성자를 통해 람다를 함수형 인터페이스 인스턴스로 만들어 변수에 저장해 활용하는 방법이다. listener는 어떤 버튼이 클릭됐는지에 따라 적절한 동작을 수행한다. OnClickListener를 구현하는 객체 선언을 통해 리스너를 만들 수도 있지만, SAM 생성자를 쓰는 쪽이 더 간결하다. 주의람다에는 무명 객체와 달리 인스턴스 자신을 가리키는 this가 없다. 따라서 람다를 변환한 무명 클래스의 인스턴스를 참조할 방법이 없다. 컴파일러 입장에서 보면 람다는 그저 코드 블록일 뿐이고, 객체가 아니므로 객체처럼 람다를 참조할 수는 없다. 람다 안에서 this는 그 람다를 둘러싼 클래스의 인스턴스를 가리킨다. 그렇기 때문에 이벤트 리스너가 이벤트를 처리하다가 자기 자신의 리스너 등록을 해제해야 한다면 람다를 사용할 수 없다. 그런 경우 람다 대신 무명 객체를 사용해 리스너를 구현해야 한다. SAM 생성자를 사용하면 무명 객체로 변환할 수 있으므로 this가 자기 자신인 무명 객체를 가리킨다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"},{"name":"컬렉션 함수형 API","slug":"컬렉션-함수형-API","permalink":"http://victorywoolee/victorywoolee.github.io/tags/컬렉션-함수형-API/"}]},{"title":"[Kotlin] 지연(Lazy) 계산 컬렉션 연산","slug":"Chap5-3","date":"2019-10-13T04:46:39.000Z","updated":"2019-10-13T06:22:36.397Z","comments":true,"path":"2019/10/13/Chap5-3/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/13/Chap5-3/","excerpt":"","text":"전에 살펴본 map이나 filter 같은 몇가지 컬렉션 함수는 결과 컬렉션을 즉시 생성한다. 이는 컬렉션 함수를 연쇄시켜 사용하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는것을 뜻한다. 시퀀스를 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄시켜 사용할 수 있다. 1people.map(Person::name).filter &#123; it.startsWith(\"A\") &#125; 코틀린 문서에는 map과 filter가 리스트를 반환한다고 명시되어 있다. 이는 위의 연쇄 호출이 리스트를 2개 만든다는 뜻이다. 한 리스트는 filter의 결과를, 다른 리스트는 map의 결과를 담는다. 원본 리스트의 개수가 적으면 큰 문제가 되지 않지만, 원소가 수백만개가 되면 효율이 떨어진다. 이를 더 효율적으로 만들기 위해서는 각 연산이 컬렉션을 직접 사용하는 대신 시퀀스를 사용하게 만들어야 한다. 1234people.asSequence() .map(Person::name) .filter &#123; it.startsWith(\"A\") &#125; .toList() 위의 코드는 원본 컬렉션을 시퀀스로 변환한다. 그리고 시퀀스도 컬렉션과 똑같은 API를 제공하기 때문에 데이터를 가공할 수 있다. 마지막으로 결과 시퀀스를 다시 리스트로 변환한다. 중간 결과를 저장하는 컬렉션이 생기지 않기 때문에 원소가 많은 경우 성능이 훨씬 좋아진다. Sequence 인터페이스의 강점은 그 인터페이스 위에 구현된 연산이 계산을 수행하는 방법 때문에 생긴다. 시퀀스의 원소는 필요할 때 비로소 계산된다. 따라서 중간 처리 결과를 저장하지 않고도 연산을 연쇄적으로 적용해서 효율적으로 계산을 수행할 수 있다. asSequence 확장 함수를 호출해 컬렉션을 시퀀스로 바꾸고 시퀀스를 리스트로 다시 변환할 때는 toList()를 사용한다. 큰 컬렉션에 대해서 연산을 연쇄시킬 때는 시퀀스를 사용하는 것을 규칙으로 삼아라. 관련된 부분은 뒤에서 조금 더 자세하게 다룰 예정이다. 뒤에서는 중간 컬렉션을 생성함에도 불구하고 코틀린에서 즉시 계산 컬렉션에 대한 연산이 더 효율적인 이유를 설명할 것이다. 하지만, 컬렉션에 들어있는 원소가 많으면 중간 원소를 재배열하는 비용이 커지기 때문에 지연 계산이 더 낫다. 시퀀스 연산 실행 시퀀스에 대한 연산은 중간 연산과 최종 연산으로 나뉜다. 중간 연산 : 다른 시퀀스를 반환한다. 그 시퀀스는 최초 시퀀스의 원소를 변환하는 방법을 알고 있다. 최종 연산 : 결과를 반환한다. 결과는 최초 컬렉션에 대해 변환을 적용한 시퀀스로부터 일련의 계산을 수행해 얻을 수 있는 컬렉션이나 원소, 숫자 또는 객체다. 1sequence.map&#123; ... &#125;.filter &#123; ... &#125;.toList() 위의 예제 코드에서 map과 filter를 적용한 부분이 중간 연산에 해당되고 마지막에 toList를 적용한 부분이 최종 연산에 해당된다. 중간 연산은 항상 지연 계산된다. 아래에서 확인해보자. 123listOf(1,2,3,4).asSequence() .map&#123; print(\"map($it) \") it * it &#125; .filter&#123; print(\"filter($it) \") it % 2 == 0 &#125; 위 코드를 실행하면 결과가 출력되지 않는다. 이는 map과 filter 변환이 늦춰져서 결과를 얻을 필요가 있을 때 즉, 최종 연산이 호출될 때 적용된다는 뜻이다. 그래서 마지막에 toList를 호출해 최종 연산을 수행해주면 다음과 같은 결과를 얻을 수 있다. 1map(1) filter(1) map(2) filter(4) map(3) filter(9) map(4) filter(16) 다음의 코드와 결과를 보고 시퀀스의 연산 순서에 대해서 생각해보자. 1234println(listOf(1,2,3,4).asSequence() .map&#123; it * it &#125; .find&#123; it&gt;3 &#125;)결과:4 같은 연산을 컬렉션에 수행한 경우 map의 결과가 먼저 평가돼어 최초 컬렉션의 모든 원소가 map을 통해서 변환된다. 두 번째 단계에서는 map을 적용해서 얻은 중간 컬렉션으로부터 술어를 만족하는 원소를 찾는다. 같은 연산을 시퀀스를 적용한 경우 지연 계산으로 인해 모든 연산은 각 원소에 대해 순차적으로 적용된다. 즉, 첫 번째 원소가 변환된 다음에 filter를 통해 걸러지는 처리가 되고 다시 두 번째 원소가 처리되며, 이와 같은 처리가 모든 원소에 대해 적용된다. 따라서 지연 계산으로 인해 원소 중 일부의 계산은 이뤄지지 않는다. 아래 결과는 즉시 계산과 지연 계산을 수행했을 때의 결과를 보여준다. 위에서 확인할 수 있듯이 컬렉션을 사용하면 리스트가 다른 리스트로 변환된다. 그래서 map 연산은 3,4를 포함해 모든 원소를 변환한다. 그 후 find가 술어를 만족하는 첫 번째 원소인 4를 찾는다. 시퀀스를 사용하면 find 호출이 원소를 하나씩 처리하기 시작한다. 최초 시퀀스로부터 수를 하나 가져와서 map에 지정된 변환을 수행한 다음에 find에 지정된 술어를 만족하는지 검사한다. 그래서 결과를 찾으면 남은 원소에 대해 연산을 하지 않아도 된다. 컬렉션에 대해 수행하는 연산의 순서도 성능에 영향을 끼친다. 다음의 코드를 보면 확실하게 알 수 있다. 아래는 이름이 어떤 길이보다 짧은 사람의 명단을 얻고 싶은 코드이다. map과 filter를 적용하는데 순서에 따라서 성능의 차이가 있다. 1234567891011121314val people = listOf(Person(\"Lee\",26), Person(\"Kim\",35), Person(\"Bob\",31),Person(\"Park\",30))// 1. map 다음에 filter 수행println(people.asSequence() .map(Person::name) .filter &#123; it.length &lt; 4 &#125; .toList())결과 : [Lee, Kim, Bob]// 2. filter 다음에 map 수행println(people.asSequence() .filter &#123; it.length &lt; 4 &#125; .map(Person::name) .toList())결과 : [Lee, Kim, Bob] map을 먼저 하면 모든 원소를 변환한다. 하지만, filter를 먼저 하면 부적절한 원소를 먼저 제외하기 때문에 그런 원소는 변환되지 않으며, 변환 횟수가 줄어들어 성능상 이점을 갖는다. 자바 스트림과 코틀린 시퀀스 비교 자바 8 스트림이 코틀린 시퀀스와 비슷한 개념으로 보인다. 코틀린에서 같은 개념을 따로 구현해 제공하는 이유는 안드로이드 등에서 예전 버전의 자바를 사용하는 경우 자바 8에 있는 스트림이 없기 때문이다. 또한, 자바 8을 사용하면 현재 코틀린 컬렉션과 시퀀스에서 제공하지 않는 중요한 기능을 사용할 수 있다. 스트림 연산을 여러 CPU에서 병렬적으로 실행하는 기능이다. 필요에 따라서 적절하게 선택하면 된다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"},{"name":"컬렉션 함수형 API","slug":"컬렉션-함수형-API","permalink":"http://victorywoolee/victorywoolee.github.io/tags/컬렉션-함수형-API/"}]},{"title":"[Kotlin] 컬렉션 함수형 API","slug":"Chap5-2","date":"2019-10-12T08:31:25.000Z","updated":"2019-10-13T04:46:23.504Z","comments":true,"path":"2019/10/12/Chap5-2/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/12/Chap5-2/","excerpt":"","text":"이번에는 함수형 프로그래밍과도 관련이 있는 내용을 배울 것이다. 컬렉션을 사용할 때 아주 편리하게 사용할 수 있는 것들도 있다. 함수형 프로그래밍에서는 람다나 다른 함수를 인자로 받거나 함수를 반환하는 함수를 고차 함수라고 한다. 고차 함수는 기본 함수를 조합해서 새로운 연산을 정의하거나, 다른 고차 함수를 통해 조합된 함수를 또 조합해서 더 복잡한 연산을 쉽게 정의할 수 있다는 장점이 있다. 이런 식으로 고차 함수와 단순한 함수를 조합해서 코드를 작성하는 기법을 컴비네이터 패턴이라고 브르고, 이 패턴에서 복잡한 연산을 만들기 위해 값이나 함수를 조합할 때 사용하는 고차 함수를 컴비네이터라 한다. 필수적인 함수1. filter filter : 컬렉션을 이터레이션(반복)하면서 주어진 람다에 각 원소를 넘겨서 람다가 true를 반환하는 원소만 모은다. 즉, 필터로 true를 반환하는 원소만 모은다. 결과는 입력 컬렉션의 원소 중에서 주어진 술어(참, 거짓을 반환하는 함수를 술어라고 한다.)를 만족하는 원소만으로 이뤄진 새로운 컬렉션이다. filter는 컬렉션에서 원치 않는 원소를 제거한다. 2. map map : 주어진 람다를 컬렉션의 각 원소에 적용한 결과를 모아서 새 컬렉션을 만든다. 즉, 값을 변환해주는 함수이다. map 함수는 어떤 값을 다른 타입 혹은 값으로 변환하고자 할 때 유용하게 사용할 수 있다. 이런 메소드는 멤버 참조도 적용할 수 있고 연쇄적으로 호출할 수 있다는 장점이 있다. 아래는 나이가 30살 이상인 사람의 이름을 출력하는 구문이다. 1people.filter&#123; it.age &gt; 30 &#125;.map(Person::name) 다음은 목록에서 가장 나이 많은 사람의 이름을 알고 싶다. 먼저, 목록에 있는 사람들의 나이의 최댓값을 구하고 나이가 그 최댓값과 같은 모든 사람을 반환하면 된다. 1people.filter &#123; it.age == people.maxBy(Person::age)!!.age &#125; 하지만, 위의 코드는 최댓값을 구하는 작업을 반복한다는 단점이 있다. 100명이 있다면 100번 최댓값을 찾는 연산을 반복한다. 따라서 아래처럼 미리 변수로 찾아놓은 후 filter에서 비교하는 편이 좋다. 꼭 필요하지 않은 경우 굳이 계산을 반복하지 않는게 좋다. 람다를 인자로 받는 함수에 람다를 넘기면 겉으로 볼 때는 단순해 보이는 식이 내부 로직의 복잡도로 인해 실제로는 엄청나게 불합리한 계산식이 될 때가 있다. 따라서 코드를 작성할 때 어떤 일을 하는지 명확히 이해해야 한다. 12val maxAge = people.maxBy(Person::age)!!.agepeople.filter &#123; it.age == maxAge &#125; all, any, count, find 함수 컬렉션에 대해 자주 수행하는 연산으로 컬렉션의 모든 원소가 어떤 조건을 만족하는지 판단하거나 컬렉션 안에 어떤 조건을 만족하는 원소가 있는지 판단하는 연산들이 있다. all : 컬렉션 안에 있는 모든 원소가 어떤 조건을 만족하는지 판단한다. any : 컬렉션 안에 있는 어떤 원소가 어떠한 조건을 만족하는지 판단한다. count : 조건을 만족하는 원소의 개수를 반환 find : 조건을 만족하는 첫 번째 원소를 반환 (조건을 만족하는 원소가 하나라도 있는 경우, 가장 먼저 조건을 만족한다고 확인된 원소를 반환) find는 firstOrNull과 같다. 조건을 만족하는 원소가 없으면 null이 나온다. 함수를 적재적소에 사용하라: count와 size count가 있지만, size가 익숙해서 자주 사용할 수 있다. 그래서 컬렉션을 필터링한 결과의 크기를 가져올 때 아래처럼 사용한다. 12println(people.filter(canBeInClub27).size)결과:1 하지만 이렇게 처리하면 조건을 만족하는 모든 원소가 들어가는 중간 컬렉션이 생긴다. 반면, count는 조건을 만족하는 원소의 개수만을 추적하지 조건을 만족하는 원소를 따로 저장하지 않는다. 따라서 count가 훨씬 효과적이다. groupBy 리스트를 여러 그룹으로 이루어진 맵으로 변경한다. 컬렉션의 모든 원소를 어떤 특성에 따라 여러 그룹으로 나누고 싶을 때 사용하면 좋다. 123val people = listOf(Person(\"lee\", 26), Person(\"kim\", 25), Person(\"Bob\",30), Person(\"Carol\",31))println(people.groupBy&#123; it.age &#125;) 위 연산의 결과는 컬렉션의 원소를 구분하는 특성이 age가 되며 키이다. 그리고 키 값에 따른 각 그룹이 값인 맵이다. 여기서는 Person 객체의 모임이다. age를 키 값으로 하며, 키에 따라서 그룹으로 분류된 리스트가 존재한다. 각 그룹은 리스트다. 따라서 groupBy의 결과 타입은 Map&lt;Int, List&gt;이다. flatMap, flatten 중첩된 컬렉션 안의 원소 처리 flatMap : 인자로 주어진 람다를 컬렉션의 모든 객체에 적용하고(또는 매핑하고) 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스트로 한데 모은다. 다음의 예를 확인해보자.12345val books = listOf(Book(\"Thursday Next\", listOf(\"Jasper Fforde\")), Book(\"Mort\", listOf(\"Terry Pratchett\")), Book(\"Good Omens\", listOf(\"Terry Pratchett\",\"Neil Gaiman\")))println(books.flatMap &#123; it.authors &#125;.toSet())결과 : [Jasper Fforde, Terry Pratchett, Neil Gaiman] 위의 코드에서 책을 여러 작가가 함께 쓸 수도 있다. book.authors 프로퍼티는 작가를 모아둔 컬렉션이다. flatMap 함수는 모든 책의 작가를 평평한 리스트 하나로 모은다. 그리고 toSet은 flatMap의 결과 리스트에서 중복을 없애고 집합으로 만든다. 따라서 최종 출력에서는 Terry Pratchett를 한 번만 볼 수 있다. 리스트의 리스트가 있는데 모든 중첩된 리스트의 원소를 한 리스트로 모아야 한다면(위의 경우처럼) flatMap을 떠올릴 수 있을 것이다. 하지만, 특별히 변환해야 할 내용이 없다면 리스트의 리스트를 평ㄹ평하게 펼치기만 하면 된다. 그런 경우에는 listOfLists.flatten()처럼 flatten() 함수를 사용할 수 있다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"},{"name":"컬렉션 함수형 API","slug":"컬렉션-함수형-API","permalink":"http://victorywoolee/victorywoolee.github.io/tags/컬렉션-함수형-API/"}]},{"title":"[Android] SDK란?","slug":"Android-SDK","date":"2019-10-12T08:31:19.000Z","updated":"2019-10-19T03:13:12.994Z","comments":true,"path":"2019/10/12/Android-SDK/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/12/Android-SDK/","excerpt":"","text":"간단한 개념을 정리하기 위한 공간입니다. SDK란? Android SDK : Android Software Development Kit의 약자이다. 즉, 안드로이드 소프트웨어를 개발하기 위한 툴 킷을 의미한다. 구체적으로는 아래와 같은 것들이 포함된다. 안드로이드 API 안드로이드 개발을 보다 더 쉽게 하도록 접근을 허용하는 안드로이드 API들 안드로이드 응용 프로그램 개발에 필요한 각종 도구들 안드로이드 소스 코드를 실행 가능한 어플리케이션으로 만들기 위한 컴파일러나 에뮬레이터 등 샘플 코드들 안드로이드 API 사용법을 이해시키기 위한 예제 코드들 관련 문서 SDK를 사용하기 위한 각종 패키지나 클래스에 대한 설명 등 API란? API : Application Programming Interface의 약자로, 앱을 개발하기 위한 규칙이다. 앱에서 사용할 수 있도록 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스, 개발자를 위한 인터페이스 운영체제가 응용프로그램을 위해 제공하는 함수의 집합으로 응용프로그램과 디바이스를 연결해주는 역할을 한다.","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"SDK","slug":"SDK","permalink":"http://victorywoolee/victorywoolee.github.io/tags/SDK/"},{"name":"개념","slug":"개념","permalink":"http://victorywoolee/victorywoolee.github.io/tags/개념/"}]},{"title":"[Kotlin] 람다","slug":"Chap5-1","date":"2019-10-12T06:22:11.000Z","updated":"2019-10-12T08:29:44.419Z","comments":true,"path":"2019/10/12/Chap5-1/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/12/Chap5-1/","excerpt":"","text":"람다 또는 람다 식은 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 의미한다. 람다를 사용하면 쉽게 공통 구조를 라이브러리 함수로 뽑아낼 수 있다. 주로 컬렉션 처리에서 많이 사용된다. 람다 식이 유용한 예제를 하나 살펴보고 문법에 대해서 알아보자. 사람들로 이뤄진 리스트가 있고 그 중에서 연장자를 찾아보자. 12345678910111213141516171819data class Person(val name: String, val age: Int)fun findTheOldest(people: List&lt;Person&gt;)&#123; var maxAge: Int=0 var theOldest: Person?=null for(person in people)&#123; if(person.age &gt; maxAge)&#123; maxAge = person.age theOldest = person &#125; &#125; println(theOldest)&#125;val people = listOf(Person(\"Lee\", 26),Person(\"Jung\",23))findTheOldest(people)Person(name=Lee,age=26) 코틀린을 썼지만, 자바처럼 작성했다. 그리고 코드가 길어진다. 코틀린에서는 훨씬 줄여서 쓸 수 있다. 123val people = listOf(Person(\"Lee\", 26),Person(\"Jung\",23))println(people.maxBy&#123;it.age&#125;)Person(name=Lee, age=26) 코드가 이전에 비해 훨씬 짧아진 것을 확인할 수 있다. maxBy 함수는 모든 컬렉션에 대해 호출할 수 있다. 또한, 단지 함수나 프로퍼티를 반환하는 역할을 수행하는 람다는 멤버 참조로 대치할 수 있다. 1people.maxBy(Person::age) 이처럼 람다 식을 사용하면 함수의 가독성을 높여준다. 그리고 코드가 더 짧아지며 이해하기가 쉽다. 람다 식의 문법 람다는 값처럼 여기저기 전달할 수 있는 동작의 모임이다. 람다를 따로 선언해서 변수에 저장할 수도 있지만, 함수에 인자로 넘기면서 바로 람다를 정의하는 경우가 대부분이다. 1&#123; x: Int, y: Int -&gt; x + y &#125; 람다 식은 중괄호로 둘러싸여 있으며, 인자 목록 주변에 괄호가 없다. -&gt; (화살표)가 인자 목록과 람다 본문을 구분해준다. 또한, 람다 식을 변수에 저장할 수 있으며, 저장된 변수를 다른 일반 함수처럼 다룰 수 있다. 람다 호출에는 부가 비용이 들지 않는다. 기본 구성 요소와 비슷한 성능을 낸다. 12val sum = &#123; x: Int, y: Int -&gt; x + y &#125;println(sum(1,2)) 도입부에서 살펴본 예제를 다시 확인해보자. 정식으로 람다를 작성하면 아래와 같은 코드이다. 1people.maxBy(&#123;p: Person -&gt; p.age&#125;) 중괄호 안에 있는 코드는 람다 식일고 그 람다 식을 maxBy 함수에 넘긴다. 람다 식은 Person 타입의 값을 인자로 받아서 인자의 age를 반환한다. 의미는 알겠지만,코드가 번잡하다. 우선 구분자가 많아 가독성이 떨어진다. 그리고 컴파일러가 문맥으로부터 유추할 수 있는 인자 타입을 굳이 적을 필요는 없다. 마지막으로 인자가 단 하나뿐인 경우 굳이 인자에 이름을 붙이지 않아도 된다. 그럼 위의 코드를 조금 더 깔끔한 람다 식으로 개선해보자. 코틀린에서는 함수 호출 시 맨 마지막 인자라 람다 식이라면 람다를 괄호 밖으로 뺄 수 있다. 1people.maxBy() &#123;p: Person -&gt; p.age&#125; 이처럼 람다가 어떤 함수의 유일한 인자이고 괄호 뒤에 람다를 썼다면 호출 시 빈 괄호를 없애도 된다. 1people.maxBy&#123;p: Person -&gt; p.age&#125; 이제 타입을 없애면 된다. 컴파일러가 타입을 유추할 수 있다면 굳이 명시할 필요가 없다. maxBy 함수의 경우 파라미터의 타입은 항상 컬렉션의 원소 타입과 같다. 1people.maxBy &#123; p -&gt; p.age &#125; 마지막으로 람다의 파라미터가 하나뿐이고 컴파일러가 그 타입을 추론할 수 있는 경우 it을 사용해 더 간결하게 코드를 작성할 수 있다. 1people.maxBy&#123; it.age &#125; Tipit은 람다 파라미터의 이름을 따로 지정하지 않은 경우에 자동으로 만들어지는 이름이다. 이는 코드를 아주 간단하게 만들어준다. 하지만, 남용하면 안된다. 특히 람다 안에 람다가 중첩되는 경우, 각 람다의 파라미터를 명시하는 편이 낫다. 파라미터를 명시하지 않으면 각각의 it이 가리키는 파라미터가 어떤 람다에 속했는지 파악하기 어려울 수 있다. 문맥에서 람다 파라미터의 의미나 파라미터의 타입을 쉽게 알 수 없는 경우에 파라미터를 명시적으로 선언하면 도움이 된다. 람다를 변수에 저장할 때는 파라미터의 타입을 추론할 문맥이 존재하지 않기 때문에 파라미터 타입을 명시해야 한다. 12val getAge = &#123;p: Person -&gt; p.age&#125;people.maxBy(getAge) 현재 영역에 있는 변수에 접근 람다를 함수 안에서 정의하면 함수의 파라미터뿐 아니라 람다 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다. 자바와 다른 점 중 중요한 한가지는 코틀린 람다 안에서는 파이널 변수가 아닌 변수에 접근할 수 있다는 것이다. 또한 람다 안에서 바깥 변수를 변경해도 된다. 123456789101112131415161718fun printMessage(responses: Collection&lt;String&gt;)&#123; var clientErrors=0 var serverErrors=0 responses.forEach &#123; if(it.startsWith(\"4\"))&#123; clientErrors++ &#125;else if(it.startsWith(\"5\"))&#123; serverErrors++ &#125; &#125; println(\"$clientErrors client errors, $serverErrors server errors\")&#125;val responses = listOf(\"200 OK\", \"418 I'm a teapot\", \"500 Internal Server Error\")printMessage(responses)결과 : 1 client errors, 1 server errors 위에서 살펴본 prefix, clientErrors, serverErrors와 같이 람다 안에서 사용하는 외부 변수를 람다가 포획한 변수라고 부른다. 기본적으로 함수 안에 정의된 로컬 변수의 생명주기는 함수가 반환되면 끝난다. 하지만, 어떠 함수가 자신의 로컬 변수를 포획한 람다를 반환하거나 다른 변수에 저장한다면 로컬 변수의 생명주기와 함수 생명주기가 달라질 수 있다. 포획한 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 여전히 포획한 변수를 읽거나 쓸 수 있다. 파이널 변수를 포획한 경우에는 람다 코드를 변수 값과 함께 저장한다. 파이널이 아닌 변수를 포획한 경우에는 변수를 특별한 래퍼로 감싸서 나중에 변경하거나 읽을 수 있게 한 다음, 래퍼에 대한 참조를 람다 코드와 함께 저장한다. 멤버 참조 함수를 값으로 바꿀 수 있다. 이때 이중 콜론(::)을 사용한다. ::를 사용하는 식은 멤버 참조라고 부른다. 멤버 참조는 프로퍼티나 메소드를 단 하나만 호출하는 함수 값을 만들어준다. 아래 두 문장은 같은 식이다. 멤버 참조를 사용하는지와 람다 식을 사용하는지 차이만 있을 뿐이다. 또한, 최상위에 선언된(다른 클래스의 멤버가 아닌) 함수나 프로퍼티를 참조할 수도 있다. 1234567val getAge = Person::ageval getAge = &#123;p: Person -&gt; p.age&#125;fun salute() = println(\"Salute!!\")run(::salute)결과 : Salute!! 람다가 인자가 여럿인 다른 함수한테 작업을 위임하는 경우에 람다를 정의하지 않고 직접 위임 함수에 대한 참조를 제공하면 편리하다. 12345val action = &#123; person: Person, message: String -&gt; sendMail(person, message) &#125;val action = ::sendMail 또한, 생성자 참조를 사용하면 클래스 생성 작업을 연기하거나 저장해 둘 수도 있다. :: 뒤에 클래스 이름을 넣으면 생성자 참조를 만들 수 있다. 123456data class Person(val name: String, val age: Int)val createPerson = ::Person // Person의 인스턴스를 만드는 동작을 변수에 할당함으로써 값으로 저장한다.val p = createPerson(\"Lee\",26)println(p)결과 : Person(name=Lee, age=26) 확장 함수도 멤버 참조를 사용할 수 있다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"},{"name":"람다","slug":"람다","permalink":"http://victorywoolee/victorywoolee.github.io/tags/람다/"}]},{"title":"[Kotlin] object 키워드","slug":"Chap4-4","date":"2019-10-09T13:16:26.000Z","updated":"2019-10-12T05:50:12.989Z","comments":true,"path":"2019/10/09/Chap4-4/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/09/Chap4-4/","excerpt":"","text":"object 키워드를 다양한 상황에서 사용하지만, 모든 경우 클래스를 정의하면서 동시에 인스턴스를 생성한다는 공통점이 있다. object를 사용하는 상황을 다음과 같다. 싱글톤을 정의할 때 object를 사용한다. companion object(동반 객체)는 인스턴스 메소드는 아니지만, 어떤 클래스와 관련있는 메소드와 팩토리 메소드를 담을 때 주로 쓰인다. 동반 객체가 포함된 클래스 이름을 사용해 접근할 수 있다. 객체 식은 자바의 익명 내부 클래스 대신 쓰인다. 객체 선언 : 싱글톤 객체 선언을 통해 싱글톤을 언어에서 기본으로 지원한다. 객체 선언 = 클래스 선언 + 클래스에 속한 단일 인스턴스의 선언 123456789object Payroll&#123; val allEmployee = arrayListOf&lt;Person&gt;() fun calculateSalary()&#123; for(person in allEmployee)&#123; // 생략. &#125; &#125;&#125; 객체 선언은 object 키워드로 시작한다. 객체 선언은 클래스를 정의하고 그 클래스의 인스턴스를 만들어서 변수에 저장하는 모든 작업을 한 문장으로 수행한다. 클래스와 마찬 가지로 객체 선언(object) 안에도 프로퍼티, 메소드, 초기화 블록 등이 들어갈 수 있지만, 생성자는 쓸 수 없다. 이유는 일반 클래스 인스턴스와 달리 싱글톤 객체는 객체 선언문이 있는 위치에서 생성자 호출 없이 즉시 만들어지기 때문이다. 따라서 객체 선언(object)에는 생성자 정의가 필요 없다. 객체 선언도 클래스나 인스턴스를 상속할 수 있다. 일반 객체를 사용할 수 있는 곳에서는 항상 싱글톤 객체를 쓸 수 있다. 클래스 안에서 객체 선언을 할 수도 있다. 그런 객체도 인스턴스는 단 하나뿐이다.(즉, 바깥 클래스의 인스턴스마다 중첩 객체 선언에 해당하는 인스턴스가 하나씩 따로 생기는 것이 아니다.) 동반 객체 companion object라고 하며, 동반 객체라고도 부른다. 코틀린에는 자바에서의 static과 같은 개념이 없다. 그래서 정적인 멤버가 없다. 그래서 패키지 수준의 최상위 함수(자바의 정적 메소드 역할을 거의 대신한다.)와 객체 선언(자바의 정적 메소드 역할 중 코틀린 최상위 함수가 대신할 수 없는 역할이나 정적 필드를 대신할 수 있다.)을 활용한다. 대부분의 경우 최상위 함수를 활용하는 편은 더 권장한다. 최상위 함수는 클래스의 private 멤버에 접근할 수 없다. 클래스의 인스턴스와 상관없이 호출해야 하지만, 클래스 내부 정보에 접근해야 하는 함수가 필요할 때는 클래스에 중첩된 객체 선언의 멤버 함수로 정의해야 한다. 클래스 안에 정의된 객체에 companion 키워드를 붙이면 동반 객체로 만들 수 있다. 동반 객체의 프로퍼티, 메소드에 접근하기 위해서는 클래스 이름.동반 객체로 접근하면 된다. 이때 객체의 이름을 따로 지정하지 않아도 된다. 동반 객체는 자신을 둘러싼 클래스의 모든 private 멤버에 접근할 수 있다. 따라서 팩토리 패턴을 구현하기 적합하다. 아래는 이전에 예제로 다뤄봤던 코드이다. 두 클래스를 하나로 합치면서 사용자 객체를 여러가지 방법으로 제공한다. 12345678910class User &#123; val nickname: String constructor(email: String)&#123; nickname = email.substringBefore('@') &#125; constructor(facebookAccountId: Int)&#123; nickname = getFacebookName(facebookAccountId) &#125;&#125; 위의 로직을 좀 더 유용한 방법으로 표현하기 위해서 팩토리 패턴을 사용해보자. 생성자를 통해 객체를 생성할 수 없고 팩토리 메소드를 사용해야 한다. 123456789class User private constructor(val nickname: String)&#123; companion object&#123; fun newSubscribingUser(email: String) = User(email.substringBefore('@')) fun newFacebookUser(facebookAccountId: Int) = User(getFacebookName(facebookAccountId)) &#125;&#125; 동반 객체를 일반 객체처럼 사용 동반 객체는 클래스 안에 정의된 일반 객체다. 따라서 이름을 붙일 수도 있고, 인터페이스를 상속하거나, 동반 객체 안에 확장 함수와 프로퍼티를 정의할 수도 있다. 이름을 정의하지 않으면 동반 객체의 이름은 자동으로 Companion이 된다. 동반 객체에서 인터페이스 구현 동반 객체에서 인터페이스를 구현할 수 있다. 다음 코드를 확인해보자. 123456789interface JSONFactory&lt;T&gt;&#123; fun fromJSON(jsonText: String): T&#125;class Person(val name: String)&#123; companion object : JSONFactory&lt;Person&gt;&#123; override fun fromJSON(jsonText: String): Person = ... &#125;&#125; 동반 객체가 인터페이스를 구현하고 JSON으로부터 각 원소를 다시 만들어내는 추상 팩토리가 있다고 가정하면 Person 객체를 그 팩토리에게 쉽게 넘길 수 있다. 12345fun loadFromJSON&lt;T&gt; (factory: JSONFactory&lt;T&gt;) : T&#123; ...&#125;loadFromJSON(Person) 여기서 동반 객체가 구현한 JSONFactory의 인스턴스를 넘길 때 Person 클래스의 이름을 그대로 사용할 수 있다. 동반 객체는 일반 객체와 비슷한 방식으로 클래스에 정의된 인스턴스를 가리키는 정적 필드로 컴파일된다. 동반 객체 확장 확장 함수를 사용하는 것의 장점은 코드 기반의 다른 곳에서 정의된 클래스의 인스턴스에 대해 새로운 메소드를 정의할 수 있다는 것이다. 이 방법을 동반 객체에도 적용할 수 있다. 위에서 살펴본 Person의 관심사를 좀 더 명확하게 분리해보자. Person 클래스는 핵심 비즈니스 로직 모듈의 일부다. 하지만, 특정 데이터 타입에 의존하기를 원하지 않는다. 역직렬화 함수를 비즈니스 모듈이 아닌 클라이언트/서버 통신을 담당하는 모듈 안에 포함시키고 싶다. 1234567891011class Person(val name: String)&#123; companion object&#123; // 비어있는 동반 객체. &#125;&#125;fun Person.Companion.fronJSON(json: String): Person&#123; // 확장 함수를 선언.&#125;val p = Person.fromJSON(json) 이렇게 확장 함수를 정의함으로써 동반 객체 안에 fronJSON 함수를 정의한 것처럼 호출할 수 있다. 실제로 fromJSON 함수를 클래스 밖에 정의한 확장 함수이다. 동반 객체에 대한 확장 함수를 정의하기 위해서는 클래스 안에 비어있더라도 동반 객체를 선언해줘야 한다. 객체 식: 무명 내부 클래스를 다른 방식으로 작성 object 키워드는 무명 객체를 정의할 때도 사용된다. 무명 객체는 자바의 무명 내부 클래스를 대신한다. 안드로이드에서는 흔히 사용하는 이벤트 리스너가 한 예가 될 수 있다. 123456789window.addListener(object : Adapter()&#123; override fun mouseClicked(e: Event)&#123; ... &#125; override fun mouseEntered(e: Event)&#123; ... &#125;&#125;) 객체 식은 클래스를 정의하고 그 클래스에 속한 인스턴스를 생성한다. 하지만, 클래스나 인스턴스에 이름을 붙이지 않는다. 이 점이 object 키워드를 싱글톤 선언할 때 사용하는 방식과 다른 점이다. 보통 함수를 호출하면서 인자로 무명 객체를 넘기기 때문에 클래스와 인스턴스 모두 이름이 필요하지 않다. 하지만, 이름이 필요하다면 변수에 무명 객체를 할당해서 사용하면 된다. 무명 클래스는 여러 인터레이스를 구현하거나 클래스를 확장하면서 인터페이스를 구현할 수 있다. 객체 선언과 달리 무명 객체는 싱글톤이 아니다. 객체 식이 쓰일 때마다 새로운 인스턴스가 생성된다. 요약 인터페이스는 자바와 비슷하지만, 디폴트 구현을 포함할 수 있고, 프로퍼티도 포함할 수 있다. 모든 코틀린 선언은 기본적으로 final이며 public이다. final이 되지 않게 하려면 open을 붙여 변경하면 된다. 이를 통헤 상속과 오버라이딩이 가능하다. internal 선언은 같은 모듈 안에서만 볼 수 있다. 중첩 클래스는 기본적으로 내부 클래스가 아니다. 바깥쪽 클래스에 대한 참조를 중첩 클래스 안에 포함시키기 위해서는 inner 키워드를 중첩 클래스 앞에 붙여 내부 클래스로 만들어야 한다. sealed 클래스를 상속하는 클래스를 정의하려면 반드시 부모 클래스 정의 안에 중첩(또는 내부) 클래스로 선언하거나 같은 파일 안에 위치시키면 된다. 초기화 블록 init과 부 생성자 constructor를 사용하면 클래스 인스턴스를 더 유연하게 초기화할 수 있다. data class를 사용하면 컴파일러가 자동으로 equals, toString, hashCode, copy 등의 메소드를 생성해준다. field 식별자를 통해 프로퍼티 접근자인 게터와 세터 안에서 프로퍼티의 데이터를 저장하는 데 쓰이는 뒷받침하는 필드를 참조할 수 있다. 클래스 위임을 사용하면 위임 패턴을 구현할 때 필요한 준비 코드를 줄여 간단하게 코드를 구성할 수 있다. 객체 선언 object를 사용해 싱글톤 패턴을 구현할 수 있다. 동반 객체인 companion object는 자바의 정적 메소드와 필드 정의를 대신한다. 동반 객체도 객체이므로 인터페이스를 구현할 수 있으며, 외부에서 동반 객체에 대한 확장 함수와 프로퍼티를 정의할 수 있다. 객체 식인 object는 자바의 무명 내부 클래스를 대신한다. 하지만, 코틀린 객체 식은 여러 인스턴스를 구현하거나 객체가 포함된 영역에 있는 변수의 값을 변경할 수 있는 등 자바보다 더 많은 기능을 제공한다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"},{"name":"object","slug":"object","permalink":"http://victorywoolee/victorywoolee.github.io/tags/object/"}]},{"title":"[Kotlin] 데이터 클래스와 클래스 위임","slug":"Chap4-3","date":"2019-10-09T09:00:04.000Z","updated":"2019-10-09T12:19:02.945Z","comments":true,"path":"2019/10/09/Chap4-3/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/09/Chap4-3/","excerpt":"","text":"모든 클래스가 정의해야 하는 메소드 자바와 마찬가지로 코틀린 클래스도 toString, equals, hashCode 등을 오버라이드할 수 있다. 그리고 코틀린은 이런 메소드 구현을 자동으로 생성해 줄 수 있다. 한 가지 예를 통해서 이 메소드가 어떤 것인지에 대해 알아보자. 1class Client(val name: String, val postalCode: Int) 1. 문자열 표현: toString() 코틀린도 클래스 인스턴스의 문자열 표현을 얻을 방법을 제공하며 주로 디버깅과 로깅 시 해당 메소드를 사용한다. 기본 제공되는 방법은 객체 자체를 보여주기 때문에 toString을 오버라이드해서 기본 구현을 바꿔야 한다. 기본 문자열 표현을 바꿈으로써 더 많은 정보를 얻을 수 있다. 123class Client(val name: String, val postalCode: Int)&#123; override fun toString() = \"Client(name=$name, postalCode=$postalCode)\"&#125; 2. 객체의 동등성: equals() 서로 다른 두 객체가 내부에 동일한 데이터를 포함하는 경우 그 둘을 동등한 객체로 간주해야 할 수도 있다. 코틀린에서 == 연산자는 자바와 달리 참조 동등성을 검사하지 않고 객체의 동등성을 검사한다. 따라서 == 연산은 equals()를 호출하는 식으로 컴파일된다. 동등성 연산에 ==를 사용한다. 자바에서는 ==를 원시 타입과 참조 타입을 비교할 때 사용한다. 원시 타입의 경우 ==는 두 피연산자의 값이 같은지 비교한다.(동등성) 반면, 참조 타입의 경우 ==는 두 피연산자의 주소가 같은지를 비교한다.(참조 비교) 따라서 자바에서는 두 객체의 동등성을 알려면 equals()를 호출해야 한다. 코틀린에서는 == 연산자가 두 객체를 비교하는 가장 기본적인 방법이다. ==는 내부적으로 equals()를 호출해서 객체를 비교한다. 즉, 대상 내용 자체를 비교한다. 따라서 equals를 오버라이드하면 ==를 통해 안전하게 그 클래스의 인스턴스를 비교할 수 있다. 참조 비교를 위해서는 === 연산자를 사용할 수 있다. === 연산자는 자바에서 객체의 참조를 비교할 때 사용하는 == 연산자와 같다. 3. 해시 컨테이너: hashCode() 자바에서는 equals를 오버라이드할 때, hashCode도 함께 오버라이드 해야한다. JVM 언어에서는 hashCode가 지켜야 하는 제약이 있다. equals()가 true를 반환하는 두 객체는 반드시 같은 hashCode()를 반환해야 한다 processed 집합은 HashSet이다. HashSet은 원소를 비교할 때, 비용을 줄이기 위해 먼저 객체의 해시 코드를 비교하고 해시 코드가 같은 경우에만 실제 값을 비교한다. 아래의 두 Client 인스턴스는 해시 코드가 다르기 때문에 두 번째 인스턴스가 집합 안에 들어있지 않다고 판단한다. 해시 코드가 다를 때 equals()가 반환하는 값은 판단 결과에 영향을 끼치지 못한다. 즉, 원소 객체들이 해시 코드에 대한 규칙을 지키지 않는 경우, HashSet은 제대로 작동할 수 없다. 이 문제를 해결하기 위해서는 hashCode를 직접 구현하면 된다. 123val processed = hashSetOf(Client(\"이승우\", 9406))println(processed.contains(Client(\"이승우\", 9406)))// 결과 : false 위에서 살펴봤던 메소드를 코틀린 컴파일러는 자동으로 생성해준다. 데이터 클래스 코틀린에서 제공하는 data class는 data라는 변경자를 class 앞에 붙이면 된다. 이는 다음과 같은 메소드를 컴파일러 자동으로 만들어준다. 인스턴스 간 비교를 위한 equals HashMap과 같은 해시 기반 컨테이너에서 키로 사용할 수 있는 hashCode 클래스의 각 필드를 선언 순서대로 표시하는 문자열 표현을 만들어주는 toString 데이터 클래스와 불변성 copy equals와 hashCode는 주 생성자에 나열된 모든 프로퍼티를 고려해 만들어진다. 이때 주 생성자 밖에 정의된 프로퍼티는 equals나 hashCode를 계산할 때 고려의 대상이 되지 않는다. 데이터 클래스와 불변성 : copy() 코틀린 컴파일러가 생성해주는 메소드 중 하나이다. 데이터 클래스의 프로퍼티가 꼭 val일 필요는 없다. var 프로퍼티를 써도 되지만, 데이터 클래스의 모든 프로퍼티를 읽기 전용(val)으로 만들어서 불변 클래스로 만들라고 권장한다. HashMap 등의 컨테이너에 데이터 클래스 객체를 담는 경우에는 불변성이 필수적이다. data class 객체를 키로 하여 컨테이너에 담은 후 키로 쓰인 data class 객체의 프로퍼티를 변경할 경우에 컨테이너 상태가 잘못될 수 있기 때문이기도 하다. 또한, 불변 객체를 사용하면 프로그램에 대해 훨씬 쉽게 추론할 수 있다. 특히 다중스레드 프로그램의 경우 이런 성질은 더욱 중요하다. 불변 객체를 주로 사용하는 프로그램에서는 스레드가 사용 중인 데이터를 다른 스레드가 변경할 수 없으므로 스레드 동기화의 필요성이 줄어든다. data class 인스턴스를 불변 객체로 더 쉽게 활용할 수 있게 코틀린 컴파일러는 copy()라는 메소드를 제공한다. 이 메소드는 객체를 복사하면서 일부 프로퍼티를 바꿀 수 있게 해주는 copy 메소드다. 객체를 메모리상에서 직접 바꾸는 대신 복사본을 만드는 편이 낫다. 복사본은 원본과 다른 생명주기를 가지며, 복사를 하면서 일부 프로퍼티 값을 바꾸거나 복사본을 제거해도 프로그램에서 원본을 참조하는 다른 부분에 영향을 끼치지 않는다. 클래스 위임 : by 키워드 사용대규모 객체지향 시스템을 설계할 때 시스템을 취약하게 만드는 문제는 보통 구현 상속에 의해 발생한다. 하위 클래스가 상위 클래스의 메소드 중 일부를 오버라이드하면 하위 클래스는 상위 클래스의 세부 구현 사항에 의존한다. 시스템이 변함에 따라 상위 클래스의 구현이 바뀌거나 새로운 메소드가 추가되기도 한다. 그 과정에서 하위 클래스가 상위 클래스에 대해 갖고 있던 가정이 깨져 코드가 정상적으로 동작하지 못하는 경우가 생길 수 있다. 그래서 코틀린은 모든 클래스를 기본적으로 final로 취급하여 상속을 염두에 두고 open 변경자가 붙은 열린 클래스만 확장할 수 있다. 열린 상위 클래스의 소스 코드를 변경할 때는 open 변경자를 보고 해당 클래스를 다른 클래스가 상속하리라 예상할 수 있으므로, 변경 시 하위 클래스를 깨지 않기 위해 좀 더 조심할 수 있다. 하지만 종종 상속을 허용하지 않는 클래스에 새로운 동작을 추가해야할 때가 있는데 이때 사용하는 일반적인 방법이 데코레이터 패턴이다. 데코레이터 패턴과 관련된 내용은 직접 찾아보길 바란다! 이런 방법의 단점은 준비 코드가 상당히 많이 필요하다는 점이다. 예를 들어, Collection과 같은 단순한 인터페이스를 구현하면서 아무 동작도 변경하지 않는 데코레이터를 만들 때조차도 코드가 복잡해진다. 123456789class DelegatingCollection&lt;T&gt;: Collection&lt;T&gt; &#123; private val innerList = arrayListOf&lt;T&gt;() override val size: Int get() = innerList.size override fun isEmpty(): Boolean = innerList.isEmpty() override fun contains(element: T): Boolean = innerList.contains(element) override fun iterator(): Iterator&lt;T&gt; = innerList.iterator() override fun containsAll(elements: Collection&lt;T&gt;): Boolean = innerList.containsAll(elements)&#125; 이와 같은 위임을 언어가 제공하는 일급 시민 기능으로 지원한다는 점이 코틀린의 특징 중 하나이다. 코틀린은 인터페이스를 구현할 때 by 키워드를 통해 그 인터페이스에 대한 구현을 다른 객체에 위임한다는 사실을 명시할 수 있다. 아래는 위임을 사용해 코드를 재작성한 것이다. 1class DelegatingCollection&lt;T&gt;(innerList: Collection&lt;T&gt; = ArrayList&lt;T&gt;()): Collection&lt;T&gt; by innerList 클래스 안에 있던 모든 메소드 및 프로퍼티 정의가 사라졌다. 컴파일러가 그런 전달 메소드를 자동으로 생성하며 자동 생성한 코드의 구현은 DelegatingCollection에 있던 구현과 비슷하다. 컴파일러가 자동으로 해줄 수 있는 작업을 굳이 해야할 이유가 없다. 만약, 메소드 중 일부의 동작을 변경하고 싶은 경우에 메소드를 오버라이드하면 컴파일러가 생성한 메소드 대신 오버라이드한 메소드가 쓰인다. 기존 클래스의 메소드에 위임할 때, 기본 구현으로 충분한 메소드는 따로 오버라이드할 필요가 없다. 12345678910111213class CountingSet&lt;T&gt;(val innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()): MutableCollection&lt;T&gt; by innerSet&#123; var objectsAdded: Int = 0 override fun add(element: T): Boolean&#123; objectsAdded++ return innerSet.add(element) &#125; override fun addAll(c: Collection&lt;T&gt;): Boolean&#123; objectsAdded += c.size return innerSet.addAll(c) &#125;&#125;","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"},{"name":"데이터 클래스","slug":"데이터-클래스","permalink":"http://victorywoolee/victorywoolee.github.io/tags/데이터-클래스/"},{"name":"클래스 위임","slug":"클래스-위임","permalink":"http://victorywoolee/victorywoolee.github.io/tags/클래스-위임/"}]},{"title":"[Kotlin] 뻔하지 않은 프로퍼티와 생성자","slug":"Chap4-2","date":"2019-10-09T05:01:27.000Z","updated":"2019-10-09T08:59:24.713Z","comments":true,"path":"2019/10/09/Chap4-2/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/09/Chap4-2/","excerpt":"","text":"생성자 주 생성자 : 클래스를 초기화할 때 주로 사용하는 간략한 생성자로, 클래스 본문 밖에서 정의한다. (괄호 {} 밖에서 정의한다.) 부 생성자 : 클래스 본문 안에서 정의한다. (괄호 {} 안에서 정의한다.) 초기화 블록 : 초기화 로직을 추가할 수 있다. 클래스 초기화 클래스 이름 뒤에 오는 괄호롤 둘러싸인 부분은 주 생성자라고 부른다. 주 생성자에서는 생성자 파라미터를 지정하고 그 생성자 파라미터에 의해 초기화되는 프로퍼티를 정의하는 두 가지 목적에 쓰인다. constructor : 주 생성자, 부 생성자를 정의 init : 초기화 블록을 시작한다. 클래스의 객체가 만들어질 때, 실행될 초기화 코드가 들어간다. 주로 주 생성자와 함께 사용된다. 주 생성자는 제한적이기 때문에 별도의 코드를 포함할 수 없으므로 초기화 블록이 필요하다. 12345678class User constructor(_nickname: String)&#123; val nickname: String // 초기화 블록. init&#123; nickname = _nickname &#125;&#125; 위의 코드에서 nickname 프로퍼티를 초기화하는 코드를 nickname 프로퍼티 선언에 포함시켜서 초기화 블록을 제거할 수 있다. 그리고 주 생성자 앞에 가시성 변경자가 없다면 constructor 키워드를 생략할 수 있다. 123class User(_nickname: String)&#123; val nickname = _nickname&#125; 파라미터가 하나인 주 생성자이면서 프로퍼티를 주 생성자의 파라미터로 초기화한다. 프로퍼티를 초기화하는 식이나 초기화 블록 안에서만 주 생성자의 파라미터를 참조할 수 있다. 주 생성자의 파라미터로 프로퍼티를 초기화한다면 주 생성자 파라미터 앞에 val 키워드를 추가하여 프로퍼티 정의와 초기화를 간략하게 쓸 수 있다. 123class User(val nickname: String)// val은 이 파라미터에 상응하는 프로퍼티가 생성된다는 뜻이다. // 따라서 프로퍼티의 정의를 하고 초기화도 할 수 있다. 클래스의 인스턴스를 만들 때는 new 키워드 없이 생성 가능하다. 클래스가 상위 클래스를 상속받았다면 주 생성자에서 상위 클래스의 생성자를 호출해야 한다. 1234567open class User(name: String)&#123; ...&#125;class FacebookUser(name: String) : User(name)&#123; ...&#125; 클래스를 정의할 때 별도로 생성자를 정의하지 않으면 컴파일러가 자동으로 아무 일도 하지 않는 디폴트 생성자를 만들어준다. 비록 생성자는 인자를 받지 않지만, 해당 클래스를 상속받은 하위 클래스는 상위 클래스의 생성자를 호출해야만 한다. 이런 규칙으로 인해 상위 클래스 이름 뒤에는 빈 괄호가 꼭 들어가야 한다. (인자가 없다면, 인자가 있다면 생성자에 인자를 넣어준다.) 인터페이스의 경우 생성자가 없기 때문에 상속 받을 경우, 인터페이스의 이름만 명시해주면 된다. 12345open class Buttonclass RadioButton: Button()&#123; ...&#125; Tip모든 생성자 파라미터에 디폴트 값을 지정하면 컴파일러가 자동으로 파라미터가 없는 생성자를 만들어준다. 자동으로 만들어진 파라미터 없는 생성자는 디폴트 값을 이용해 클래스를 초기화한다.이와 같이 코틀린이 제공하는 파라미터 없는 생성자는 의존성 주입(DI, Dependency Injection) 프레임워크 등과의 통합을 쉽게 해준다. 이유는 파라미터가 없는 생성자를 통해 객체를 생성해 라이브러리를 사용할 수 있게 도와주기 때문이다. 부 생성자 코틀린에서는 생성자가 여럿 있는 경우가 많지 않다. 자바에서 오버로드한 생성자가 필요한 상황 중 상당수는 코틀린의 디폴트 파라미터 값와 이름 붙은 인자를 사용하면 해결된다. 생성자가 2개인 View 클래스가 있다고 하고 아래와 같은 코드의 구조를 보인다. 주 생성자는 없고 constructor 키워드를 가진 2개의 부 생성자를 가지고 있다. View 클래스를 확장한 Button 클래스에서는 super() 키워드를 이용해 부 생성자에서 상위 클래스의 생성자를 호출해 객체 생성을 위임한다. (자신에 대응하는 상위 클래스의 생성자를 호출한다.) 12345678910111213141516171819open class View&#123; constructor(ctx: Context)&#123; &#125; constructor(ctx: Context, attr: AttributeSet)&#123; &#125;&#125;class Button: View&#123; constructor(ctx: Context) : super(ctx)&#123; &#125; constructor(ctx: Context, attr: AttributeSet) : super(ctx,attr)&#123; &#125;&#125; this()를 통해 클래스 자신의 다른 생성자를 호출할 수도 있다. 다음은 파라미터 중 하나의 값에 디폴트 값을 넘겨 같은 클래스의 다른 생성자를 호출해 생성을 위임한다. 클래스에 주 생성자가 없다면 모든 부 생성자는 반드시 상위 클래스를 초기화하거나 다른 생성자에게 생성을 위임해야 한다. 부 생성자가 필요한 이유는 자바 상호운용성이다. 또는 클래스 인스턴스를 생성할 때, 파라미터 목록이 다른 생성 방법이 여럿 존재하는 경우다. 부 생성자를 사용할 때, 주의 사항이 있다. 이는 주 생성자가 아니므로 파라미터를 프로퍼티처럼 사용할 수 없다. 그래서 클래스 본문에서 참조해 사용할 수 없다. 생성자 파라미터를 프로퍼티처럼 사용하기 위해서는 주 생성자에서 선언해서 사용이 가능하다. 인터페이스에 선언된 프로퍼티 구현 인터페이스에 추상 프로퍼티 선언을 할 수 있다. 이 인터페이스를 구현하는 클래스가 추상 프로퍼티의 값을 얻을 수 있는 방법을 제공해야 한다. 아래 인터페이스가 있고 이를 구현한 클래스가 존재한다. 123456789101112131415161718192021interface User&#123; val nickname: String&#125;// 별명을 저장.// 주 생성자에 있는 프로퍼티class PrivateUser(override val nickname: String) : User// 이메일과 함께 저장.// 커스텀 게터class SubscribingUser(val email: String) : User&#123; override val nickname get() = eamil.substringBefore('@')&#125;// 페이스북 계정의 ID를 저장.// 함수를 이용한 프로퍼티 초기화 식class FacebookUSer(val accountId: Int) : User&#123; override val nickname = getFacebookName(accountId)&#125; Privateuser 주 생성자 안에 프로퍼티를 선언해 간결한 구문을 보여준다. SubscribingUser 커스텀 게터로 nickname 프로퍼티를 설정한다. 필드에 값을 저장하지 않고 매번 이메일 주소에서 별명을 계산한다. FacebookUser getFacebookName() 함수를 호출해 초기화한다. 페이스북에 접속해 인증을 거친 후 데이터를 가져와야 하기 때문에 비용이 많이들 가능성이 있다. 따라서 객체를 초기화하는 단계에서 한 번만 호출한다. 인터페이스에는 추상 프로퍼티뿐 아니라 게터와 세터가 있는 프로퍼티를 선언할 수 있다. 하지만, 게터와 세터는 필드를 참조할 수 없다. 이유는 필드가 초기화되어 있지 않기 때문이다. 필드가 있다는 것은 인터페이스에 상태를 추가한다는 의미인데, 인터페이스는 상태를 가질 수 없다. 게터와 세터에서 뒷받침하는 필드에 접근 값을 저장하는 동시에 어떠한 로직을 실행할 수 있게 하기 위해서는 접근자 안에서 프로퍼티를 뒷받침하는 필드에 접근할 수 있어야 한다. 간단한 예를 확인해보자. 123456789class User(val name: String)&#123; val address: String = \"not yet\" set(value: String)&#123; println(\"Address was changed for $name: \"$field\" -&gt; \"$value\". \"\"\".trimIndent()) field = value // 뒷받침하는 필드 값을 변경한다. &#125;&#125; field를 통해서 뒷받침하는 필드에 접근할 수 있다.(즉, address에 접근 가능.) 게터에서는 field 값을 읽을 수만 있고, 세터에서는 field 값을 읽거나 쓸 수 있다. 변경 가능 프로퍼티의 게터와 세터 중 한쪽만 직접 정의해도 된다. 접근자의 가시성 변경 get(), set() 앞에 가시성 변경자를 추가해 접근자의 가시성을 변경할 수 있다. 아래는 추가된 단어의 길이를 반환하는 함수가 있다. 이는 클라이언트에게 제공되므로 public으로 선언되 외부에 공개한다. 다만, 단어 길이의 합을 외부에서 바꾸지 못하도록 하기 위해서 게터는 그대로 냅두고, 세터의 가시성을 private으로 지정한다. 1234567891011121314class LengthCounter&#123; var counter: Int = 0 private set // 이 클래스의 밖에서 counter의 값을 바꿀 수 없다. fun addWord(word: String)&#123; counter += word.length &#125;&#125;val lengthCounter = LengthCounter()lengthCounter.addWord(\"Hi!\")println(lengthCounter.counter)// 결과:3","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"},{"name":"생성자","slug":"생성자","permalink":"http://victorywoolee/victorywoolee.github.io/tags/생성자/"}]},{"title":"[Android] Compose","slug":"Android-Compose","date":"2019-10-05T08:07:49.000Z","updated":"2019-10-06T13:21:00.377Z","comments":true,"path":"2019/10/05/Android-Compose/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/05/Android-Compose/","excerpt":"","text":"왜??선언적 프로그래밍이 UI 프로그래밍에 있어서 부상하고 있는 이유는 갈수록 복잡해지고 다양해지는 UI/UX 때문이라고 할 수 있다. 특히 애니메이션 같은 부분은 명령형으로 처리하기 매우 까다롭다. 가장 중요한 뷰의 상태라는 것에만 신경쓰고, 상세한 부분들은 프레임워크가 알아서 해주기를 기대하는 것이다. 기존의 안드로이드 UI 시스템에는 다음과 같은 문제가 있다. 안드로이드 프레임워크와 강하게 묶여있다. 안드로이드에서 제공하는 다양한 라이브러리들은 각자 버전이 따로 업데이트 된다. 그리고 개발자들은 다른 라이브러리를 신경쓰지 않고 필요한 버전만 해당 라이브러리에 적용해서 사용할 수 있다. 반면에, UI는 SDK와 함께 버전업이 되기 때문에 새로운 기능을 사용하려면 SDK를 함께 업데이트해야 한다. 하지만, SDK에는 UI만 있는게 아니기 때문에 버전을 올리기가 쉽지 않다. 예를 들면, 마시멜로에서 생긴 권한 체크가 그 중 한가지이다. 복잡한 코드와 클래스 구조 View.java의 소스는 거의 3만줄에 육박한다. 그만큼 복잡하며 길다. 그리고 특정 뷰에 어울리지 않는 동작들이 있다. 예를 들면, Button이 TextView의 속성을 그대로 가지고 있다. 그래서 버튼 안의 텍스트를 선택하거나 수정하는 등의 동작이 가능하다. 설명 영상에서는 이를 API Regret이라고 표현했다. 너무 많은 코드 커스텀 뷰를 작성하게 된다면 작성해야 하는 파일이 많다. 새로운 속성을 추가하기 위해서는 접근해야 하는 곳이 많다. CustomView.kt layout.xml attrs.xml styles.xml 이렇게 커스텀 뷰에 대해서 분산되어 있는 코드로 인해 수정과 유지보수를 위한 비용이 많이 든다. 일관되지 않은 데이터 흐름MVP, MVVM, MVI 등의 프론트엔드 아키텍처는 데이터 흐름을 일관되게 유지하는 것을 목적으로 하고 있다고 할 수 있다. 이러한 아키텍처들은 대부분 뷰에 상태를 두지 않고, 뷰의 변화를 관찰하는 개체가 뷰의 상태를 관리한다. 이를 통해서 데이터의 흐름이 한 방향으로 흐르도록 할 수 있다. 반면, 안드로이드 UI 시스템은 이러한 아키텍처들과는 다소 상반되는 구조를 가지고 있다. 안드로이드의 뷰들은 각자만의 상태를 가지고 있고, 스스로 상태를 제어한다. 이렇다보니 코드를 깔끔하게 만들지 않는다면 UI를 구현할 때나 디버깅을 할 때 힘들다. 목표??위에서 봤듯이 꽤 큰 문제들이 있다. Compose는 이러한 문제를 어떻게 해결할 수 있을까? SDK와 UI를 분리 SDK와 UI를 분리함으로써 서로 의존성을 갖지 않게 하여 UI를 업데이트하는데 편리함을 갖게 될 수 있다. 재사용 가능하고 간단한 View 구조 불필요한 상속을 없애고, 보일러플레이트 코드를 제거하는 것을 목표로 한다. 재사용 가능하고 작성한 대로 출력되는 직관적인 UI 코드를 작성하는 것이 목표다. 적은 코드 커스텀 뷰를 작성할 때처럼 layout, attr, style과 같은 파일로 분산시켜 작성하는 것에서 하나의 UI 코드를 작성함으로써 수정 및 유지보수의 비용을 줄일 수 있다. 하나의 데이터 흐름 State는 하나의 Owner만 갖으며, 하나의 Owner만 State를 변경한다. Owner가 이벤트를 감지하고 변경을 주도한다. Compose??1. UI 작성을 위한 선언적 방법 Jetpack에 포함된 Compose는 UI 개발을 단순화하도록 설계된 번들 툴킷이다. 반응형 프로그래밍 모델과 Kotlin 프로그래밍 언어의 간결함 및 사용 편의성을 결합한다. 주의해야할 점은 Compose가 아직 초기 알파 단계 버전이기 때문에 실제 프로덕션에 사용하는 것을 권장하지는 않는다. 2. 핵심 원칙 Concise and Idiomatic Kotlin(간결하고 관용적인 코틀린) 코틀린이 제공하는 이점으로 간결하고 안전하며 Java 언어와 완벽하게 상호 운용된다. 작성해야 하는 상용구 코드의 양을 대폭 줄이도록 설계되어 앱 코드에 집중하고 전체 클래스의 오류를 피할 수 있다. Declarative(선언적) 레이아웃을 그리는 것부터 생성을 포함해서 UI 구성 요소를 정의하는데 선언적인 방법을 사용한다. UI를 컴포저블 함수로 표현하면 프레임워크는 뷰 계층에 대한 자동 업데이트를 하고 UI 최적화를 처리한다. Compatible(호환) 기존의 View와 호완되므로 모든 Android 및 Jetpack API에 직접 접근해 원하는대로 혼합시키고 일치시킬 수 있다. Enable Beautiful Apps(아름다운 앱 사용) 처음부터 Material Design과 애니메이션으로 설계되어 모션이 가득한 멋진 앱을 만들 수 있다. Accelerate Development(개발 가속화) 적은 코드를 작성하고 Apply Changes 및 라이브 미리보기와 같은 도구를 사용해 개발을 가속화할 수 있다. 3. 핵심적인 아이디어 UI as a function 어떤 입력을 받아 결과를 반환하는 함수의 아이디어를 UI로 확장해서 어떤 입력을 받아 UI 구조를 반환하는 함수라고 생각하면 된다. 함수는 어떠한 상태도 가지고 있지않고, 외부의 어떤 상태도 변경해서는 안된다. 그저 자신이 그려야할 UI의 계층을 반환할 뿐이다. -&gt; 순수함수 또한, Kotlin의 함수로 UI를 표현하기 때문에 XML에서는 불가능한 프로그래밍 언어의 다양한 기능을 UI를 작성하는데 활용할 수 있다. 123fun Greeting(name: String)&#123; Text(\"Hello $name\")&#125; Composable is composable Compose의 UI 위젯을 사용하기 위해서는 @Composable 어노테이션을 붙여줘야 한다. 그리고 이 함수는 다른 Composable 함수를 포함할 수 있다. 1234@Composablefun Greeting(name: String)&#123; Text(\"Hello $name\")&#125; Observable Model 데이터의 변경이 생길 때마다 직접 UI를 업데이트하는 건 번거로운 작업이다. 이런 문제를 해결하기 위해 RxJava나 LiveData와 같은 Observable을 사용하면 된다. 123vm.state.observe(this) &#123; state -&gt; updateUi(state)&#125; Compose에서는 데이터가 바뀔 때마다 UI를 변경시키기 위해서 LiveData를 사용하는 방법을 쓸 수도 있다. 123vm.name.observe(this) &#123; name -&gt; Greeting(name)&#125; 그려야할 데이터가 많다면 각 데이터에 대해 일일히 LiveData를 만들어줘야 하기 때문에 불편하다. 이런 경우에는 data class에 @Model 어노테이션을 붙여주어 값이 변경될 때마다 해당 값을 참조하고 있는 Composable 함수가 다시 Compose 된다고 한다. 2가지 주요 구성 요소 레이아웃, 입력, 텍스트, 애니메이션, 스타일, 위젯 및 그래픽이 포함된 핵심 UI 툴킷이 포함된 UI 라이브러리를 포함해야 한다. 컴포저블 기능을 수행하고 UI 계층 구조를 자동으로 업데이트하는 사용자 정의 Kotlin 컴파일러 플러그인, Compose 컴파일러를 포함해야 한다. Compose Application은 애플리케이션 데이터를 UI 계층으로 변환하는 Composable한 함수로 구성되어있다. @Composable 어노테이션을 추가해 컴포저블한 함수를 만들 수 있다. 기본적으로 Compose는 사용자 정의 Kotlin 컴파일러 플러그인을 사용하므로 기본 데이터가 변경되면 업데이트 가능한 UI 계층을 생성하기 위해 작성 가능한 기능을 다시 호출할 수 있다. 실행Compose는 아직 pre-alpha 단계다. 그래서 다른 라이브러리처럼 간단하게 dependency를 추가해서 사용할 수 없다. 대신에 오픈 소스를 가져와서 직접 빌드해야 한다. repo AOSP(Android Open Source Project)에서는 repo라는 툴을 사용해 버전 관리를 한다. Git과 비슷하지만, 안드로이드에 좀 더 적합하게 만들었다고 한다. 다음 명령어를 통해 repo를 설치하면 된다. 12$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; repo$ chmod a+x repo source 초기화 및 소스 코드의 Sync를 맞춘다.12$ repo init -u https://android.googlesource.com/platform/manifest -b androidx-master-dev$ repo sync -j8 -c 시작 소스를 내려받고 /frameworks/support/ui 위치로 이동해서 안드로이드 스튜디오를 실행하면 된다. 평소에 사용하는 버전이 아니라 지정된 버전을 사용해야 하기 때문에 studiow를 통해 안드로이드 스튜디오를 실행하면 된다고 한다. 12$ cd androidx-master-dev/frameworks/support/ui$ ./studiow API - Annotations Composable 이 어노테이션을 붙인 함수는 Compose의 기본이 되는 Composable Widget으로써 기능한다. 반환 타입을 따로 정의하지 않는다. 코틀린 컴파일러 플러그인을 통해서 구현된다. 따라서 컴파일 전과 후의 코드는 완전히 다르고, 우리가 일반적으로 알던 코틀린의 실행 흐름과 다르게 동작할 수 있다. Model 위젯에서 사용되는 데이터를 정의할 수 있다. 이 모델이 변경될 경우 위젯이 다시 렌더링된다. API - EffectsEffect는 위젯을 그리는 단계에서 어떠한 코드를 실행하고 싶을 때 사용한다. 이해하기 위해서 Compose의 실행 흐름을 이해할 필요가 있다 Execution Flow 1) Composition Phase 이 단계에서는 어떤 위젯을 그릴 것인지 선언한다. 선언적 프로그래밍 패러다임에는 지연 실행이라는 개념이 있는데, 최대한 실제 실행을 뒤로 미루는 것을 말한다. 이렇게 화면에 렌더링을 한다라는 실제 실행을 하기 이전에 어떻게 그릴 것인가를 정의하는 단계이다. 2) Execution Phase Compostion Phase에서 정의했던 Component의 그래프를 화면에 렌더링하는 단계이다. 123456789101112@Modeldata class Counter(val number: Int=0)&#123; fun increment(): Counter = Counter(number + 1)&#125;@Composablefun CounterWidget()&#123; var counter = Counter() Text(text = \"Counter : $&#123;counter.value&#125;\") Button(onClick = &#123;counter = counter.increment()&#125;)&#125; CounterWidget에는 counter라는 로컬 변수, 즉 상태가 존재한다. Text에서는 그것을 보여주고 Button에서는 그 값을 업데이트하고 있다. @Model로 모델 클래스임을 명시했으니 모든게 완벽하다. 버튼을 누르면 값이 증가하는 동작을 실행할 것 같지만 그렇지 않다. 앞서 @Composable 어노테이션을 이야기할 때, 코드가 일반적인 코틀린의 실행 흐름과는 다르게 동작할 수 있다고 언급했었다. Compose의 위젯들은 일종의 Context 위에서 실행된다. 따라서 위젯에서 필요한 데이터 역시 이 Context 위에 올라가 있어야 한다. 이를 도와주는게 Effect라는 것을 사용하면 가능하다. 123456789101112@Modeldata class Counter(val number: Int=0)&#123; fun increment(): Counter = Counter(number + 1)&#125;@Composablefun CounterWidget()&#123; var counter = +memo&#123; Counter() &#125; Text(text = \"Counter : $&#123;counter.value&#125;\") Button(onClick = &#123;counter = counter.increment()&#125;)&#125; 이전의 코드에서 memo Effect와 해당 Effect를 resolve하는 +(unaryPlus) 연산자 오버로딩 함수를 붙여주면 제대로 동작함을 확인할 수 있다. Effect의 이름 Effect는 개념적으로 리턴 값을 가지고 있는 Composable 함수이고 이게 Compose의 실행 흐름에 일종의 효과를 적용하는 것과 비슷해서 Effect라고 지은 것으로 추측된다. Defined Effects 몇 가지 미리 정의되어 있는 Effect들이 존재하며 다음과 같다. 실제 사용 예는 대부분 실행 단계에서 필요한 어떤 값을 가져오기 위한 목적으로 쓴다. Memo 단순히 어떤 실행 블록을 기억하는 역할을 한다.123fun &lt;T&gt; memo(calculation: () -&gt; T) = effectOf&lt;T&gt;&#123; context.remember(calculation)&#125; calculation 코드 블록에서 반환하는 클래스에 @Model이 붙어있지 않으면 Composition이 다시 이루어져도 이 코드 블록은 재실행되지 않는다. State memo와 비슷하지만, 단순히 어떤 코드 블록을 기억하는 목적이 아니라 위젯에서 사용할 Local State의 개념을 가지고 있는 Effect이다. State는 Compose의 모델 클래스이고, 단순히 어떤 값을 wrapping하고 있는 클래스다. 123456fun &lt;T&gt; state(init: () -&gt; T) = memo &#123; State(init()) &#125;@Modelclass State&lt;T&gt; internal constructor(value: T) : Framed &#123; /* ... */&#125; Lifecycle Effects 그 외 3 가지 Composition의 라이프사이클에 관련된 Effect가 존재한다. onActive : Composition이 처음 실행될 때 호출되고, 그 이후로는 호출되지 않는다. onDispose : 해당 위젯이 더 이상 화면에서 보이지 않을 때 호출된다. onCommit : Compostion이 실행될 때마다 호출된다. 선언형 프로그래밍과 명령형 프로그래밍 명령형 프로그래밍 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 방식 알고리즘을 명시하고 목표는 명시하지 않는다.123val container = binding.containercontainer.removeAllViews()containter.setBackgroundColor(Color.BLUE) 원하는 상태를 만들기 위해 명령문을 사용한다. 위의 코드는 container에게 모든 뷰를 제거, 백그라운드 색상을 지정하는 등의 명령을 내린다. 제어 흐름이 명확하다는 장점이 있지만, 반대로 어떤 상태에 도달하려는 것인지 명확하지 않다. 선언형 프로그래밍 제어 흐름이 아니라 어떤 상태를 원하는지 서술한다.123456return State( backgroundColor = Color.RED, children = [ createNewButton() ]) 이런 방식이 제대로 동작하기 위해서는 이전 상태와 다음 상태를 비교하고 전환을 수행하는 기능을 프레임워크가 제공해야 한다. 리액트가 이런 방식으로 동작한다고 한다. 상태를 비교하고 상태가 다를 경우 해당 부분만 렌더링한다. 참고 Google Developer Android Studio Jetpack Compose &amp; Sample App How to install Repo @tura velog","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Jetpack","slug":"Jetpack","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Jetpack/"},{"name":"Compose","slug":"Compose","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Compose/"}]},{"title":"[CleanCode] 8장","slug":"CleanCode08","date":"2019-10-04T13:24:51.000Z","updated":"2019-10-05T01:46:20.302Z","comments":true,"path":"2019/10/04/CleanCode08/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/04/CleanCode08/","excerpt":"","text":"외부 코드 사용하기 인터페이스 제공자와 인터페이스 사용자 사이에는 특유의 긴장이 존재한다. 패키지 제공자나 프레임워크 제공자는 적용성을 최대한 넓히려 애쓴다. 더 많은 환경에서 돌아가야 더 많은 고객이 구매하기 때문이다. 반면, 사용자는 자신의 요구에 집중하는 인터페이스를 바란다. 이런 긴장으로 인해 시스템 경계에서 문제가 생길 소지가 많다. Map은 굉장히 다양한 인터페이스로 수많은 기능을 제공한다. Map이 제공하는 기능성과 유연성은 확실히 유용하지만, 그만큼 위험부담이 크다. ex)12Map sensors = new HashMap(); // Map 생성Sensor s = (Sensor) sensors.get(sensorId); // Sensor 객체를 가져온다. 위와 같은 코드가 한 번이 아니라 여러 차례 나온다. 즉, Map이 반환하는 Object를 올바른 유형으로 변환할 책임은 Map을 사용하는 클라이언트에 있다. 그래도 코드는 올바르게 동작한다. 하지만, 깨끗한 코드라 보기 어렵다. 제네릭을 사용하면 코드 가독성이 높아진다. 12Map&lt;String, Sensor&gt; sensors = new HashMap&lt;Sensor&gt;();Sensor s = sensors.get(sensorId); 하지만, 위의 방법도 결국 사용자에게 필요하지 않은 기능까지 제공한다는 문제가 남아있다. Map&lt;String, Sensor&gt;아래는 Map을 조금 더 깔끔하게 사용한 코드다. Sensors 사용자는 제네릭이 사용되었는지 여부에 신경 쓸 필요가 없다. 제네릭의 사용 여부는 Sensors 안에서 결정한다. 1234567public class Sensors&#123; private Map sensors = new HashMap(); public Sensor getById(String id)&#123; return (Sensor) sensors.get(id); &#125;&#125; 경계 인터페이스인 Map은 Sensors 안으로 숨긴다. 따라서 Map 인터페이스가 변하더라도 나머지에는 영향을 미치지 않는다. 제네릭을 사용하든 말든 문제가 되지 않는다. Sensors 클래스 안에서 객체 유형을 관리하고 변환하기 때문이다. 또한, Sensors 클래스는 프로그램에 필요한 인터페이스만 제공한다. 그래서 코드는 이해하기 쉽지만 오용하기는 어렵다. Sensors 클래스는 나머지 프로그램이 설계 규칙과 비즈니스 규칙을 따르도록 강제할 수 있다. Map과 같은 경계 인터페이스를 사용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다. Map 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않는다. 경계 살피고 익히기 외부 코드를 익히기는 어렵다. 외부 코드를 통합하기도 어렵다. 곧바로 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히면 어떨까? 이를 학습 테스트라 부른다. 학습 테스트는 프로그램에서 사용하려는 방식대로 외부 API를 호출한다. 통제된 환경에서 API를 제대로 이해하는지를 확인하는 셈이다. 학습 테스트는 API를 사용하려는 목적에 초점을 맞춘다. 학습 테스트는 공짜 이상이다 학습 테스트에 드는 비용은 없다. 오히려 필요한 지식만 확보하는 손쉬운 방법이다. 이해도를 높여준다. 투자하는 노력보다 얻는 성과가 크다. 학습 테스트를 이용한 학습이 필요하든 그렇지 않든, 실제 코드와 동일한 방식으로 인터페이스를 사용하는 테스트 케이스가 필요하다. 이런 경계 테스트가 있다면 패키지의 새 버전으로 이전하기 쉬워진다. 그렇지 않다면 낡은 버전을 필요 이상으로 오랫동안 사용하려는 유혹에 빠지게 된다. 아직 존재하지 않는 코드를 사용하기 경계와 관련해 또 다른 유형은 아는 코드와 모르는 코드를 분리하는 경계다. 아직 존재하지 않는 코드를 위해 인터페이스를 사용해 설계를 먼저 한다. 우리가 바라는 인터페이스를 구현하면 우리가 인터페이스를 전적으로 통제한다는 장점이 생긴다. 또한 코드 가독성도 높아지고 코드 의도도 분명해진다. 깨끗한 경계 경계에 위치하는 코드는 깔끔히 분리한다. 또한 기대치를 정의하는 테스트 케이스도 작성한다. 통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 좋다. 자칫하면 외부 코드에 휘둘리고 만다. 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자. 새로운 클래스로 경계를 감싸거나 Adapter 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하자. 어느 방법이든 코드 가독성이 높아지며, 경계 인터페이스를 사용하는 일관성도 높아지며, 외부 패키지가 변했을 때, 변경할 코드도 줄어든다.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"경계","slug":"경계","permalink":"http://victorywoolee/victorywoolee.github.io/tags/경계/"}]},{"title":"[CleanCode] 7장","slug":"CleanCode07","date":"2019-10-04T08:39:45.000Z","updated":"2019-10-04T12:04:16.120Z","comments":true,"path":"2019/10/04/CleanCode07/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/04/CleanCode07/","excerpt":"","text":"깨끗한 코드와 오류 처리는 연관성이 있다. 상당수 코드 기반은 전적으로 오류 처리 코드에 좌우된다. 여기저기 흩어진 오류 처리 코드 때문에 실제 코드가 하는 일을 파악하기가 거의 불가능하다는 의미다. 오류 처리는 중요하다. 하지만, 오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워진다면 깨끗한 코드라 부르기 어렵다. 오류 코드보다 예외를 사용하라 예외를 처리하지 않고 오류를 처리하고 보고하는 방법은 제한적이다. 오류 플래그를 설절하거나 호출자에게 오류 코드를 반환하는 방법이 전부다. 이와 같은 방법은 호출자 코드가 복잡해진다. 함수를 호출한 즉기 오류를 확인해야 하기 때문이다. 이 단계는 잊어버리기 쉽다. 오류가 발생하면 예외를 던지는 편이 낫다. 그러면 호출자 코드가 깔끔해진다. 예외를 던지면 코드가 확실히 깨끗해진다. 코드 품질도 나아진다. Try-Catch-Finally 작성해라 try 블록에 들어가는 코드를 실행하면 어느 시점에서든 실행이 중단된 후 catch 블록으로 넘어갈 수 있다. try 블록은 트랜잭션과 비슷하다. try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성 있게 유지해야 한다. 그러므로 예외가 발생할 코드를 짤때는 try-catch-finally 문으로 시작하는 편이 낫다. 그러면 try 블록에서 무슨 일이 생기든지 호출자가 기대하는 상태를 정의하기 쉬워진다. 미확인을 사용하라 자바가 처음에 나왔을 때는 사람들이 확인된 예외를 멋진 아이디어라고 생각했다. 당시에는 그랬지만, 지금은 아니다. 확인된 오류가 치르는 비용에 상응하는 이익을 제공하는지 철저히 따져봐야 한다. 확인된 예외는 OCP를 위반한다. 예를 들어, 메소드에서 확인된 예외를 던졌는데 catch 블록이 세 단계 위에 있다면 그 사이 메소드 모두가 선언부에 해당 예외를 정의해야 한다. 즉, 하위 단계에서 코드를 변경하면 상위 단계 메소드 선언부를 전부 고쳐야 한다. 모듈과 관련된 코드가 전혀 바뀌지 않았더라도 (선언부가 바뀌었으므로) 모듈을 다시 빌드한 다음 배포해야 한다는 말이다. 대규모 시스템에서 호출이 일어나는 방식을 생각해보자. 최상위 함수가 아래 함수를 호출한다. 아래 함수는 그 아래 함수를 호출한다. 단계를 내려갈수록 호출하는 함수의 수가 늘어난다. 이제 최하위 함수를 변경해 새로운 오류를 던진다고 가정하자. 확인된 오류를 던진다면 함수는 선언부에 throws 절을 추가해야 한다. 그러면 변경한 함수를 호출하는 함수 모두가 catch 블록에서 새로운 예외를 처리하거나 선언부에 throw 절을 추가해야 한다. 결과적으로 취하위 단계에서 최상위 단계까지 연쇄적인 수정이 일어난다. throws 경로에 위치하는 모든 함수가 최하위 함수에서 던지는 예외를 알아야 하므로 캡슐화가 깨진다. 오류를 원거리에서 처리하기 위해 예외를 사용한다는 사실을 감안한다면 이처럼 확인된 예외가 캡슐화를 깨버리는 현상은 참으로 유감스럽다. 예외에 의미를 제공하라 예외를 던질 때는 전후 상황을 충분히 덧붙인다. 그러면 오류가 발생한 원인과 위치를 찾기가 쉬워진다. 호출자를 고려해 예외 클래스를 정의하라 오류를 분류하는 방법은 수없이 많다. 오류가 발생한 위치로 분류할 수도 있고, 오류가 발생한 컴포넌트로 분류한다. 또는 유형으로도 분류가 가능하다. 하지만, 애플리케이션에서 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야 한다. 아래는 외부 라이브러리를 호출하는 try-catch-finally문을 포함한 코드이다. 12345678910111213141516ACMEPort port = new ACMEPort(12);try&#123; port.open();&#125; catch(DeviceResponseException e)&#123; reportPortError(e); logger.log(\"Device response exception\", e);&#125; catch(ATM1212UnlockedException e)&#123; reportPortError(e); logger.log(\"Unlock exception\", e);&#125; catch(GMXError e)&#123; reportPortError(e); logger.log(\"Device response exception\", e);&#125; finally&#123; ...&#125; 중복이 심하지만 놀랍지 않다. 대다수 상황에서 우리가 오류를 처리하는 방식은 (오류를 일으킨 원인과 무관하게)비교적 일정하다. 오류를 기록한다. 프로그램을 계속 수행해도 좋은지 확인한다. 위의 경우는 예외를 대응하는 방식이 예외 유형과 무관하게 거의 동일하다. 그래서 코드를 고치기 쉽다. 123456789LocalPort port = new LocalPort(12);try &#123; port.open();&#125; catch(PortDeviceFailure e)&#123; reportError(e); logger.log(e.getMessage(), e)&#125; finally&#123; ...&#125; LocalPort 클래스가 ACMEPort 클래스가 던지는 예외를 잡아 변환하는 감싸주는 클래스다. LocalPort 클래스처럼 ACMEPort를 감싸는 클래스는 유용하다. 이렇게 외부 API를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어든다. 나중에 다른 라이브러리로 갈타도 비용이 적다. 또한, 감싸기 클래스에서 외부 API를 호출하는 대신 테스트 코드를 넣어주는 방법으로 프로그램을 테스트하기도 쉬워진다.123456789101112131415161718192021222324public class LocalPort&#123; private ACMEPort innerPort; public LocalPort(int portNumber)&#123; innerPort = new ACMEPort(portNumber); &#125; public void open()&#123; try&#123; innerPort.open(); &#125; catch(DeviceResponseException e)&#123; reportPortError(e); logger.log(\"Device response exception\", e); &#125; catch(ATM1212UnlockedException e)&#123; reportPortError(e); logger.log(\"Unlock exception\", e); &#125; catch(GMXError e)&#123; reportPortError(e); logger.log(\"Device response exception\", e); &#125; finally&#123; ... &#125; &#125;&#125; 정상 흐름을 정의하라 비즈니스 논리와 오류 처리가 잘 분리된 코드가 깨끗하다. 그리고 간결한 알고리즘이 보이기 시작한다. 하지만, 그러다 보면 오류 감지가 프로그램 언저리로 밀려난다. 외부 API를 감싸 독자적인 예외를 던지고 코드 위에 처리기를 정의해 중단된 계산을 처리한다. 대개는 멋진 방식이지만, 때로는 중단이 적합하지 않은 때도 있다. 특수 상황을 처리할 필요가 없다면 더 좋고, 코드가 훨씬 깔끔해진다. 특수 사례 패턴은 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식이다. 그러면 클라이언트 코드가 예외적인 상황을 처리할 필요가 없어진다. 클래스나 객체가 예외적인 상황을 캡슐화해서 처리하므로. null을 반환하지 마라 null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다. null 확인을 중간에 빼먹는다면 애플리케이션이 통제 불능에 빠지게 될지도 모른다. 메소드에서 null을 반환하고픈 유혹이 든다면 그 대신 예외를 던지거나 특수 사례 객체를 반환한다. 사용하려는 외부 API가 null을 반환한다면 감싸기 메소드를 구현해 예외를 던지거나 특수 사례 객체를 반환하는 방식을 고려한다. 123456List&lt;Employee&gt; employees = getEmployees();if(employees != null)&#123; for (Employee e: employees)&#123; totalPay += e.getPay(); &#125;&#125; 위에서 getEmployees()는 null을 반환할 수도 있다. 하지만, 반드시 null을 반환할 필요가 있을까? getEmployees()를 변경해 빈 리스트를 반환한다면 코드가 훨씬 깔끔해진다. 12345678910public List&lt;Employee&gt; getEmployees()&#123; if(직원이 없다면)&#123; return Collections.emptyList(); &#125;&#125;List&lt;Employee&gt; employees = getEmployees();for (Employee e: employees)&#123; totalPay += e.getPay();&#125; Collections.emptyList()가 있어 미리 정의된 읽기 전용 리스트를 반환한다. null을 반환하는 부분을 변경하면 위 코드처럼 깔끔하게 처리할 수 있으며 NullPointerException이 발생할 가능성도 줄어든다. null을 전달하지 마라 메소드로 null을 전달하는 방식을 null을 반환하는 것보다 더 나쁘다. 정상적인 인수로 null을 기대하는 API가 아니라면 메소드로 null을 전달하는 코드는 최대한 피한다. 대다수 프로그래밍 언어는 호출자가 실수로 넘기는 null을 적절하게 처리하는 방법이 없다. 그렇다면 애초에 null을 넘기지 못하도록 금지하는 정책이 합리적이다. 즉, 인수로 null이 넘어오면 코드에 문제가 있다는 의미다. 이런 정책을 따르면 그만큼 부주의한 실수를 저지를 확률도 작아진다. 결론깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다. 이 둘은 상충하는 목표가 아니다. 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다. 오류 처리를 프로그램 논리와 분리하면 독립적인 추론이 가능해지며 코드 유지보수성도 크게 높아진다.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"오류 처리","slug":"오류-처리","permalink":"http://victorywoolee/victorywoolee.github.io/tags/오류-처리/"}]},{"title":"[Kotlin] 클래스와 인터페이스","slug":"Chap4-1","date":"2019-10-04T06:35:18.000Z","updated":"2019-10-12T05:53:56.163Z","comments":true,"path":"2019/10/04/Chap4-1/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/04/Chap4-1/","excerpt":"","text":"클래스 계층 정의1. 코틀린 인터페이스 추상 메소드 뿐 아니라 구현이 있는 메소드도 정의할 수 있다. 아무런 상태(필드)도 들어갈 수 없다. 인터페이스의 선언은 자바와 같으며, extends(상속)와 implements(구현)은 코틀린에서는 모두 콜론(:) 키워드를 사용해 클래스 확장과 인터페이스 구현을 모두 처리한다. override 변경자는 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메소드를 오버라이드한다는 표시다. 꼭 사용해야 한다. 디폴트 구현은 단지 메소드 본문은 시그니처 뒤에 작성하면 된다. 1234interface Clickable&#123; fun click() // 일반 메소드 선언 fun showOff() = println(\"I'm clickable!! \") // 디폴트 구현이 있는 메소드&#125; 위 인터페이스를 구현하는 클래스는 click에 대한 구현을 제공해야 한다. 반면, showOff() 메소드의 경우 새로운 동작은 정의할 수도 있고 그냥 정의를 생략해서 디폴트 구현을 사용할 수도 있다. 그러면 다른 인터페이스가 showOff()와 같은 구현을 포함한다고 가정해보자. 1234interface Focusable&#123; fun setFocus(b: Boolean) = println(\"I $&#123;if (b) \"got\" else \"lost\"&#125; focus. \") fun showOff() = println(\"I'm focusable!! \")&#125; 이제 한 클래스에서 이 두 인터페이스를 함께 구현하면 어떻게 될지 궁금하다. 두 인터페이스 모두 디폴트 구현이 들어있는 showOff() 메소드가 있다. 어느쪽 showOff() 메소드가 선택될까? 결론은 어느쪽도 선택되지 않는다. 클래스가 구현하는 두 상위 인터페이스에 정의된 showOff() 구현을 대체할 오버라이딩 메소드를 직접 제공하지 않으면 컴파일 오류가 발생한다. 이처럼 코틀린 컴파일러는 두 메소드를 아우르는 구현을 하위 클래스에 직접 구현하게 강제한다. 123456789class Button: Clickable, Focusable&#123; override fun click() = println(\"I was clicked!! \") override fun showOff() &#123; super&lt;Clickable&gt;.showOff() super&lt;Focusable&gt;.showOff() // 상위 타입의 이름을 꺽쇠 괄호 사이에 넣어서 super를 지정하면 // 어떤 상위 타입의 메소드를 호출할 지 지정할 수 있다. &#125;&#125; super.showOff()처럼 꺽쇠 괄호 안에 기반 타입 이름을 지정한다. 상속한 구현 중 단 하나만 호출해도 된다면 상위 타입의 메소드를 하나만 지정해도 된다. 2. open, final, abstract 변경자 취약한 기반 클래스라는 문제는 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우에 생긴다. 어떤 클래스가 자신을 상속하는 방법에 대해 정확한 규칙(어떤 메소드를 어떻게 오버라이드해야 하는지 등)을 제공하지 않는다면 그 클래스의 클라이언트는 기반 클래스를 작성한 사람의 의도와 다른 방식으로 메소드를 오버라이드할 위험이 있다. 모든 하위 클래스를 분석하는 것은 불가능하므로 기반 클래스를 변경하는 경우, 하위 클래스의 동작이 예기치 않게 바뀔 수도 있다는 면에서 기반 클래스는 취약하다. 위와 같은 문제를 고려해 코틀린의 클래스와 메소드는 기본적으로 final이다. 어떤 클래스의 상속을 허용하려면 클래스 앞에 open 변경자를 붙여야 한다. 그와 더불어 오버라이드를 허용하고 싶은 메소드 앞에도 open 변경자를 붙여야 한다. 123456789101112// open을 통해서 상속 가능하도록 열려 있음.open class RichButton: Clickable&#123; // final로 하위 클래스에서 오버라이드할 수 없다. fun disable() &#123; &#125; // open을 통해서 오버라이드 가능하도록 열려있다. open fun animate() &#123; &#125; // 상위 클래스에서 선언된 열려있는 메소드를 오버라이드한다. // 오버라이드한 메소드는 기본적으로 열려있다. override fun click() &#123; &#125;&#125; 주의해야 할 점은 기반 클래스나 인터페이스의 멤버를 오버라이드하는 경우 그 메소드는 기본적으로 열려있다. 오버라이드하는 메소드의 구현을 하위 클래스에서 오버라이드하지 못하게 금지하려면 오버라이드하는 메소드 앞에 final 변경자를 붙여 닫혀 있도록 만들어야 한다. 1234open class RichButton: Clickable &#123; final override fun click() &#123; &#125; // 이렇게 함으로써 오버라이드한 메소드는 열려있지 않게 된다.&#125; Tip스마트 캐스트는 타입 검사 뒤에 값이 변경될 수 없는 변수에만 적용이 가능하다. 클래스 프로퍼티의 경우 val이면서 커스텀 접근자가 없는 경우에만 사용할 수 있다는 의미다. 이 요구 사항은 프로퍼티가 final이어야만 한다는 뜻이기도 하다. final이 아니라면 그 프로퍼티를 다른 클래스가 상속하면서 커스텀 접근자를 정의함으로써 스마트 캐스트의 요구 사항을 깰 수도 있기 때문이다. abstract abstract를 사용해 추상 클래스를 선언할 수 있으며, 추상 클래스는 인스턴스화 할 수 없다. 구현이 없는 추상 멤버가 있어 하위 클래스에서 추상 멤버를 오버라이드 해야 한다. 추상 멤버는 항상 열려있다. 따라서 open을 명시할 필요가 없다. 1234567891011abstract class Animated &#123; abstract fun animate() open fun stopAnimating()&#123; &#125; fun animateTwice()&#123; &#125;&#125; 추상 클래스에 속하는 비추상 함수는 기본적으로 final이지만, 원한다면 open으로 오버라이드를 허용할 수 있다. 상속 제어 변경자 인터페이스 멤버의 경우 final, open, abstract를 사용하지 않는다. 인터페이스 멤버는 항상 열려있으며, final로 변경할 수 없다. 인터페이스 멤버에게 본문이 없으면 자동으로 추상 멤버가 되지만, 그래도 따로 abstract를 명시적으로 지정할 필요가 없다. final : 오버라이드할 수 없으며, 이는 클래스 멤버의 기본 변경자다. open : 오버라이드할 수 있으며, 반드시 open을 명시해야 오버라이드할 수 있다. abstract : 반드시 오버라이드해야 하며, 추상 클래스의 멤버에만 이 변경자를 붙일 수 있다. 추상 멤버에는 구현체가 있으면 안된다. override : 상위 클래스나 상위 인스턴스의 멤버를 오버라이드하는 것을 나타낸다. 오버라이드하는 멤버는 기본적으로 열려있다. 하위 클래스의 오버라이드를 금지하라면 final을 명시해야 한다. 가시성 변경자 : 기본적으로 공개 클래스 외부 접근을 제어한다. 어떤 클래스의 구현에 대한 접근을 제한함으로써 그 클래스에 의존하는 외부 코드를 깨지 않고도 클래스 내부 구현을 변경할 수 있다. public, protected, private이 있다. 기본 변경자는 모두 공개된다. 즉, public이다. 코틀린은 패키지를 가시성 제어에 사용하지 않는다. internal은 모듈 내부에서만 볼 수 있다는 뜻이다. 모듈 : 한 번에 한꺼번에 컴파일되는 코틀린 파일들을 의미한다. 자바에서는 패키지가 같은 클래스를 선언하기만 하면 외부의 다른 프로젝트에서 접근이 가능하기 때문에 캡슐화가 깨지기 쉽다. 하지만, 모듈 내부 가시성은 모듈의 구현에 대해 진정한 캡슐화를 제공한다는 장점이 있다. 최상위 선언에 대해 private 가시성을 허용한다. 코틀린의 가시성 변경자 public(기본) : 클래스 멤버와 최상위 선언 모두 모든 곳에서 볼 수 있다. internal : 클래스 멤버, 최상위 선언 모두 같은 모듈 안에서만 볼 수 있다. protected : 클래스 멤버는 하위 클래스 안에서만 볼 수 있으며, 최상위 선언에 적용할 수 없다. private : 클래스 멤버는 같은 클래스 안에서만 볼 수 있으며, 최상위 선언에 적용되면 같은 파일 안에서만 볼 수 있다. 유의해야할 점은 자바에서는 같은 패키지 안에서 protected 멤버에 접근할 수 있지만, 코틀린은 그렇지 않다는 것이다. 코틀린에서 protected 멤버는 오직 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 보인다. 클래스를 확장한 함수는 그 클래스의 private이나 protected 멤버에 접근할 수 없다. 내부 클래스와 중첩된 클래스 클래스 안에 다른 클래스를 선언할 수 있다. 클래스 안에 다른 클래스를 선언하면 도우미 클래스를 캡슐화하거나 코드 정의를 그 코드를 사용하는 곳 가까이에 두고 싶을 때 유용하다. 코틀린의 중첩 클래스는 명시적으로 요청하지 않는 한 바깥쪽 클래스 인스턴스에 대한 접근 권한이 없다. 책의 예제 참고 자바에서는 클래스 안에 정의한 클래스는 자동으로 내부 클래스가 된다. 따라서 내부의 클래스는 바깥 클래스에 대한 참조를 묵시적으로 포함한다. 그 참조로 인해 내부 클래스를 직렬화할 수 없다. 바깥 클래스를 직렬화할 수 없으므로 바깥 클래스에 대한 참조가 내부 클래스의 직렬화를 방해한다. 자바의 내부 클래스 특징 살펴보기 문제를 해결하기 위해서는 내부 클래스를 static으로 선언해야 한다. 중첩 클래스를 static으로 선언하면 그 클래스를 둘러싼 바깥쪽 클래스에 대한 묵시적인 참조가 사라진다. 코틀린에서 중첩된 클래스가 기본적으로 동작하는 방식은 위와 반대이다. 1234567class Button: View &#123; override fun getCurrentState(): State = ButtonState() override fun restoreState(state: State) &#123; .. &#125; class ButtonState: State &#123; .. &#125;&#125; 코틀린 중첩 클래스에 아무런 변경자가 붙지 않으면 자바 static 중첩 클래스와 같다.(즉, 바깥쪽 클래스에 대한 참조가 없다.) 이를 내부 클래스로 변경해서 바깥쪽 클래스에 대한 참조를 포함하게 만들기 위해서는 inner 변경자를 붙이면 된다. 클래스 B 안에 정의된 클래스 A 자바에서는 코틀린에서는 중첩 클래스(바깥쪽 클래스에 대한 참조를 저장하지 않음) static class A class A 내부 클래스(바깥쪽 클래스에 대한 참조를 저장함) class A inner class A 클래스 계층을 만들되 그 계층에 속한 클래스의 수를 제한하고 싶은 경우 중첩 클래스를 쓰면 편리하다. 봉인된 클래스 클래스 계층 정의 시 계층 확장 제한 아래에서는 상위 클래스인 Expr에 숫자를 표현하는 Num과 덧셈 연산을 표현하는 Sum이라는 두 하위 클래스가 존재한다. When 식에서 이 모든 하위 클래스를 처리하면 편리하지만, When 식에서 Num과 Sum이 아닌 경우를 처리하는 else 분기를 반드시 넣어야 한다.1234567891011interface Exprclass Num(val value: Int): Exprclass Sume(val left: Expr, val right: Expr): Expr fun eval(e: Expr) : Int = when(e)&#123; is Num -&gt; e.value is Sum -&gt; eval(e.right) + eval(e.left) else -&gt; throw IllegalArgumentException(\"Unknown expression\") &#125; 코틀린 컴파일러는 when을 사용해 Expr 타입의 값을 검사할 때 꼭 디폴트 분기인 else 분기를 덧붙이게 강제한다. 위의 코드는 else 분기에서 반환할 만한 의미 있는 값이 없으므로 예외를 던진다. 항상 디폴트 분기를 추가하는게 편하지 않다. 그리고 디폴트 분기가 있으면 클래스 계층에 새로운 하위 클래스를 추가하더라도 컴파일러가 when이 모든 경우를 처리하는지 제대로 검사할 수 없다. 혹여나 실수로 새로운 클래스에 대한 처리를 잊어버리더라도 디폴트 분기가 선택되기 때문에 심각한 버그가 발생할 수 있다. 이런 문제에 대한 해답은 sealed 클래스다. 상위 클래스에 sealed 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다. sealed 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스 안에 중첩시켜야 한다. 12345678910sealed class Expr&#123; class Num(val value: Int): Expr() class Sume(val left: Expr, val right: Expr): Expr()&#125; fun eval(e: Expr) : Int = when(e) &#123; is Expr.Num -&gt; e.value is Expr.Sum -&gt; eval(e.right) + eval(e.left) &#125; when 식이 sealed 클래스의 모든 하위 클래스를 검사하므로 별도의 디폴트(else) 분기가 없어도 된다. sealed 클래스는 자동으로 open이 되어 상속 가능하다. 외부에 자신을 상속한 클래스를 둘 수 없다. sealed 클래스에 속한 값에 대해 디폴트 분기를 사용하지 않고 when 식을 사용하면 나중에 sealed 클래스의 상속 계층에 새로운 하위 클래스를 추가해도 when 식이 컴파일되지 않는다. 따라서 when 식을 고쳐야 한다. 내부적으로 Expr 클래스는 private한 생성자를 가진다. 그 생성자는 클래스 내부에서만 호출할 수 있다. sealed 인터페이스를 정의할 수는 없다. 왜그럴까? 봉인된 인터페이스를 만들 수 있다면 그 인터페이스를 자바 쪽에서 구현하지 못하게 막을 수 있는 수단이 코틀린 컴파일러에게 없기 때문이다. 코틀린 1.1부터는 sealed 클래스와 같은 파일의 아무데서나 상위 클래스를 상속한 하위 클래스를 만들 수 있고, 데이터 클래스로 하위 클래스를 정의할 수도 있다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"}]},{"title":"[Kotlin] 문자열과 정규식 다루기","slug":"Chap3-2","date":"2019-10-03T15:59:40.000Z","updated":"2019-10-04T06:34:26.272Z","comments":true,"path":"2019/10/04/Chap3-2/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/04/Chap3-2/","excerpt":"","text":"해당 포스팅은 코틀린 인 액션 책을 보며 정리한 내용입니다. 주관적인 생각이 포함되어 있으니 다른 의견이 있으시다면 적극적으로 알려주시면 감사합니다. 문자열과 정규식 다루기 다양한 확장 함수를 제공함으로써 표준 자바 문자열을 더 잘 다룰 수 있게 해준다. 1. 문자열 나누기 코틀린에서는 자바의 split 대신에 여러 가지 다른 조합의 파라미터를 받는 split 확장 함수를 제공한다. 이는 정규식을 파라미터로 받는 함수는 String이 아닌 Regex 타입의 값을 받는다. 아래는 마침표나 대시로 문자열을 분리하는 예이다.12345678println(\"12.345-6.A\".split(\"\\\\.|-\".toRegex()))// toRegex()를 통해 명시적으로 정규식을 만든다.// 결과 : [12, 345, 6, A]println(\"12.345-6.A\".split(\".\",\"-\"))// 간단한 정규식일 경우, 구분 문자열을 하나 이상 인자로 받는 오버로딩된 함수를 호출하면 된다.// 결과 : [12, 345, 6, A] 코드 다듬기 로컬 함수와 확장 코틀린에서는 함수에서 추출한 함수를 원 함수 내부에 중첩시킬 수 있다. 그렇게 하면 문법적인 비용을 들이지 않고도 깔끔하게 코드를 조직할 수 있다. 중복 코드를 로컬 함수를 통해 제거할 수 있다. 중복되는 부분을 함수로 작성하고 함수 내에서 중첩시켜서 로컬 함수로 만든다. 이를 통해 중복 부분을 제거할 수 있다. 하지만, 중첩된 함수의 깊이가 깊어지면 코드를 읽기 어려워진다. 따라서 일반적으로 한 단계만 함수를 중첩시킨다. 요약 자체 컬렉션 클래스를 정의하지 않지만, 자바 클래스를 확장해서 더 풍부한 API를 제공한다. 함수 파라미터의 디폴트 값을 정의하면 오버로딩한 함수를 정의하지 않아도 된다. 이름 붙인 인자를 사용해 함수 호출 시의 가독성을 높일 수 있다. 코틀린은 클래스 멤버가 아니라 최상위 함수와 프로퍼티를 직접 선언할 수 있다. 이를 활용해 코드 구조를 더 유연하게 만들 수 있다. 확장 함수와 프로퍼티를 사용하면 외부 라이브러리에 정의된 클래스를 포함해 모든 클래스의 API를 그 클래스의 소스 코드를 바꿀 필요 없이 확장할 수 있다. 확장 함수를 사용해도 실행 시점에 부가 비용이 들지 않는다. 중위 호출을 통해 인자가 하나 밖에 없는 메소드나 확장 함수를 더 깔끔한 구문으로 호출할 수 있다. 정규식과 일반 문자열을 처리할 때 다양한 문자열 처리함수를 제공한다. 3중 따옴표 문자열을 사용하면 이스케이프와 같은 처리를 깔끔하게 할 수 있다. 로컬 함수를 사용해 코드를 더 깔끔하게 유지하면서 중복을 제거할 수 있다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"}]},{"title":"[Kotlin] 함수 정의와 호출","slug":"Chap3-1","date":"2019-09-29T13:08:18.000Z","updated":"2019-10-04T05:35:19.373Z","comments":true,"path":"2019/09/29/Chap3-1/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/29/Chap3-1/","excerpt":"","text":"해당 포스팅은 코틀린 인 액션 책을 보며 정리한 내용입니다. 주관적인 생각이 포함되어 있으니 다른 의견이 있으시다면 적극적으로 알려주시면 감사합니다. 코틀린에서 컬렉션코틀린는 자체 컬렉션을 제공하지 않는다. 대신에 기존 자바의 컬렉션을 활용할 수 있다. 이는 자바 코드와 상호작용하기가 훨씬 쉽다는 것을 의미한다. 자바에서 코틀린 함수를 호출하거나 코틀린에서 자바 함수를 호출할 때 자바와 코틀린을 서로 변환할 필요가 없다. 하지만, 코틀린에서는 좀 더 다양한 기능을 제공하기도 한다. 예를 들면, 리스트에서 가장 마지막 원소를 가져오거나 수로 이뤄진 컬렉션에서 최대값을 찾을 수 있다. 이름 붙인 인자 매개변수가 많은 함수를 호출할 때, 내가 전달하는 인자가 어떤 역할을 하는지 확인하기 어려운 경우가 많다. 우리가 함수의 시그니처를 외우거나 IDE가 함수 시그니처를 표시해서 도움을 줄 수 있겠지만, 함수 호출 코드 자체는 여전히 모호하다. 코틀린에서는 이러한 문제를 해결하기 위해서 작성한 함수를 호출할 때는 함수에 전달하는 인자 중 일부(또는 전부)의 이름을 명시할 수 있다. 일반적으로 인자 중 어느 하나라도 이름을 명시하고 나면 혼동을 줄이기 위해 나머지 인자도 모두 이름을 붙여주는 것이 좋다. 1joinToString(collection, separator = \" \", prefix = \" \", postfix = \" \") 디폴트 파라미터 값 자바에서는 일부 클래스에서 오버로딩한 메소드가 많아진다는 문제가 있다. 오버로딩을 통해 편의를 줄 수 있지만, 많아진다면 결국 중복이라는 결과를 얻게 된다. 코틀린에서는 함수 선언에서 디폴트 파라미터 값을 지정할 수 있으므로 오버로드 중 상당수를 피할 수 있다. 함수를 선언하는 곳에서 지정된다. 위에서 함수 호출만 작성했던 joinToString() 함수를 작성해보자. 아무 접두사나 접미사 없이 콤마로 원소를 구분한다. 123456fun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String = \",\". prefix: String = \" \", postfix: String = \" \"): String 함수를 호출할 때, 모든 인자를 쓸 수도 있고 일부를 생략해서 쓸 수도 있다.12345678joinToString(list, \", \", \"\",\"\")// 결과 : 1, 2, 3joinToString(list)// 결과 : 1, 2, 3joinToString(list, \"; \")// 결과 : 1; 2; 3 이름 붙은 인자를 사용하면 인자 목록의 중간에 있는 인자를 생략하고 지정하고 싶은 인자를 이름을 붙여 순서와 상관없이 호출할 수 있다. 디폴트 값과 자바 자바에는 해당 개념이 없어서 코틀린 함수를 호출하는 경우에는 그 코틀린 함수가 디폴트 파라미터 값을 제공하더라도 모든 인자를 명시해야 한다. 그래서 자바에서 코틀린 함수를 자주 호출해야 한다면, 편하게 호출할 수 있는 방법에 대해 생각해봐야 한다. @JvmOverloads 어노테이션을 함수에 추가하면 코틀린 컴파일러가 자동으로 맨 마지막 파라미터부터 하나씩 생략한 오버로딩한 메소드를 추가해주어 자바에서 디폴트 파라미터를 사용하는 코틀린 함수를 쉽게 호출할 수 있다. 정적인 유틸리티 클래스 없애기 : 최상위 함수와 프로퍼티 코틀린에서는 함수가 클래스 안에 없어도 된다. 다양한 정적 메소드를 모아두며 특별한 상태나 인스턴스 메소드는 없는 클래스가 생겨난다. JDK의 Collections 클래스가 전형적인 예이다. 코틀린에서는 무의미한 클래스가 필요없다. 대신 함수를 직접 소스 파일의 최상위 수준, 모든 다른 클래스의 밖에 위치시키면 된다. 최상위 함수를 선언해보자. 아래와 같이 join.kt 파일을 만들어보자.1234package stringsfun joinToString()&#123; // 생략.&#125; 이 함수가 어떻게 실행될까? JVM이 클래스 안에 들어있는 코드만을 실행할 수 있기 때문에 컴파일러는 이 파일을 컴파일할 때 새로운 클래스를 정의해준다. 그러면 자바 등의 다른 JVM 언어에서 호출하고 싶다면 코드가 어떻게 컴파일되는지 알아야 joinToString과 같은 최상위 함수를 사용할 수 있다. 코틀린이 join.kt를 컴파일하는지 보여주기 위해 join.kt를 컴파일한 결과와 같은 클래스를 자바 코드로 써보면 다음과 같다. 123456package strings;public class JoinKt&#123; public static String joinToString()&#123; // 생략. &#125;&#125; 코틀린 컴파일러가 생성하는 클래스의 이름은 최상위 함수가 들어있던 코틀린 소스 파일의 이름과 대응한다. 코틀린 파일의 모든 최상위 함수는 이 클래스의 정적인 메소드(static)가 된다. 따라서 자바에서 joinToString()을 호출하기 쉽다.JoinKt.joinToString(list,&quot;, &quot;,&quot;&quot;,&quot;&quot;); 최상위 프로퍼티 함수와 마찬가지로 프로퍼티도 파일의 최상위 수준에 놓을 수 있다. 이런 프로퍼티의 값은 정적 필드에 저장된다. 최상위 프로퍼티를 활용해 코드에 상수를 추가할 수도 있다. const 키워드를 사용하면 프로퍼티를 public static final 즉, 상수로 선언할 수 있으며 이 필드로 컴파일하게 만들 수 있다.(단, 원시 타입과 String 타입의 프로퍼티만 const로 지정할 수 있다.)12345const val NUMBER = 10 public static final int NUMBER = 10; // 위의 두 문장은 같다. 확장 함수와 확장 프로퍼티 기존 코드와 코틀린 코드를 자연스럽게 통합하는 것은 어려운 목표다. 코틀린을 기존 자바 프로젝트에 통합하는 경우에는 코틀린으로 직접 변환할 수 없거나 미처 변환하지 않은 기존 자바 코드를 처리할 수 있어야 한다. 이런 기존 자바 API를 재작성하지 않고도 코틀린이 제공하는 여러 편리한 기능을 사용할 수 있다면 좋을 것이다. 바로 확장 함수 가 그런 역할을 해준다. 확장 함수는 어떤 클래스의 멤버 메소드인 것처럼 호출할 수 있지만, 그 클래스의 밖에 선언된 함수이다. fun String.lastChar(): Char = this.get(this.length - 1) 위의 함수는 문자열의 마지막 문자를 반환하는 함수이다. 확장 함수를 만드는 것은 간단하다. 추가하려는 함수 이름 앞에 그 함수가 확장할 클래스의 이름을 덧붙이면 된다. 클래스의 이름을 수신 객체 타입이라고 한다. 확장 함수가 호출되는 대상이 되는 값(객체) 수신 객체라 부른다. 위의 코드에서 String이 수신 객체 타입이고, this가 수신 객체이다. 수신 객체 타입 : 확장이 정의될 클래스 수신 객체 : 그 클래스에 속한 인스턴스 객체 12println(\"kotlin\".lastChar())// 호출 String이 어떤 언어로 작성되었는가는 중요하지 않다. 자바 클래스로 컴파일한 클래스 파일이 있는 한 그 클래스에 원하는 대로 확장을 추가할 수 있다. this를 생략할 수 있다. 1fun String.lastChar(): Char = get(length - 1) 확장 함수가 캡슐화를 깨지는 않는다. 클래스 안에서 정의한 메소드와 달리 확장 함수 안에서는 클래스 내부에서만 사용할 수 있는 private, protected 멤버를 사용할 수 없다. 호출하는 쪽에서는 확장 함수와 멤버 메소드를 구분할 수 없고, 호출하는 메소드가 확장 함수인지 멤버 메소드인지 여부가 중요하지 않다. 임포트와 확장 함수 확장 함수를 정의했다고 프로젝트의 모든 소스 코드에서 사용할 수 있는 건 아니다. 확장 함수를 사용하기 위해서 그 함수를 다른 클래스나 함수와 마찬가지로 임포트해야만 한다. 자바와 마찬가지로 임포트할 때 동일한 구문을 사용하면 된다. 개별 함수를 임포트할 수도 있으며, *를 사용한 임포트도 잘 작동한다. 그리고 as 키워드를 사용해 임포트한 클래스나 함수를 다른 이름으로 부를 수 있다.123import strings.lastCharimport strings.*import strings.lastChar as last 다른 여러 패키지에 이름이 같은 함수가 많은데 한 파일 안에서 그런 함수들을 함께 써야 하는 경우 이름을 바꿔서 임포트하면 편리하다. 일반적인 클래스나 함수라면 다른 방법도 있다. 해당 클래스나 함수를 부를 때 전체 이름을 쓰면 된다. 하지만, 확장 함수는 코틀린 문법상 반드시 짧은 이름을 써야 한다. 따라서 임포트시 이름을 바꾸는 방법이 확장 함수의 이름 충돌을 해결하는 좋은 방법이 된다. 자바에서 확장 함수 호출 내부적으로 확장 함수는 수신 객체를 첫 번째 인자로 받는 정적 메소드다. → 실행 시점 부가 비용이 들지 않는다. 자바에서 확장 함수를 사용하기 편리하다. 1char c = StringUtilKt.lastChar(\"Java\") 코틀린은 아래와 같다. 1val c = \"Java\".lastChar() 가변 인자 함수 인자의 개수가 달라질 수 있는 함수 정의 파라미터 앞에 vararg 변경자를 붙인다. 이미 배열에 들어있는 원소를 가변 길이 인자로 넘길 때도 코틀린과 자바 구문이 조금 다르다. 코틀린에서는 배열을 명시적으로 풀어서 배열의 각 원소가 인자로 전달되게 해야 한다. 기술적으로는 스프레드 연산자가 그런 작업을 해준다. 실제로 전달하려는 배열 앞에 *를 붙이면 된다.12345fun main(args: Array&lt;String&gt;)&#123; val list = listOf(\"args:\", *args) // 스프레드 연산자가 배열의 내용을 펼쳐준다. println(list)&#125; 값의 쌍 다루기 중위 호출과 구조 분해 선언 to는 중위 호출이라는 특별한 방식으로 to라는 일반 메소드를 호출한 것이다. 중위 호출 시에는 수신 객체와 유일한 메소드 인자 사이에 메소드 이름을 넣는다. (이때 객체, 메소드 이름, 유일한 인자 사이에는 공백이 들어가야 한다.) 아래의 두 호출은 동일하다. 12341.to(\"one\")// to 메소드를 일반적인 방식으로 호출함.1 to \"one\"// to 메소드를 중위 호출 방식으로 호출함. 인자가 하나뿐인 일반 메소드나 인자가 하나뿐인 확장 함수에 중위 호출을 사용할 수 있다. 함수(메소드)를 중위 호출에 사용하게 허용하고 싶으면 infix 변경자를 함수(메소드) 앞에 추가해야 한다. 이어지는 내용으로 to 함수는 Pair 인스턴스를 반환한다. 이는 코틀린 표준 라이브러리 클래스로 두 원소로 이루어진 쌍을 표현한다. Pair의 내용으로 두 변수를 즉시 초기화할 수 있다. 123456val (number, name) = 1 to \"Lee\"// 루프에서 구조 분해 선언 사용for ((index, element) in collection.withIndex())&#123; println(\"$index: $element\")&#125; 이와 같은 기능을 구조 분해 선언이라고 한다. 구조 분해 선언은 Pair나 Map 객체에서 key와 value를 분해해서 한 번에 변수를 담을 때 사용할 수 있다. 또한, 반복문과 같은 루프에서도 사용할 수 있다. to 함수는 타입과 관계 없이 임의의 순서쌍을 만들 수 있다. 즉, to의 수신 객체가 제네릭하다. listOf와 마찬가지로 mapOf에도 원하는 개수만큼 인자를 전달할 수 있지만, 각 인자가 키와 값으로 이뤄진 순서쌍이어야 한다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"}]},{"title":"[ETC] 함수와 메소드의 차이","slug":"Function-Method-Dif","date":"2019-09-29T09:42:09.000Z","updated":"2019-09-29T09:49:24.251Z","comments":true,"path":"2019/09/29/Function-Method-Dif/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/29/Function-Method-Dif/","excerpt":"","text":"개발을 하다보면 함수와 메소드라는 말을 자주 접하고 듣는다. 어찌보면 개발자에게 있어서 없어서는 안되는 것이기도 하다. 그런데 어떤 상황에서는 함수라고 하고 어떤 상황에서는 메소드라고 한다. 둘의 차이가 뭔지 궁금해서 해당 글을 포스팅해본다. 함수(Function) 특정 작업을 수행하는 코드 조각이다. 전역이던 지역이던 독립된 기능을 수행하는 단위다. 함수가 메소드를 포함하고 있다. 함수가 더 포괄적인 개념이다. 메소드(Method) 클래스, 구조체, 열거형에 포함되어 있는 함수를 메소드라고 부른다. 다른말로 클래스 함수라고도 한다. 예제12345678910111213// 함수fun printFunction()&#123; println(\"Fuction\")&#125;class Person&#123; val name: String = \"Victory\" // 메소드 fun printMethod()&#123; println(\"$name Method\") &#125;&#125;","categories":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/categories/ETC/"}],"tags":[{"name":"함수","slug":"함수","permalink":"http://victorywoolee/victorywoolee.github.io/tags/함수/"},{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/tags/ETC/"},{"name":"메소드","slug":"메소드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/메소드/"},{"name":"함수와 메소드 차이","slug":"함수와-메소드-차이","permalink":"http://victorywoolee/victorywoolee.github.io/tags/함수와-메소드-차이/"}]},{"title":"[Clean Code] 6장","slug":"CleanCode06","date":"2019-09-27T15:28:28.000Z","updated":"2019-09-29T09:40:00.689Z","comments":true,"path":"2019/09/28/CleanCode06/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/28/CleanCode06/","excerpt":"","text":"자료 추상화아래의 두 코드 차이를 살펴보자. 두 클래스 모두 2차원 점을 표현한다. 그런데 한 클래스는 구현을 외부로 노출하고 다른 클래스는 구현을 완전히 숨긴다. 구체적인 Point 클래스 1234public class Point&#123; public double x; public double y;&#125; 추상적인 Point 클래스 12345678public interface Point&#123; double getX(); double getY(); void setCartesian(double x, double y); double getR(); double getTheta(); void setPolar(double r, double theta);&#125; 추상적인 Point 클래스에서는 직교 좌표계를 사용하는지 극좌표계를 사용하는지 알 수 없다. 둘 다 아닐 수도 있다. 그럼에도 불구하고 인터페이스는 자료구조를 명백하게 표현한다. 사실, 자료 구조 이상을 표현한다. 클래스 메소드가 접근 정책을 강제한다. 또한, 좌표를 읽을 때는 각 값을 개별적으로 읽어야 한다. 하지만 좌표를 설정할 때는 두 값을 한꺼번에 설정해야 한다. 구체적인 Point 클래스는 직교좌표계를 사용하며 구현을 노출한다. 변수를 private으로 선언하더라도 각 값마다 조회, 설정 함수를 제공한다면 구현을 외부로 노출하는 셈이다. 변수 사이에 함수라는 계층을 넣는다고 구현이 감춰지지는 않는다. 구현을 감추기 위해서는 추상화가 필요하다. 그저 조회, 설정 함수로 변수를 다룬다고 클래스가 되지 않는다. 그보다는 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다. 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋다. 인터페이스나 조회,설정 함수만으로는 추상화가 이뤄지지 않는다. 개발자는 객체가 포함하는 자료를 표현할 수 있는 가장 좋은 방법을 심각하게 고민해야 한다. 아무 생각 없이 조회, 설정 함수를 추가하는 방법이 가장 나쁘다. 자료/객체 비대칭 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다. 자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다. 아래는 객체 지향적인 도형 클래스다. area()는 다형성 메소드다. 그러므로 새 도형을 추가해도 기존 함수에 아무런 영향을 미치지 않는다. 반면, 새 함수를 추가하고 싶다면 도형 클래스 전부를 고쳐야 한다. 12345678910111213141516171819202122232425262728public class Square implements Shape&#123; private Point topLeft; private double side; public double area()&#123; return side * side; &#125;&#125;public class Rectangle implements Shape&#123; private Point topLeft; private double height; private double width; public double area()&#123; return height * width; &#125;&#125;public class Circle implements Shape&#123; private Point center; private double radius; public final double PI = 3.14159; public double area()&#123; return PI * radius * radius; &#125;&#125; 자료 구조를 사용하는 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다. 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다. 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 상속 받는 클래스에서 모든 클래스를 고쳐야 한다. 디미터 법칙 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다. 객체는 자료를 숨기고 함수를 공개한다. 즉, 객체는 조회 함수로 내부 구조를 공개하면 안된다는 의미다. 그러면 내부 구조를 숨기지 않고 노출하는 셈이 된다. 좀 더 정확하게 표현해서 “클래스 C의 메소드 f는 다음과 같은 객체의 메소드만 호출해야 한다.“고 주장한다. 클래스 C f가 생성한 객체 f 인수로 넘어온 객체 C 인스턴스 변수에 저장된 객체 위 객체에서 허용된 메소드가 반환하는 객체의 메소드는 호출하면 안된다. 낮선 사람은 경계하고 친구랑만 놀라는 의미다. 기차 충돌 여러 객차가 한 줄로 이어진 기차처럼 보이는 코드이다. 일반적으로 조잡하다 여겨지는 방식이므로 피하는 편이 좋다. 흔히 아래와 같은 코드를 기차 충돌이라 부른다. 1final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath(); 위의 코드는 아래와 같이 나누는 편이 좋다. 123Options opts = ctxt.getOptions();File scratchDir = opts.getScratchDir();final String outputDir = scratchDir.getAbsolutePath(); 위의 코드에서는 함수 하나가 아는 지식이 굉장히 많다. 즉 함수가 많은 객체를 탐색할 줄 안다는 의미다. 위 코드가 디미터 법칙을 위반하는지 여부는 ctxt, Options, ScratchDir이 객체인지 아니면 자료 구조인지에 달렸다. 객체라면 내부 구조를 숨겨야 하므로 확실히 디미터 법칙을 위반한다. 반면, 자료구조라면 당연히 내부 구조를 노출하므로 디미터 법칙이 적용되지 않는다. 위 코드는 조회 함수를 사용해서 혼란을 일으킨다. 코드를 아래와 같이 구현했다면 디미터 법칙을 거론할 필요가 없어진다. 1final String outputDir = ctxt.options.scratchDir.absolutePath; 자료 구조는 무조건 함수 없이 공개 변수만 포함하고 객체는 비공개 변수와 공개 함수를 포함한다면 문제는 훨씬 간단하다. 하지만, 단순한 자료 구조에도 조회 함수와 설정 함수를 정의하라 요구하는 프레임워크와 표준이 존재한다. 잡종 구조 혼란으로 말미암아 절반은 객체, 절반은 자료 구조인 잡종 구조가 나온다. 이런 잡종 구조는 새로운 함수는 물론이고 새로운 자료 구조도 추가하기 어렵다. 단점만 모아놓았다. 그러므로 잡종 구조는 피하는 편이 좋다. 구조체 감추기 만약 위에서 사용했던 ctxt, options, scratchDir이 진짜 객체라면 앞의 예제처럼 줄줄이 사탕으로 엮어서는 안된다. 객체라면 내부 구조를 감춰야 하기 때문이다. 그렇다면 임시 디렉토리의 절대 경로는 어떻게 얻어야 좋을까? 다음 두 코드를 참고해보자.12ctxt.getAbsolutePathofScratchDirectoryOption();ctxt.getScratchDirectoryOption().getAbsolutePath(); 첫 번째 방법은 ctxt 객체에 공개해야 하는 메소드가 너무 많아진다. 두 번째 방법은 getScratchDirectoryOption()이 객체가 아니라 자료 구조를 반환한다고 가정한다. 어느 방법도 내키지 않는다. ctxt가 객체라면 뭔가를 하라고 말해야지 속을 드러내라고 말하면 안된다. 임시 디렉토리의 절대 경로는 왜 필요할까? 이유는 임시 파일을 생성하기 위한 목적이 있기 때문이다. 그렇다면 ctxt 객체에 임시 파일을 생성하라고 시키면 어떨까? 1BufferedOutputStream bos = ctxt.creteScratchFileStream(classFileName); 이는 객체에게 맡기기에 적당한 임무로 보인다. ctxt는 내부 구조를 드러내지 않으며, 모듈에서 해당 함수는 자신이 몰라야 하는 여러 객체를 탐색할 필요가 없다. 따라서 디미터 법칙을 위반하지 않는다.ㄴ 자료 전달 객체 자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다. 자료 전달 객체(Data Transfer Object, DTO)라고 한다. 데이터베이스와 통신하거나 소켓에서 받은 메시지의 구문을 분석할 때 유용하다. 흔히 DTO는 데이터베이스에 저장된 가공되지 않은 정보를 애플리케이션 코드에서 사용할 객체로 변환하는 일련의 단계에서 처음으로 사용하는 구조체다. 활성 레코드 DTO의 특수형 형태다. 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료 구조지만, 대게 save나 find와 같은 탐색 함수도 제공한다. 활성 레코드는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과다. 활성 레코드에 비즈니스 규칙 메소드를 추가하면 자료 구조도 아니고 객체도 아닌 잡종 구조가 나오기 때문에 이렇게 만드는 것은 바람직하지 않다. 활성 레코드는 자료 구조로 취급한다. 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체는 따로 생성한다. 결론 객체는 동작을 공개하고 자료를 숨긴다. 그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면, 기존 객체에 새 동작을 추가하기는 어렵다. 자료 구조는 별다른 동작 없이 자료를 노출한다. 그래서 기존 자료 구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다. 시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다. 다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다. 우수한 소프트웨어 개발자는 편견없이 이 사실을 이해해 직면한 문제에 최적인 해결책을 선택한다.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"객체와 자료구조","slug":"객체와-자료구조","permalink":"http://victorywoolee/victorywoolee.github.io/tags/객체와-자료구조/"}]},{"title":"[ETC] Freeze","slug":"Freeze","date":"2019-09-27T14:45:17.000Z","updated":"2019-09-27T15:04:40.602Z","comments":true,"path":"2019/09/27/Freeze/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/27/Freeze/","excerpt":"","text":"회사에서 들은 용어 중 Feture Freeze라는 말이 있다. 이 말을 들으면서 어떤 의미인지 알겠지만, 정확하게 정리가 안되서 간단하게 정리하고 넘어가려고 이 글을 작성한다. 해당 글은 필자의 생각을 바탕으로 작성한 글로 잘못된 내용이 포함되었을 수 있습니다. 의견이 있으면 댓글을 남겨주세요! Feature Freeze검색해보니까 한글로 된 자료는 거의 찾아보기 힘들다. Feature Freeze와 Code Freeze라는 용어가 있는데 필자가 생각하기에는 두 용어 거의 비슷한 것으로 보인다. 어떤 기능을 개발할 때, 브랜치를 나눠 작업을 한다. 이때, 브랜치를 Feature 단위로 나눈다고 한다. Feature가 하나의 작은 작업 단위라고 생각하면 될 것이다. 예를 들면, 로그인 기능을 개발한다고 하자. 간단하게 아래와 같은 작업이 필요할 것이다. 로그인 UI 작성 로그인 기능 구현 로그인 상태 판단 간단하게 생각나는 대로 적었을 때, 3개로 나눌 수도 있다. 더 쪼갤 수도 있고 2번과 3번을 합칠 수도 있다. 이때 작업 단위 하나 하나를 Feature라고 부른다. 그리고 로그인 기능이 이번에 배포에 포함된다고 해보자. 수요일이 정기 배포일이라고 한다면 배포에 포함될 기능들이 완료되어 feature 브랜치로 모여야 한다. 그리고 develop과 master에 merge가 되고 배포가 이루어져야 한다. 이 과정을 Feature Freeze 혹은 Code Freeze라고 한다. 배포를 하기 위해 진행했던 작업들(코드)이 합쳐지고 배포가 이루어지는 일련의 과정을 의미하는 것이다.","categories":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/categories/ETC/"}],"tags":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/tags/ETC/"},{"name":"Freeze","slug":"Freeze","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Freeze/"}]},{"title":"[Android] EditText","slug":"Android-EditText","date":"2019-09-27T14:24:29.000Z","updated":"2019-09-27T14:37:41.124Z","comments":true,"path":"2019/09/27/Android-EditText/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/27/Android-EditText/","excerpt":"","text":"EditTextAndroid에서 사용자 입력, 검색을 받기 위해서 EditText를 사용한다. 기본적으로는 키보드가 올라오면 엔터키 자리가 줄바꿈으로 되어있을 것이다. 하지만, 기획과 개발에서 요구하는 사항에 따라서 해당 엔터키가 특정 동작을 하길 원할 수도 있다. 나는 검색 관련 기능을 구현하면서 엔터키가 검색 버튼이며 검색 기능을 동작했으면 했다. 그래서 엔터키를 검색 아이콘으로 변경했다. xml과 코드 상에서 모두 변경 가능하며 아래는 xml에서 변경하는 방식이다. 1234567891011&lt;EditText android:id=\"@+id/search_query\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:background=\"@color/transparent\" android:imeOptions=\"actionSearch\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toStartOf=\"@id/btn_clear\" app:layout_constraintStart_toEndOf=\"@id/btn_back\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_goneMarginEnd=\"16dp\" /&gt; 그리고 엔터키가 검색 동작임을 확인해서 원하는 기능을 구현할 수 있다. 아래와 같이 리스너를 달아주어 어떤 이벤트인지와 입력되는 값을 캐치할 수 있다. 123456searchQuery.setOnEditorActionListener &#123; query, id, _ -&gt; if(EditorInfo.IME_ACTION_SEARCH == id)&#123; viewModel.searchDestination(query.text.toString()) &#125; true &#125; 리스너를 달아주고 들어오는 이벤트의 id가 위에서 설정했던 actionSearch와 같다면 viewModel의 쿼리를 날려 검색 결과를 보여주는 간단한 기능이다. 참고 imeOptions 종류","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"EditText","slug":"EditText","permalink":"http://victorywoolee/victorywoolee.github.io/tags/EditText/"}]},{"title":"[ETC] Super App","slug":"SuperApp","date":"2019-09-27T14:00:57.000Z","updated":"2019-09-27T14:23:05.724Z","comments":true,"path":"2019/09/27/SuperApp/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/27/SuperApp/","excerpt":"","text":"이 글은 슈퍼앱이라는 단어를 듣고 무엇인지 생각해보고 검색해서 어느 글을 참고해서 정리한 글입니다. 플랫폼의 시대는 저물고 있다.조금은 슬픈 이야기지만, 플랫폼의 시대는 저물고 있다. 2000년대와 2010년대 초반까지 가장 화두가 되는 키워드는 플랫폼이었다. ‘누가 세상에 없는 서비스를 만들어내는가?‘와 같은 여태까지 없던 새로움이 승부를 결정짓는 중요한 포인트였다. 페이스북, 유튜브, 위챗, 인스타그램 등과 같은 플랫폼은 각자의 장점을 가지고 오랜 기간동안 많은 사용자를 모았다. 이를 통해서 굉장한 가치를 쌓아나갔다. 하지만, 최근에는 많은 스타트업도 있고 이 중에서 플랫폼도 많이 늘어나고 있다. 그래서 포화상태에 이르렀다. 이 사이에서 새로움을 찾는 것은 힘들다. 말 그대로 플랫폼의 시대는 저물고 있으며, 이제는 기술력과 컨텐츠, 그리고 슈퍼앱의 시대가 오고 있다. PC? 이젠 모바일이지.2010년부터 빠르게 진행된 스마트폰 보급 덕분에 모바일 시장은 엄청난 속도로 성장했다. 그래서 모바일 개발자들도 많이 늘어났다. 어느 리서치의 결과에 따르면 모바일을 통한 소비가 2014년도를 기준으로 계속 성장하고 있음을 밝혔다. PC에서 모바일로 변화하게 된 가장 큰 원인은 접근성의 차이다. 스마트폰이 보편화됨에 따라 예전에는 PC 웹에서만 가능하던 일들이 이제는 손에 들려있는 핸드폰에서도 가능하게 되었기 때문이다. 정보 검색에서부터 자료 수집, 관련 자료 시청, 상품 주문, 결제까지 할 수 있게 되었다. 슈퍼앱?이제 슈퍼앱에 대해 이야기를 해보자. 검색을 하면 슈퍼앱이라는 단어가 위챗과 많은 연관이 있는 것으로 보인다. 그 이유는 위챗은 위챗 하나로 다른 앱들은 필요 없고 위챗에서 생활에 필요한 전반적인 서비스를 이용할 수 있게 만들기 위해 슈퍼앱으로 만들려는 목표를 가졌다고 한다. 스마트폰이 많이 활성화됨에 따라서 사람들의 일상 대부분은 스마트폰을 통해서 이루어진다. 음식 주문, 옷 결제, 연락, 약속 등등 대부분을 스마트폰으로 할 수 있다. 이런 편의를 제공하기 위한 앱들도 많다. 하지만, 앱이 너무 많아서 사용자들은 이런 저런 앱을 깔았다 지우기도 한다. 자주 사용하지 않는 앱의 경우 삭제할 가능성이 크다. 이와 같은 사용자의 불편함을 해소 할 수 있는 방안이 슈퍼앱인 것이다. 회사 생활을 하다보니 처음 들어보는 용어가 많다. 그리고 들어본 것 같지만 의미를 모르는 것도 많다. 이런 용어나 새로운 개념에 대해서도 정리하는 공간을 만들 것이다. 개발만 공부한다고 다가 아니라는 것을 느끼는 요즘이다.","categories":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/categories/ETC/"}],"tags":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/tags/ETC/"},{"name":"Super App","slug":"Super-App","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Super-App/"}]},{"title":"[Android] Two-Way Data Binding","slug":"Android-Two-Way-Binding","date":"2019-09-23T05:48:31.000Z","updated":"2019-09-27T13:59:35.700Z","comments":true,"path":"2019/09/23/Android-Two-Way-Binding/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/23/Android-Two-Way-Binding/","excerpt":"","text":"해당 글은 데이터 바인딩에 대한 사전 지식을 가지고 있으면 이해가 수월합니다. 위의 그림을 통해서 알 수 있듯이 View와 ViewModel이 데이터바인딩을 통해 느슨하게 연결되고 Model은 View가 아닌 ViewModel과 통신하게 된다. 원칙적으로 View는 ViewModel에게 일방적으로 작업을 던지고 ViewModel은 직접적으로 View를 알지 못하기 때문에 데이터바인딩을 통해서만 View가 갱신된다. 그래서 대부분의 상황에서 ViewModel의 변화로 인해 ViewModel -&gt; View 방향으로 전달되는 일방통행의 데이터바인딩이 만들어진다. 하지만, 그림에서도 볼 수 있듯이 반대의 경우도 가능하다. 2-way 데이터바인딩은 여기서 나오는 개념이며 양방향 데이터바인딩이라고도 한다. 이에 대해 알아보기 위해서 구글 공식 문서를 찾아봤지만, 생각보다 설명이 친절하지 않았다. 그래도 일단 공식 문서의 내용을 정리해보겠다. Google DeveloperTwo Way DataBinding은 다음과 같이 두 가지 방식으로 구현할 수 있다. ObservableField를 사용하는 방법 notifyPropertyChanged() 메소드를 사용하는 방법 1. @Bindable과 notifyPropertyChanged()를 사용하는 방법단방향 데이터바인딩을 사용해 xml의 속성에 값을 설정하고 해당 속성의 변경에 반응하도록 설정할 수 있다. 코드는 아래와 같다. 12345&lt;CheckBox android:id=\"@+id/rememberMeCheckBox\" android:checked=\"@&#123;viewmodel.rememberMe&#125;\" android:onCheckedChanged=\"@&#123;viewmodel.rememberMe&#125;\"/&gt; 체크 박스를 이용해서 처음 상태는 뷰모델의 rememberMe 상태로 초기화를 하고 변경되면 뷰모델의 rememberMe를 참조해서 속성의 변경에 반응하도록 설정할 수 있다. 양방향 데이터바인딩을 사용하면 위의 과정을 단축시킬 수 있다. 1234&lt;CheckBox android:id=\"@+id/rememberMeCheckBox\" android:checked=\"@=&#123;viewmodel.rememberMe&#125;\"/&gt; @={} 표기법은 = 표기법이 기존의 단방향 데이터바인딩과의 차이점이다. 그리고 이는 속성에 대한 데이터 변경사항을 수신하고 동시에 사용자 업데이트를 듣는다. 레이아웃에 있는 뒤쪽의 데이터의 변화에 반응하기 위해, 레이아웃 변수를 Observable 구현으로 만들 수 있다. 보통 BaseObservable()을 구현하고 코드에서 @Bindable 어노테이션을 사용한다. 12345678class User: BaseObservable()&#123; @get:Bindable var firstName: String = \"\" set(value) &#123; field = value notifyPropertyChanged(BR.firstName) &#125;&#125; 사용하려는 Class에서 BaseObservable을 상속받는다. firstName이라는 변수를 @get:Bindable 어노테이션을 이용해 바인딩을 통해서 값을 가져올 수 있도록 설정한다. 사용자 지정 set()을 사용해서 값을 할당하고 notifyPropertyChanged() 메소드를 통해서 데이터바인딩을 통해서 만들어진 파일에서 firstName이라는 변수가 변경되었다는 것을 알려서 갱신을 한다. 중요한 포인트는 set()할 때는 값을 할당하고 notifyPropertyChanged() 메소드를 통해서 변경되었다는 것을 알려주는 것이고, @get:Bindable 어노테이션을 통해서 접근이 가능하도록 연결 통로를 마련해줘야 한다. 2. ObservableField를 사용하는 방법 이 방법도 1번과 비슷한 방법이지만, 조금 다르다. @Bindable과 notifyPropertyChanged() 메소드를 사용하지 않는다. 대신에 사용하려는 프로퍼티를 ObservableField 타입으로 선언한다. 1234567891011class User: BaseObservable()&#123; var user: ObservableField&lt;String&gt; = ObservableField(\"\") fun getInformation(): String&#123; return user.get()!! &#125; fun setInformation(name: String)&#123; user.set(name) &#125;&#125; ObservableField를 이용할 때는 get() 메소드를 이용해서 프로퍼티의 값을 가져온다. 값을 할당할 때는 set() 메소드를 이용해서 프로퍼티에 값을 할당한다. 주의해야할 점은 ObservableField를 초기화할 때, 빈 생성자로 초기화를 하면 객체가 생성되지 않는다. 기본값을 넘겨주어 초기화를 진행해야 객체가 생성된다. ObservableField의 get() 메소드는 Nullable하기 때문에 주의해서 처리해야 한다. 형태와 값을 가져오고 할당하는 코드가 조금 다르지만 결국 같은 결과를 보여준다. 어떤 방법을 사용할지는 개발자의 몫이다. 조금 더 생각해보면 코드를 간단히 할 수도 있을 것 같다. 이 부분은 조금 더 생각해보기로 하자. ObservableField를 사용하는 경우, BaseObervable()을 상속받지 않고 프로퍼티를 선언만해서 사용하는 방법도 가능하다. 그리고 추가될 내용으로는 양방향 데이터바인딩에서 바인딩 어댑터를 사용하는 방법을 알아볼 예정이다. 참고 Google Developer Google Developer 안드로이드의 2-way 데이터바인딩","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Data Binding","slug":"Data-Binding","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Data-Binding/"},{"name":"Two way Binding","slug":"Two-way-Binding","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Two-way-Binding/"}]},{"title":"[Clean Code] 5장","slug":"CleanCode05","date":"2019-09-22T10:48:14.000Z","updated":"2019-09-22T12:21:28.153Z","comments":true,"path":"2019/09/22/CleanCode05/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/22/CleanCode05/","excerpt":"","text":"형식 맞추기와 관련된 내용입니다. 프로그래머라면 형식을 깔끔하게 맞춰 코드를 짜야한다. 코드 형식을 맞추기 위해 간단한 규칙을 정하고 그 규칙을 착실히 따라야 한다. 팀으로 일한다면 팀이 합의해 규칙을 정하고 모두가 그 규칙을 따라야 한다. 형식을 맞추는 목적 코드 형식을 중요하다. 이는 의사소통의 일환이다. 의사소통은 전문 개발자의 일차적인 의무다. 원활한 소통을 장려하는 코드 형식은 무엇일까? 생각해봐야 한다. 적절한 행 길이를 유지하라 코드의 길이가 길지 않게 유지하더라도 큰 규모의 시스템을 구축할 수 있다. 일반적으로 큰 파일보다는 작은 파일이 이해하기 쉽다. 신문 기사처럼 작성하라 이름은 간단하면서도 설명이 가능하게 짓는다. 이름만 보고도 올바른 모듈을 살펴보고 있는지 아닌지를 판단할 정도로 신경써서 짓는다. 소스 파일의 첫 부분은 고차원 개념과 알고리즘을 설명한다. 아래로 내려갈수록 의도를 세세하게 표현한다. 마지막에는 가장 저차원 함수와 세부 내역이 나온다. 개념은 빈 행으로 분리하라 거의 모든 코드는 왼쪽에서 오른쪽으로 그리고 위에서 아래로 읽힌다. 각 행은 수식이나 절을 나타내고 일련의 행 묶음은 완결된 생각 하나를 표현한다. 생각 사이는 빈 행을 넣어 분리해야 마땅하다. 빈 행은 새로운 개념을 시작하는 시각적 단서가 되면서 가독성을 높여준다. 세로 밀집도 바로 위의 줄바꿈이 개념을 분리한다면 세로 밀집도는 연관성을 의미한다. 즉, 서로 밀접한 코드 행은 세로 가까이 놓여야 한다는 뜻이다. 수직 거리 함수 연관 관계와 동작 방식을 이해하려고 어디에 있는지 찾고 기억하느라 시간과 노력을 소모하는 것은 낭비다. 서로 밀접한 개념은 세로로 가까위 둬야 한다. 물론 두 개념이 서로 다른 파일에 속한다면 규칙이 통하지 않는다. 하지만 타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 마땅하다. 이게 바로 protected 변수를 피해야 하는 이유 중 하나다. 같은 파일에 속할 정도로 밀접한 두 개념은 세로 거릴 연관성을 표현한다. 여기서 연관성이란 한 개념을 이해하는데 다른 개념이 중요한 정도다. 연관성이 깊은 두 개념이 멀리 떨어져 있으면 코드를 읽는 사람이 소스파일과 클래스를 여기저기 뒤지게 되어 혼란스러워진다. 변수 선언 변수는 사용하는 위치에 최대한 가까이 선언한다. 루프를 제어하는 변수는 흔히 루프 문 내에 선언한다. 드물게 다소 긴 함수에서 블록 상단이나 루프 직전에 변수를 선언하는 사례도 있다. 인스턴스 변수 클래스 맨 처음에 선언한다. 변수간에 세로로 거리를 두지 않는다. 위치가 어디가 되었던 간에 잘 알려진 위치에 인스턴스 변수를 모은다는 사실이 중요하다. 종속 함수 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까에 배치한다. 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다. 그러면 프로그램이 더 자연스럽게 읽힌다. 이를 통해 모듈 전체의 가독성이 높아진다. 개념적 유사성 친화도가 높을수록 코드를 가까이 배치한다. 친화도가 높은 요인은 여러가지다. 위의 경우처럼 종속함수가 한 예가 된다. 변수와 그 변수를 사용하는 함수도 된다. 또한, 비슷한 동작을 수행하는 일군의 함수가 그 예가 된다. 세로 순서 일반적으로 함수 호출 종속성은 아래 방향으로 유지한다. 다시 말해, 호출되는 함수를 호출하는 함수보다 아래에 배치한다. 그러면 소스 코드 모듈이 고차원에서 저차원으로 자연스럽게 내려간다. 중요한 개념을 표현할 때는 세세한 사항을 최대한 배제한다. 세세한 사항은 가장 마지막에 표현한다. 그러면 독자가 소스 파일에서 첫 함수 몇개만 읽어도 개념을 파악하기 쉬워진다. 가로 형식 맞추기 프로그래머는 명백하게 짧은 행을 선호한다. 짧은 행이 바람직하다. 120자 정도의 행 길이를 제한하는 것이 추천된다. 가로 공백과 밀집도 가로로는 공백을 사용해 밀접한 개념과 느슨한 개념을 표현한다. 1234public void max(int a, int b)&#123; int size = a; return size*2 + b;&#125; 할당 연산자를 강조하려고 앞뒤에 공백을 줬다. 이로 인해 두 가지 주요 요소가 확실히 나뉜다는 사실이 더욱 분명해진다. 반면, 함수 이름과 이어지는 괄호 사이에는 공백을 넣지 않았다. 함수와 인수는 서로 밀접하기 때문이다. 공백을 넣으면 한 개념이 아니라 별개로 보인다. 가로 정렬 별로 유용하지 못하다. 이를 통해서 코드가 엉뚱한 부분을 강조해 진짜 의도가 가려진다. 인수 목록이 많아 코드가 가로로 길어진다면 정렬이 필요한게 아니라 목록 길이가 길기 때문에 목록을 정리해야 한다. 즉, 클래스를 쪼개야 한다. 들여 쓰기 범위로 이뤄진 계층을 표현하기 위해 코드를 들여쓴다. 왼쪽으로 코들르 맞춰 코드가 속하는 범위를 시각적으로 표현한다. 들여쓰기가 없다면 코드의 가독성이 현저하게 떨어진다. 들여쓰기한 파일은 구조가 한눈에 들어온다. 변수, 생성자 함수, 접근자 함수, 메소드가 금방 보인다. 들여쓰기 무시하기 때로는 간단한 if문, while문, 짧은 함수에서 들여쓰기 규칙을 무시하고픈 유혹이 생긴다. 이런 유혹에 빠질 때마다 코드를 들여쓰기 해야 한다. 그로 인해 코드가 더 명확하게 눈에 들어온다. 가짜범위 때로는 빈 while문, for문을 접한다. 이럴 때는 빈 블록을 올바로 들여쓰고 괄호로 감싼다. 세미콜론은 새 행에다 제대로 들여써서 넣어준다. 팀 규칙 팀은 한 가지 규칙에 합의해야 한다. 그리고 모든 팀원은 그 규칙을 따라야 한다. 그래야 소프트웨어가 일관적인 스타일을 보인다. 그로 인해 팀원 중 한명이 다른 사람의 코드 부분을 수정하더라도 일관성을 가지고 있기 때문에 읽기도 수월하며 수정하기도 어렵지 않을 것이다. 개개인이 따로국밥처럼 맘대로 짜대는 코드는 피해야 한다. 좋은 소프트웨어 시스템은 읽기 쉬운 문서로 이뤄진다는 사시를 기억해야 한다. 스타일은 일관적이고 매끄러워야 한다. 한 소스 파일에서 봤던 형식이 다른 소스 파일에도 쓰이리라는 신뢰감을 독자에게 줘야 한다. 온갖 스타일을 뒤섞어 소스 코드를 필요 이상으로 복잡하게 만드는 실수는 반드시 피한다.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"주석","slug":"주석","permalink":"http://victorywoolee/victorywoolee.github.io/tags/주석/"}]},{"title":"[Android] ripple","slug":"Android-ripple","date":"2019-09-22T03:54:56.000Z","updated":"2019-09-22T04:31:57.650Z","comments":true,"path":"2019/09/22/Android-ripple/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/22/Android-ripple/","excerpt":"","text":"안드로이드에서는 리플 효과라는 것이 있다. 사용자가 앱의 버튼이나 특정한 위젯을 클릭했을 때, 물결처럼 퍼져나가는 효과를 말한다. 이는 사용자가 터치를 했다는 것을 명확하게 보여주기 때문에 사용자에게 터치했다는 좋은 경험을 제공할 수 있다. 그래서 대부분의 앱들이 이러한 효과를 제공하고 있다. 그럼 리플 효과를 어떻게 적용할 수 있는지에 대해서 이야기해보려고 한다. 리플 효과버튼을 만들려고할 때, 디자인을 보고 xml에서 색상과 radius, 텍스트만 설정해서 구성할 수 있다면 클라이언트단에서 처리하는 편이 낫다. 이로 인해 리소스를 절약하고 용량도 어느정도는 작게 만들수 있기 때문이다. 그래서 xml에서 selector를 이용해서 원하는 모양을 작성하고 적용을 하기 위해서 background 속성을 이용하면 이쁘게 적용할 수 있다. 그러면 여기서 리플 효과는 어떻게 적용할까?? appcompat-v7 라이브러리에서 선택 가능한 항목의 터치 피드백을 플랫폼 버전엥 맞춰 쉽게 표시할 수 있도록 ?attr/selectableItemBackground라는 속성을 제공하고 있다. 하지만, 배경에 이 속성을 적용할 경우 해당하는 뷰에 다른 색상이나 모양, 혹은 이미지를 배경으로 함께 지정할 수 없어 레이아웃을 원하는 대로 구성할 수 없다. 위에서 작성한 xml을 적용할 수 없다는 뜻이다. 이와 같은 문제를 해결하기 위해서 터치 피드백이 다른 뷰의 가장 앞에 표시되도록 하면 될 것이다. android:foreground 속성을 사용해 해결할 수 있다. 터치 피드백이 필요한 곳에 아래와 같이 추가해주면 된다. background로 모양이나 색상을 정하지 않더라도 이를 사용하면 추후에 모양이나 색상이 추가되었을 때, 다른 수정을 할 필요가 없다. 앞으로 아래와 같이 사용하면 될 것이다. 1android:foreground=\"?selectableItemBackground\"","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"ripple","slug":"ripple","permalink":"http://victorywoolee/victorywoolee.github.io/tags/ripple/"}]},{"title":"[Android] Gradle","slug":"Android-Gradle","date":"2019-09-21T06:39:20.000Z","updated":"2019-09-21T07:57:08.567Z","comments":true,"path":"2019/09/21/Android-Gradle/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/21/Android-Gradle/","excerpt":"","text":"Grdle이란? 빌드 배포 도구 안드로이드 스튜디오와 빌드 시스템은 서로 독립적이다. 안드로이드 스튜디오 : 코드의 편집을 담당 Gradle : 빌드 빌드 프로세스를 자동화하고 관리, 유연한 맞춤형 빌드 구성을 정의할 수 있다. 3가지의 Gradle 파일이 있다. 1. Gradle 설정 파일(settings.gradle) 로트 프로젝트 디렉토리에 존재한다. 어떤 모듈을 포함할지를 Gradle에 알려준다. 1include &apos;:app&apos; 2. 최상위 빌드 파일(build.gradle) 루트 프로젝트 디렉토리에 최상위 파일로 프로젝트의 모든 모듈에 적용되는 빌드 구성을 정의한다. 모든 모듈에 공통되는 Gradle 저장소와 의존성을 정의하기 위해 buildscript 블록을 사용한다. 123456789101112buildscript&#123; repositories&#123; // gradle이 종속성을 검색하거나 다운로드하는 데 사용하는 레포지토리를 구성 &#125; dependencies&#123; // gradle이 사용하는 종속성을 정의 &#125;&#125;allprojects&#123; // 타사 플러그인 또는 라이브러리와 같이 모든 모듈이 사용하는 레포지토리 및 종속성을 구성하는 곳&#125; 3. 모듈 수준 빌드 파일(build.gradle) 해당 파일이 위치하는 특정 모듈의 빌드 설정을 구성 최상위 파일을 재정의할 수 있다. 1234567891011121314151617181920212223242526272829303132333435apply plugin: &apos;com.android.application&apos;// top-level에 선언되어야 하며, 안드로이드 플러그인을 gradle에 적용한다.android&#123; // 안드로이드와 관련된 빌드 설정을 한다. defaultConfig&#123; // AndroidManifest.xml에서 사용하는 설정에 대해 동적인 옵션을 주고 싶을 때, 이 블록 내에서 포함시킨다. // 예를 들면, versionCode, versionName 등 &#125; buildTypes&#123; // debug, release와 같이 빌드 타입을 지정할 수 있다. // 이외에도 alpha, beta 등등 &#125; flavorDimensions &quot;api&quot; // product flavor에 대한 그룹 productFlavors&#123; // 버전을 맞춤 설정하여 다양한 코드 및 리소스를 사용할 수 있으며, 모든 앱 버전에 공통되는 부분을 공유하거나 재사용할 수 있다. // flavorDimensions을 생성하고 동기화 진행 // 자신이 빌드 및 실행하고자 하는 것으로 변경 가능하다. &#125; lintOptions&#123; // 특정 lint 옵션을 구성할 수 있다. &#125; testOptions&#123; // text를 어떻게 실행하는지 방법에 대한 옵션을 지정한다. &#125;&#125;dependencies&#123; // 종속성을 관리한다. // 라이브러리를 추가하기 위해 수동으로 검색 및 다운로드 하지 않고 사용 가능하다.&#125; build variants 단일 프로젝트에서 다양한 버전의 앱을 생성하기 위해 사용한다. 각 build variants는 빌드할 수 있는 다른 버전의 앱을 나타낸다. build type과 product flavor에 구성된 설정, 코드 및 리소스를 조합한 결과 proguard 빌드 프로세스 중에 클래스를 축소하고 난독화 처리하기 위해 사용한다. 불필요한 메소드를 제거하여 멀티덱스를 피할 수 있다. 난독화 : 특정 언어로 작성된 코드를 읽기 어렵게 만드는 작업 디컴파일시 난독화가 되어 코드를 읽기 어렵다. 멀티 덱스 : 안드로이드 앱을 구성하는 코드는 컴파일되어 덱스 파일로 만들어진다. 하나의 덱스파일은 최대 65536개의 메소드만 참조 가능하다. 이를 초과하면 여러 개의 덱스 파일이 생성된다. 멀티 덱스를 사용할 수도 있지만, 빌드 과정에서 앱 내의 파일을 여러 개의 덱스 파일로 나누어야 하므로 빌드 속도가 느려지고 APK의 용량이 커지다. APK와 App Bundle APK : Android Package App Bundle : Application Bundle 두 가지 모두 여러 개의 흩뿌려져 있는 코드들을 안드로이드 기반 기기에서 독립적으로 실행 가능하도록 묶음으로 만드는 역할을 한다. APK가 커지는 이유 멀티 스크린을 지원하기 위해 이미지와 같은 리소스들이 증가 다국어를 지원하는 앱인 경우 String 파일 증가 자주 사용되지 않는 기능들의 증가 안드로이드 App Bundle은 새로운 업로드 방법으로 앱의 크기를 줄일 수 있다.기존에는 Play Console에 APK을 업로드하여 배포를 진행했지만, 새로운 배포 방법은 서명된 App Bundle을 Play Console로 배포하면 사용자의 기기에 맞는 언어, 리소스, CPU 아키텍처에 맞는 부분만 빌드하여 생성하기 때문에 사용자가 다운로드 받는 APK 용량을 줄일 수 있다. App Bundle? App Bundle은 APK와 비슷하지만 모든 코드, 리소스, CPU 아키텍처와 메타 데이터를 압축한 Zip 파일이다. 그래서 Google Play는 App Bundle에서 사용자 기기에 필요한 코드와 리소스만을 선택해 빌드될 수 있는 것이다. App Bundle을 빌드하면 .aab 파일이 생성된다. 빌드된 aab 파일을 Play Store에 업로드하면 Play Console이 사용자 각각의 디바이스에 최적화된 APK를 빌드한다. Dynamic Delivery? 사용자 기기에 필요한 리소스만을 다운로드 가능하게 해준다. Android 5.0(SDK 21) 이상부터 사용할 수 있다. Split APK 매커니즘을 이용한다. 이는 분리된 APK를 하나의 앱으로 만들어주는 것으로 여러가지 기능을 분리하고 나중에 기능이 필요할 때 다운로드 받아 설치된다. 따라서 Dynamic Delivery로 Google Play는 각 기기의 맞는 리소스만 빌드를 하고 기기에 설치되도록 한 다음에 사용자가 특정 기능을 필요로 할 때, 부분적으로 다운 받아서 사용할 수 있게 해주기 때문에 앱 용량을 줄일 수 있다. Base APK : 모든 APK가 접근할 수 있는 코드와 리소스가 포함된 APK이다. 앱의 기본 기능을 제공하고 사용자가 앱 다운로드를 요청하면 가장 처음 다운로드 받는 APK. Configuration APK : 기기에 설치될 때, 각 기기에 최적화된 화면 밀도(dpi)나 CPU 아키텍처, 다국어, 리소스와 네이티브 라이브러리가 포함된 APK이다. Google Play에서 자동으로 생성해준다. Dynamic feature APK : 사용자가 기기에 처음 설치할 때 필요하지 않지만, 나중에 추가로 설치할 수 있는 코드와 리소스가 들어있는 APK. 즉, 필요에 따라 동적으로 APK를 설치하여 사용자에게 추가 기능을 제공할 수 있다. 기본적으로 Google Play는 Base APK와 Configuration APK를 설치한다.예를 들어, 과거에는 다국어와 화면 사이즈를 대응하는 앱인 경우 APK를 빌드하고 서명 후 Play Console에 배포했다. 하지만, 지금은 App Bundle을 Google Play에 업로드하면 Google Play는 App Bundle의 메타데이터와 리소스에서 영어, xxhdpi 리소스만 빌드하여 base+en+xxhdpi으로 조합된 APK를 만든다. 이로 인해 사용자는 더 작고 최적화된 설치 파일을 다운로드 받을 수 있다.","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Gradle","slug":"Gradle","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Gradle/"},{"name":"Build","slug":"Build","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Build/"}]},{"title":"[Git] Git Flow 전략","slug":"Git-Flow","date":"2019-09-21T05:34:12.000Z","updated":"2019-09-21T06:22:52.962Z","comments":true,"path":"2019/09/21/Git-Flow/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/21/Git-Flow/","excerpt":"","text":"협업을 하면서 프로젝트를 진행하다보면 서로 같은 부분을 건드려서 개발하는 경우가 있다. 그리고 서로 다른 부분을 작업해 하나의 프로젝트에 합치는 경우도 많다. 이렇게 개발자가 협업을 할 때, 소스 코드의 버전 관리를 하기 위해서 Git을 사용하는데 여기에는 여러 전략이 있다. Github Flow 전략 Git Flow 전략 여기서 알아볼 전략은 Git Flow 전략이다.간단하게 말하면 브랜치를 효율적으로 관리하는 전략을 말한다. master branch 배포되었거나 배포될 소스가 저장되는 브랜치 master 브랜치는 배포될 때마다 태그만 달아주는 형식으로 관리한다. 예를 들어, 제품 1.0.0, 제품 1.2.1 등의 배포 버전이 있으면 해당 버전에 태그를 달아서 언제든 원하는 버전의 소스를 받아볼 수 있게 하는 역할을 한다. develop branch 다음 배포를 위해서 개발을 진행하는 브랜치다. 여러 명의 개발자가 함께 공유하면서 개발을 진행하는 브랜치다. 프로젝트 관점에서 보면 결국 개발이 진행되는 곳은 develop 브랜치다. 개발자 각각이 개발해야 하는 기능은 개발하기 전에 각자 자신의 로컬에 브랜치를 따로 생성해 개발을 진행하고 로컬 브랜치에서 개발이 완료되면 완료된 소스를 develop 브랜치에 푸시하거나 PR을 보내서 내부적인 코드 리뷰 후 merge 하는 것을 통해 개발이 진행된다. 위의 두 브랜치는 remote repository에서 항상 유지되는 브랜치이며, main branch라고 한다. feature branch 각 개발자에 의해 기능 단위의 개발이 진행되는 브랜치다. 여러 명의 개발자와 함께 프로젝트를 진행할 때, 요구사항에 있는 여러 기능을 적절하게 분배해서 개발자들과 일을 나눈다고 해보자. develop으로부터 feature 브랜치를 생성한다. 그리고 로컬에 기능을 위해 생성한 브랜치는 feature/login 브랜치다. 개발이 진행되면서 feature 브랜치로 merge를 한다. 모든 기능이 완료된 feature 브랜치는 develop으로 다시 merge되거나 push 된다. 위의 경우처럼 feature 브랜치를 로컬이 아닌 원격에 만들어서 관리해도 된다. 즉, 하나의 layer를 더 만든다고 생각하면 된다. 이렇게 함으로써 브랜치를 더 유연하게 만들어서 개발을 하면 적은 인원이 효율적으로 개발을 할 수 있다고 생각한다. hotfix branch 배포 버전에 생긴 문제로 긴급한 트러블 슈팅이 필요할 때 개발이 진행되는 브랜치다. 배포 버전에 문제가 발생해서 긴급하게 해당 기능만 수정이 필요할 때, 사용하는 브랜치다 실제 배포된 master 브랜치가 있고 이후에 개발이 지속적으로 진행된 develop 브랜치가 있는 상황이라고 가정해보자. 이때 배포된 버전에서 버그가 발생하면 어떻게 해야할까? develop 브랜치는 이미 다음에 배포될 버전이 충분히 개발된 버전이라 건들면 안된다. 이때는 배포된 master 브랜치에서 새로운 hotfitx 브랜치를 따고 문제가 생긴 코드를 고쳐서 master 브랜치에 merge한다. 아무래도 이미 배포된 버전에서 문제가 생겼기 때문에 즉각적으로 수정이 필요하다. 따라서 master로 직접 merge된다. 또한, 실제 출시된 버전에서 생긴 문제는 develop 브랜치에도 적용해야 한다. 운영에서 발견된 심각한 문제기 때문이다. release branch 내부적으로 배포할 준비가 되었다고 생각되는 소스가 저장되는 브랜치다. QA로 넘길 소스라고 보면된다. 요구되는 기능들을 모두 개발하고 내부적으로 배포하기 전에 테스트를 거치는 소스가 저장되는 브랜치다. 만약 QA 중에 문제가 발생하면 버그 픽스를 진행하고 버그가 제거된 release 소스를 중간에 develop 브랜치에 적용해 추가 개발을 이어갈 수 있다. 하지만 추가 기능 개발을 위해서 다시 develop 브랜치로 가지는 않는다. 만약 develop으로 버그가 수정된 소스가 가고 기능 개발을 한다면 그 기능은 이번 release가 아닌 다음 release 브랜치에 적용될 것이다. 모든 준비를 마치고 배포 가능한 상태가 되면 master 브랜치로 병합시키고, 병합한 커밋에 릴리즈 번호 태그를 추가한다.","categories":[{"name":"Git","slug":"Git","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Git/"},{"name":"Git Flow","slug":"Git-Flow","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Git-Flow/"}]},{"title":"[Android] 해상도","slug":"Android-Pixels","date":"2019-09-19T11:48:06.000Z","updated":"2019-09-21T04:38:35.419Z","comments":true,"path":"2019/09/19/Android-Pixels/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/19/Android-Pixels/","excerpt":"","text":"DIP(Device Independent Pixels) or DP 안드로이드에서 사용하는 독립적인 단위 수치 어떤 해상도에서도 같은 크기를 보여주는 것이 목적 DPI(Dot Per Inch) 1인치(2.54cm)에 들어가는 픽셀의 수 안드로이드에서는 160dpi를 기본 값으로 한다. px(pixel) 스크린의 실제 픽셀 단위를 사용한다. 실제 크기나 밀도와 상관 없다. 변환식 px = dp * (dpi/160) dp = px * (160/dpi) 160dpi인 해상도에서 1dp = 1px이다. 밀도 분류 160dpi = mdpi -&gt; 160 * 1 = 1dp = 1px 240dpi = hdpi -&gt; 160 * 1.5 = 1dp = 1.5px 320dpi = xhdpi -&gt; 160 * 2 = 1dp = 2px 480dpi = xxhdpi -&gt; 160 * 3 = 1dp = 3px 640dpi = xxxhdpi -&gt; 160 * 4 = 1dp = 4px 위의 그림은 구글 공식 문서에 있다. 안드로이드의 리소스 우선순위를 확인할 수 있다.자신에게 맞는 dpi 폴더를 먼저 읽고 해당 리소스가 없다면 가장 큰 dpi 폴더에서부터 작은 폴더순으로 읽으며 리소스를 찾는다. 최소 너비 사용 가능한 화면 영역의 가장 짧은 치수 기준으로 분류한다. swdp -&gt; sw320dp, sw600dp sw600dp로 분류된 레이아웃은 화면의 사용 가능한 영역 중, 가로 또는 세로 중 짧은 치수를 기준으로 600dp가 넘는 경우에만 접근이 가능하도록 한다.","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"해상도","slug":"해상도","permalink":"http://victorywoolee/victorywoolee.github.io/tags/해상도/"}]},{"title":"[Android] DI - Dagger2","slug":"Android-DI","date":"2019-09-19T11:46:46.000Z","updated":"2019-09-21T05:33:53.856Z","comments":true,"path":"2019/09/19/Android-DI/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/19/Android-DI/","excerpt":"","text":"해당 글은 DI와 관련된 공부 및 정리 글이며 추후에 내용이 추가될 가능성이 있습니다. DI Dependency Inject이라고 하면 의존성 주입을 의미한다. 구성요소 간의 의존 관계를 소스 코드 내부가 아닌 외부 설정 파일 등을 통해 정의되게 하는 디자인 패턴이다. 크게 3가지 유형으로 나누어 볼 수 있다. 생성자 주입 Setter를 통한 주입 Interface를 통한 주입 직접 의존성을 주입하는 형태의 클래스를 작성해도 되지만, 프로젝트의 규모가 커진다면 번거로운 작업이 된다. 그래서 이를 라이브러리로 넘겨서 대신 처리하도록 구현할 수 있다. 그 중에서도 Dagger와 관련해서 내용을 정리해보았다. Dagger2 Dagger의 핵심 키워드는 아래 그림과 같다. Module 의존성을 제공하는 @Provides 메소드를 가진 클래스에 이용한다. 모든 @Provides 메소드는 @Module 클래스 안에 속해야 한다. Provides 어떻게 의존성을 구성하고 제공하는지 정의하는 메소드에 사용한다. Module과 Provides는 공급자의 역할을 한다. Inject 의존성이 필요한 클래스에서 의존성 주입을 요청한다. @Inject 어노테이션으로 주입을 요청하면 연결된 Component가 Module로부터 객체를 생성하여 넘겨준다. 소비자의 역할을 한다. Component 연결된 Module을 이용해 의존성 객체를 생성하고, Inject로 요청받은 인스턴스에 생성한 객체를 주입한다. 의존성을 요청받고 주입하는 Dagger의 주된 역할을 수행한다. Module과 Inject 사이의 다리 역할을 한다. 인터페이스에만 사용한다. Scope 생성된 객체의 Lifecycle 범위를 뜻한다. 안드로이드에서는 주로 PerActivity, PerFragment 등으로 화면의 생명주기와 맞추어 사용한다. Module에서는 이 Scope을 보고 객체를 관리한다. Subcomponent Component는 계층 관계를 만들 수 있다. Subcomponent는 Inner Class 방식의 하위계층 Component이다. Sub의 Sub도 가능하다. 이는 Dagger의 중요한 컨셉인 그래프를 형성한다. Inject로 주입을 요청받으면 Subcomponent에서 먼저 의존성을 검색하고 없으면 부모로 올라가면서 검색한다. Qualifier 동일한 유형이지만 다른 인스턴스를 가진 객체를 구별하는데 사용된다. 주로 타입만으로 의존성을 식별하기 어려운 경우에 사용한다. 예를 들어, String과 같은 범용적인 타입일 경우 중첩될 수 있어서 이때 사용하면 된다. Flow@Inject -&gt; Subcomponent -&gt; Module -&gt; Scope에 있으면 return. 없으면 생성Subcomponent module에서 맞는 타입을 못찾으면 상위 Component -&gt; Module -&gt; Scope에 있으면 return. 없으면 생성. @Component를 구성하는 모든 @Module 클래스 목록을 작성해야 한다.아래와 같은 그림처럼 나타난다. Component를 구성하는 모든 Module 클래스 목록을 작성한다. 이를 통해서 Component는 Module과 연결되었다. 의존성 주입이 필요한 곳에서 @Inject를 통해 요청이 들어오면 해당 컴포넌트는 연결된 모듈 중에서 의존성을 제공할 수 있는 모듈이 있는지 검색한다. 제공할 수 있는 모듈이 있으면 Module에서 정의했던 메소드를 통해서 객체를 제공하게 된다. 그리고 주의해야할 점은 @Inject가 필요한 곳을 Component에 정의해야 한다는 것이다. 예를 들어, MainActivity에서 의존성 주입이 필요하다면 다음과 같이 Component에 정의해야 한다. 1234@Component(modules = [CatModule::class, DogModule::class])interface AnimalComponent&#123; fun inject(mainActivity: MainActivity)&#125; Component 인터페이스를 만들고 후에 build를 하면 Dagger는 이 인터페이스를 구현한 클래스를 자동으로 생성해준다. 생성된 클래스는 @Component 인터페이스 앞에 Dagger를 붙인채로 생성된다. 추가될 내용꽤 많은 블로그를 참고해 내용을 작성했는데, 주로 한글로 작성된 자료를 참고했다. 그래서 아래에 명시한 영어로 된 자료들을 참고해서 내용을 다시 정리할 예정이다.또한, Subcomponent와 관련된 내용도 더 숙지해서 정리할 필요가 있다. 참고1 참고2","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"DI","slug":"DI","permalink":"http://victorywoolee/victorywoolee.github.io/tags/DI/"},{"name":"Dagger2","slug":"Dagger2","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Dagger2/"}]},{"title":"[Android] WindowBackground","slug":"Android-WindowBackground","date":"2019-09-19T10:47:44.000Z","updated":"2019-09-19T11:44:09.018Z","comments":true,"path":"2019/09/19/Android-WindowBackground/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/19/Android-WindowBackground/","excerpt":"","text":"아래의 글을 읽어보면 어떻게 drawing을 더 빠르게 하고, activity의 시작 시간을 단축시킬 수 있는지 알 수 있다. 이는 window background drawable과 관련이 있다. setContentView()를 통해 Activity에 View를 붙이면, 이 View는 activity의 window에 붙게 된다. 하지만, window는 setContentView()를 통해 붙인 뷰만 붙이는 것이 아니다. 가장 중요한 것 중 하나인 DecorView를 붙이게 된다. DecorView는 window의 background Drawable을 가지고 있는 View다. getWindows().setBackgroundDrawable()을 호출하는 것은 실제로 DecorView의 background를 변경하여 window의 background가 변경되는 것과 같은 효과를 낸다. 하지만 이같은 설정은 추후에 version 혹은 device에 따라 달라질 수 있다. 기본 android theme를 사용한다면 default background drawable이 activity에 설정되어있다. 기본적으로는 ColorDrawable이 설정되어있다. 보통의 앱에서는 이 ColorDrawable이 DecorView에 설정되어 있는게 문제가 안된다. 하지만, drawing performance에는 영향을 줄 수도 있다. 아래는 불투명 그림이 activity 전체에 설정되어 있는 경우다. 그림에서 window background가 보이지 않는 것을 확인할 수 있다. 전부 불투명한 그림을 담고 있는 ImageView로 덮여있기 때문이다. 이 앱은 44fps가 나온다. 더 빨리 그리게 하기 위해서는 background drawable을 제거해주면 된다. 그림이 불투명이며 화면 전체를 차지하기 때문에 background는 낭비일 뿐이다. background를 제거함으로써 더 나은 퍼포먼스를 얻을 수 있다. background를 제거한 버전에서는 51fps가 나온다. 만약 default window backgroun가 더 큰 용량의 drawable일 경우에는 그 차이가 더 확연하게 난다. window background를 없애는 것은 custom theme를 적용하면 간단하게 해결된다.res/values/theme.xml을 만들고 아래와 같이 정의하면 된다. 12345&lt;resources&gt; &lt;style name=\"Theme.NoBackground\" parent=\"android:Theme\"&gt; &lt;item name=\"android:windowBackground\"&gt;@null&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 위와 같은 theme을 activity나 application의 theme로 적용해주면 된다. 1android:theme=&quot;@style/Theme.NoBackground&quot; MapView나 WebView 같은 경우도 보통 activity를 꽉 채우며 불투명하기 때문에 이런 theme를 사용하는게 좋다. 이 방법은 Android UI toolkit이 가려진 drawable을 그리지 않을만큼 똑똑하지는 않기 때문이다. 보통 android application에서 이렇게 full screen 전부가 불투명한 경우가 많지 않기 때문에 이런 최적화를 framework 단에서 하지 않았다. 하지만 이것은 추후 구현에서 자동으로 그리지 않도록 최적화될 수 있다. 전체 바탕을 theme으로 설정함으로서 activity의 시작 시간을 단축시킬수 있는 것도 좋은 방법이다. 아래와 같은 상황이 적절한 예가 될 수 있다. 위와 같은 background가 onCreate에서 설정되거나 XML layout을 통해서 설정되었다면 activity의 시작은 처음에 검은 배경이 나온 후 해당 그림으로 바뀌는 방식으로 이루어질 것이다. 사용자는 이 background를 로드하는데 시간이 걸린다고 느낄 것이며, 깜빡이는 경험도 할 것이다. 이렇게 하는 대신 theme로 설정해서 custom backgrounㅇ를 깔아주면 activity의 시작시간도 단축할 수 있고, 이렇게 깜빡이는 느낌도 없앨 수 있다. 참고 [Android/안드로이드] Window Backgrounds &amp; UI Speed","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Window Background","slug":"Window-Background","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Window-Background/"}]},{"title":"[ETC] GNB","slug":"What-is-GNB","date":"2019-09-16T13:15:48.000Z","updated":"2019-09-16T13:18:43.413Z","comments":true,"path":"2019/09/16/What-is-GNB/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/16/What-is-GNB/","excerpt":"","text":"GNB란? Global Navigation Bar의 줄임말이다. 사이트 전체에 동일하게 적용되는 네비게이션 바를 의미한다. 즉, 어느 페이지에 들어가든 공통적으로 사용할 수 있는 메뉴를 뜻한다. 그래서 의존성을 줄이고 모듈로 만들어서 필요한 곳에 사용하도록 만든다. 최상위 메뉴로 보통 상단에 위치한다.","categories":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/categories/ETC/"}],"tags":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/tags/ETC/"},{"name":"GNV","slug":"GNV","permalink":"http://victorywoolee/victorywoolee.github.io/tags/GNV/"}]},{"title":"[ConstraintLayout] 속성","slug":"Android-ConstraintLayout","date":"2019-09-16T05:05:48.000Z","updated":"2019-09-19T10:47:22.737Z","comments":true,"path":"2019/09/16/Android-ConstraintLayout/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/16/Android-ConstraintLayout/","excerpt":"","text":"안드로이드에서 뷰를 짤 때 사용하는 레이아웃은 많다.그 중에서 Constraint Layout은 이해하기 어렵지 않으며기존의 레이아웃들보다 좋은 기능을 많이 제공하고 있어 자주 사용된다. 유용한 속성들을 알아보자. 가이드 라인 뷰를 배치하기 위해 뷰그룹 내에 설정할 수 있는 일종의 기준선이다. 장점은 실제로는 이 선이 보이지 않는다는 것이다. 어떻게 보면 가상의 선을 기준으로 뷰를 배치할 수 있어서 편리하다. orientation을 통해 가로/세로 방향을 적용할 수 있다. 위치를 정하는 방법은 두 가지다. 일반적인 dp, px과 같은 수치를 적용하는 것 퍼센트를 적용하는 것 1. 수치를 적용하는 것 layout_constraintGuide_begin : begin의 경우 레이아웃 내에서 세로 가이드라인이라면 왼쪽(start)에서부터 얼만큼 떨어져있는지, 가로 가이드라인이라면 위에서부터 얼만큼 떨어져있는지를 뜻한다. layout_constraintGuide_end : end는 이와 반대로 세로는 오른쪽(end)에서부터, 가로는 아래에서부터 얼만큼 떨어져있는지를 적용하면 된다. 2. 퍼센트를 적용하는 것 layout_constraintGuidePercent : 0.0 ~ 1.0까지 적용할 수 있으며, 이때는 무조건 왼쪽이나 위쪽에서 시작한다고 생각하면 된다. 레이아웃 내부로부터 왼쪽에서 40% 지점에 세로로 된 가이드라인을 적용하려면 아래와 같이 하면 된다. 123456&lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guide_line\" android:layout_width=\"1dp\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.4\" /&gt; start vs left의 차이Android는 레이아웃 방향을 우아하게 변환하여 오른쪽에서 왼쪽으로(RTL) UI를 사용하는 언어와 아랍어, 히브리어와 같은 읽기 방향을 지원하는 사용자 인터페이스를 구축할 수 있는 API를 제공한다. 이를 설정하기 위해서는 매니페스트 파일에서 android:supportRtl의 값을 true로 설정해주면 된다. 그러면 시스템은 앱을 RTL 레이아웃으로 표시할 수 있도록 RTL API를 활성화할 것이다. RTL 레이아웃으로 표시할 때 앱의 UI를 최적화해야 하는 경우, 아래와 같은 최적화가 있다.1. 첫 번째 방법 레이아웃에서 left, right 방향을 start, end로 변경해야 한다. ex) android:layout_marginLeft -&gt; android:layout_marginStart 2. 두 번째 방법 RTL 레이아웃을 완벽하게 최적화하기 위해 ldrtl 리소스를 사용해 완전히 별개의 레이아웃 파일을 제공할 수 있다. 드로잉 가능한 자원에 매우 적합하므로 읽는 방향에 해당하는 방향에 맞는 그래픽을 제공할 수 있다. ex) 기본 레이아웃 파일은 /res/layout/에 저장하고, RTL 최적화 레이아웃은 /res/layout-ldtrl에 저장할 수 있다. 즉, start와 end 속성은 RTL을 지원하는 레이아웃에 사용된다. RTL을 지원하는 레이아웃에서는 left와 right가 우리의 입장에서 반대로 동작하기 때문에 이보다는 start와 end가 더 맞는 개념이라고 생각한다. 그래서 이를 도입해서 혼란을 방지하고자 한 것으로 보인다. 체인 개념은 간단하다. 단일축(가로축, 세로축)에서 위젯들이 그룹처럼 동작할 수 있도록 해준다. 최소 2개의 위젯이 서로 연결되어 있으면 체인 기능을 사용할 수 있다. 체인의 머리 : 체인의 가장 왼쪽(가로축일 경우) 혹은 가장 위쪽(세로축일 경우)에 있는 위젯이 체인의 머리가 된다. 체인의 여백은 체인의 스타일에 따라 달라진다. 체인의 스타일 체인의 머리는 연결된 뷰들 중 왼쪽과 위쪽이 우선순위를 갖는다. 주의할 점은 체인을 사용할 위젯들은 모두 서로 연결되어 있어야 한다는 점이다. 그래야 체인 조건이 성립되며 원하는 체인을 걸 수 있다. 배리어 다국어 지원을 하는 앱을 개발할 때 사용하면 유용하게 쓸 수 있다. 예를 들어, 세로로 2개의 텍스트뷰가 있다. 이 둘은 가로로 길어진다. 그리고 이 둘의 길이가 다를 때 더 긴쪽의 텍스트뷰 오른쪽에 뷰를 배치하고 싶을 때 사용하면 된다. barrierDirection : 왼쪽, 오른쪽의 기준을 설정할 수 있다. constraint_referenced_id : 기준시킬 뷰들의 아이디를 나열한다. 즉, 어떤 뷰가 상황에 따라서 길어지고 이 옆에 어떤 뷰를 또 배치해야할 때 유용하게 사용할 수 있을 것 같다. 그 중 하나의 예가 다국어같은 상황이다. 한 단어라도 다른 언어를 사용하면 굉장히 길어질 수 있기 때문에 이 상황에서 사용하면 예방할 수 있다. 참고 Google Developer Google Developer","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Constraint Layout","slug":"Constraint-Layout","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Constraint-Layout/"}]},{"title":"[CleanCode] 4장","slug":"CleanCode04","date":"2019-09-15T09:45:54.000Z","updated":"2019-09-16T05:05:32.497Z","comments":true,"path":"2019/09/15/CleanCode04/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/15/CleanCode04/","excerpt":"","text":"이번에는 주석과 관련된 내용입니다.책에서는 코드와 관련해서 설명이 많이 나오지만, 코드를 모두 담기에는 어려워 일부분만 담았습니다.정확한 이해가 필요하시다면 책을 구매하는 것을 추천드립니다. 잘 달린 주석은 그 어떤 정보보다 유용하다. 경솔하고 근거 없는 주석은 코드를 이해하기 어렵게 만든다. 오래되고 조잡한 주석은 거짓과 잘못된 정보를 퍼뜨려 해악을 미친다. 부정확한 주석은 아예 없는 주석보다 훨씬 나쁘다. 주석은 나쁜 코드를 보완하지 못한다. 코드에 주석을 추가하는 이유는 코드 품질이 나쁘기 때문이다. 지저분하게 코드를 짰다면 주석을 다는게 아니라 코드를 정리해야 한다! 표현력이 풍부하고 깔끔하며 주석이 거의 없는 코드가 복잡하고 어수선하며 주석이 많이 달린 코드보다 훨씬 좋다. 코드로 의도를 표현하라! 코드로 의도를 표현하라! 주석으로 달려는 설명을 함수로 만들어 표현해도 충분하다. 12345// 직원에게 복지 혜택이 있는지 검사한다.if((employee.flags &amp;&amp; HOURLY_FALT) &amp;&amp; employee.age &gt; 65) if(employee.isEligibleForFullbenefis())// 위보다 아래 코드가 의도를 더 명확하게 표현한다. 좋은 주석 어떤 주석은 필요하거나 유익하다. 하지만 정말 좋은 주석은 주석을 달지 않을 방법을 찾아낸 주석이다. 법적인 주석 소스 파일 첫 머리에 들어가는 저작권 정보와 소유권 정보 정보를 제공하는 주석 기본적인 정보를 주석으로 제공하면 편리하다. 아래 주석은 추상 메소드가 반환할 값을 설명한다. 12protected abstract Responder responderInstance();// 테스트 중인 Responder 인스턴스를 반환한다. 하지만, 가능하다면 함수 이름에 정보를 담는 편이 더 좋다.예를 들어, 위 코드에서 함수 이름을 responderBeingTested로 바꾸면 주석이 필요없어진다. 의도를 설명하는 주석 때때로 주석은 구현을 이해학 도와주는 선을 넘어 결정에 깔린 의도까지 설명한다. 의미를 명료하게 밝히는 주석 때때로 모호한 인수나 반환값은 그 의미를 읽기 좋게 표현하면 이해하기 쉬워진다. 일반적으로는 인수나 반환값 자체를 명확하게 만드련 더 좋겠지만, 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속한다면 의미를 명료하게 밝히는 주석이 유용하다. 결과를 경고하는 주석 다른 프로그래머에게 결과를 경고할 목적으로 주석을 사용한다. 아래는 특정 테스트 케이스를 꺼야 하는 이유를 설명한다. 1234// 여유 시간이 충분하지 않다면 실행하지 마십시오.public void _testWithReallyBigFile()&#123; ...&#125; 요즘은 위의 방식보다는 @Ignore 속성을 이용해 테스트 케이스를 꺼버린다. 구체적인 설명은 @Ignore 속성에 문자열로 넣어준다. JUnit4가 나오기 전에는 메소드 이름 앞에 _ 기호를 붙이는 방법이 일반적인 관례였다. TODO 주석 앞으로 할 일을 //TODO 주석으로 남겨두면 편하다. 이를 통해 함수를 구현하지 않은 이유와 미래 모습을 설명할 수 있다. 12345// TODO 현재는 필요하지 않다.// 체크 아웃 모델을 도입하면 함수가 필요하다.public VersionInfo makeVersion()&#123; return null;&#125; TODO 주석은 프로그래머가 필요하다 여기지만 당장 구현하기 어려운 업무를 기술한다. 예를 들면, 더이상 필요 없는 기능을 삭제하라는 알림, 누군가에 문제를 봐달라는 요청 등이다. TODO로 떡칠한 코드는 바람직하지 않다. 중요성을 강조하는 주석 자칫 대수롭지 않다고 여겨질 뭔가의 중요성을 강조하기 위해서도 주석을 사용한다. 예를 들면 다음과 같은 경우다. 123String listItemContent = match.group(3).trim();// trim()은 중요하다. 이 함수는 문자열에서 시작 공백을 제거한다.// 문자열에 시작 공백이 있다면 다른 문자열로 인식되기 때문이다. 공개 API에서 Javadocs 설명이 잘 된 공개 API는 참으로 유용하고 만족스럽다. 표준 자바 라이브러리에서 사용한 Javadocs가 좋은 예다. Javadocs가 없다면 자바 프로그램을 짜기가 아주 어렵다. 나쁜 주석 대다수 주석이 이 범주에 속한다. 일반적으로 대다수 주석은 허술한 코드를 지탱하거나, 엉성한 코드를 변명하거나, 미숙한 결정을 합리화하는 등 프로그래머가 주절거리는 독백에서 크게 벗어나지 못한다. 주절거리는 주석 특별한 이유 없이 의무감으로 혹은 프로세스에서 하라고 하니까 마지못해 주석을 단다면 전적으로 시간낭비다. 주석을 달기로 결정했다면 충분한 시간을 들여서 최고의 주석을 달도록 노력한다. 주석이 이해가 안되어 다른 모듈까지 뒤져야 하는 주석을 독자와 제대로 소통하지 못하는 주석이다. 같은 이야기를 중복하는 주석 함수를 보고 의미를 해석할 수 있지만, 주석으로 함수에 대한 설명을 한다. 심지어 함수보다 의미를 잘 전달하지 못한다. 없는게 더 낫다. 즉, 주석이 더 많은 정보를 제공하지 못한다. 코드를 정당화하는 주석도 아니고, 의도나 근거를 설명하는 주석도 아니다. 코드보다 읽기가 쉽지도 않다. 오해할 여지가 있는 주석 때때로 의도는 좋았으나 프로그래머가 딱 맞을 정도로 엄밀하게는 주석을 달지 못하기도 한다. 의무적으로 다는 주석 모든 함수에 Javadocs를 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석기 그지없다. 이런 주석은 코드를 복잡하게 만들며, 거짓말을 퍼뜨리고 혼동과 무질서를 초래한다. 오히려 코드만 헷갈리게 만들며, 거짓말할 가능성을 높이며 잘못된 정보를 제공할 여지만 만든다. 이력을 기록하는 주석 예전에 사람들은 모듈을 편집할 때마다 모듈 첫머리에 주석을 추가한다. 그리하여 모듈 첫머리 주석은 지금까지 모듈에 가한 변경을 모두 기록하는 일종의 일지 혹은 로그가 된다. 이제는 그렇게 하지 않는다. 소스 코드 관리 시스템이 다양하기 때문이다. 완전히 제거하자. 있으나 마나 한 주석 너무 당연한 사실을 언급하며 새로운 정보를 제공하지 못하는 주석이 있다. 이는 제거해야 마땅하다. 무서운 잡음 때로는 Javadocs도 잡음이다. 함수나 변수로 표현할 수 있다면 주석을 달지 마라. 다음 코드를 살펴보자. 12// 전역 목록 &lt;smodule&gt;에 속하는 모듈이 우리가 속한 하위 시스템에 의존하는가?if(smodule.getDependSubsystems().contains(subSysMod.getSubSystem())) 위 코드에서 주석을 없애고 다시 표현하면 아래와 같다. 123ArrayLis moduleDependees = smoudle.getDependSubsystems();String ourSubSystem = subSysMod.getSubSystem();if(moduleDependees.contains(ourSubSystem)) 코드를 작성한 저자는 주석을 먼더 달고 주석에 맞춰 코드를 작성했는지도 모른다. 하지만 위와 같이 주석이 필요하지 않도록 코드를 개선하는 편이 낫다. 위치를 표시하는 주석 소스 파일에서 특정 위치를 표시하려 주석을 사용한다. 1// Actions //////////////// 위와 같은 배너 아래 특정 기능을 모아놓으면 유용한 경우도 있다. 하지만, 일반적으로 위와 같은 주석은 가독성만 낮추므로 제거해야 한다. 배너를 남용하면 흔한 잡음으로 여겨진다. 닫는 괄호에 다는 주석 닫는 괄호에 특수한 주석을 달기도 한다. 중첩이 심하고 장황한 함수라면 의미가 있을지도 모르지만 작고 캡슐화된 함수에는 잡음일 뿐이다. 그러므로 닫는 괄호에 주석을 달아야겠다는 생각이 든다면 대신에 함수를 줄이려 시도하자. 공로를 돌리거나 저자를 표시하는 주석 1/* Woo가 추가함 */ 소스 코드 관리 시스템(Git)은 누가 언제 무엇을 추가했는지 기억한다. 그래서 저자 이름으로 코드를 오염시킬 필요가 없다. 위와 같은 정보는 소스 코드 관리 시스템에 저장하는 편이 좋다. 주석으로 처리한 코드 주석으로 처리한 코드만큼 밉살스러운 관행도 드물다. 주석으로 처리된 코드는 다른 사람들이 지우기를 주저한다. 이유가 있어 남겨놓았으리라고, 중요하니까 지우면 안된다고 생각한다. 그래서 계속해서 쌓여만 간다. 안된다. 지우자! HTML 주석 HTML 주석은 혐오 그자체다. 주석을 읽기 쉬어야 하는 편집기/IDE에서조차 읽기가 어렵다. 전역 정보 주석을 달아야 한다면 근처에 있는 코드만 기술하라. 코드 일부에 주석을 달면서 시스템의 전반적인 정보를 기술하지 마라. 주석을 달 코드와 연관있는 주석을 달아야 한다. 너무 많은 정보 주석에 흥미로운 역사나 관련 없는 정보를 장황하게 늘어놓지 마라. 모호환 관계 주석과 주석이 설명하는 코드는 둘 사이 관계가 명백해야 한다. 이왕 공들여 주석을 달았다면 적어도 독자가 주석과 코드를 읽어보고 무슨 소린지 알아야 한다. 함수 헤더 짧은 함수는 긴 설명이 필요 없다. 짧고 한 가지만 수행하며 이름을 잘 붙은 함수가 주석으로 헤더를 추가한 함수보다 훨씬 좋다. 비공개 코드에서 Javadocs 공개 API는 Javadocs가 유용하지만 공개하지 않을 코드라면 Javadocs는 쓸모가 없다. 유용하지 않을 뿐만 아니라 Javadocs 주석이 요구하는 형식으로 인해 코드만 보기 싫고 산만해진다. 참고 Clean Code","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"주석","slug":"주석","permalink":"http://victorywoolee/victorywoolee.github.io/tags/주석/"}]},{"title":"[CleanCode] 3장","slug":"CleanCode03","date":"2019-09-15T04:20:20.000Z","updated":"2019-09-15T04:23:40.600Z","comments":true,"path":"2019/09/15/CleanCode03/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/15/CleanCode03/","excerpt":"","text":"해당 글은 Clean Code 책을 보면서 내용을 간단하게 정리한 글입니다.문제가 된다면 바로 삭제하도록 하겠습니다. 작게 만들어라! 함수를 만드는 첫째 규칙은 ‘작게’이다. 두번째 규칙은 ‘더 작게’이다. 함수가 하나의 이야기만을 표현하며 짧아야 한다. 블록과 들여쓰기 if문, else문, while문에 들어가는 블록은 한 줄이어야 한다는 의미이다. 대개 거기서 함수를 호출한다. 그러면 바깥을 감싸는 함수가 작아질 뿐 아니라, 블록 안에서 호출하는 함수 이름을 적절히 짓는다면, 코드를 이해하기도 쉬워진다. 즉, 중첩 구조가 생길만큼 함수가 커져서는 안된다는 뜻이다. 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안된다. 그래야 함수는 읽고 이해하기 쉬워진다. 한가지만 해라! 함수는 한 가지를 해야 한다. 그 한가지를 잘해야 한다. 그 한가지만을 해야 한다. 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다. 함수가 한 가지만 하는지 판단하는 방법이 있다. 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다. 함수당 추상화 수준은 하나로! 함수가 확실히 ‘한 가지’ 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다. 위에서 아래로 코드 읽기: 내려가기 규칙 코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다. 즉, 위에서 아애로 프로그램을 읽으면 추상화 수준이 한 번에 한 단계씩 낮아진다. 서술적인 이름을 사용하라! 워드는 “코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 된다.” 한 가지만 하는 함수에 좋은 이름을 붙인다면 이런 원칙을 달성함에 있어 성공했다. 함수가 작고 단순할수록 서술적인 이름을 고르기가 쉬워진다. 길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 길고 서술적인 이름이 서술적인 주석보다 좋다. 함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다. 그런 다음, 여러 단어를 사용해도 함수 기능을 잘 표현하는 이름을 선택한다. 이름을 붙일 때는 일관성이 있어야 한다. 함수 인수 함수에서 이상적인 인수 개수는 0개이다. 다음은 1개이고, 그 다음은 2개이다. 3개는 가능한 피하는 편이 좋다. 4개 이상은 특별한 이유가 필요하다. 인수는 개념을 이해하기 어렵게 만든다. 최선은 입력 인수가 없는 경우이며, 차선은 입력 인수가 1개뿐인 경우다. 많이 쓰는 단항 형식 함수에 인수 1개를 넘기는 이유는 가장 흔한 경우 두 가지이다. 1.하나는 인수에 질문을 던지는 경우다. boolean fileExists(“file”) 2.다른 하나는 인수를 뭔가로 변환해 결과를 반환하는 경우다. InputStream fileOpen(“file”) 명령과 조회를 분리하라. 다소 드물게 사용하지만, 아주 유용한 단항 함수 형식이 이벤트다. 이벤트 함수는 조심해서 사용한다. 이벤트라는 사실이 코드에 명확하게 드러나야 한다. 입력 인수를 변환하는 함수라면 변환 결과는 반환값으로 돌려준다. 플래그 인수 플래그 인수는 추하다. 함수로 부울 값을 넘기는 관례는 정말 끔찍하다. 왜냐면 함수가 한꺼번에 여러 가지를 처리한다고 알려주는 셈이기 때문이다. 플래그 인수를 사용해서 여러 가지 일을 처리하기 보다는 함수를 쪼개서 작은 일 하나를 함수로 처리하는 것이 낫다. 이항 함수 인수가 2인 함수는 인수가 1개인 함수보다 이해하기 어렵다. 예를 들어, writeField(name)는 writeField(outputStream, name)보다 이해하기 쉽다. 둘다 의미는 명백하지만 전자가 더 쉽게 읽히고 더 빨리 이해된다. 이항 함수가 무조건 나쁘다는 소리는 아니다. 프로그램을 짜다 보면 불가피한 경우도 생긴다. 하지만, 그만큼 위험이 따른다는 사실을 이해하고 가능하면 단항 함수로 바꾸도록 애써야 한다. 삼항 함수 인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다. 순서, 주춤, 무시로 야기되는 문제가 두 배 이상 늘어난다. 삼항 함수를 만들 때는 신중히 고려해야 한다. 인수 객체 인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어보자. 예를 들어, 다음 두 함수를 살펴보자. Circle makeCircle(double x, double y, double radius); Circle makeCircle(Point center, double radius); 위의 함수처럼 객체를 생성해 인수를 줄이는 방법이 눈속임이라 여겨질지 모르지만 그렇지 않다. 이전 예제에서 x와 y를 묶었듯이 변수를 묶어 넘기려면 이름을 붙여야 하므로 결국은 개념을 표혀하게 되는 것이다. 인수 목록 때로는 인수 개수가 가변적인 함수도 필요하다. String.format 메소드가 좋은 예다. String.format(“%s worke %.2f hours.”, name, hours); 위 예제처럼 가변 인수 전부를 동등하게 취급하면 List형 인수 하나로 취급할 수 있다. 이런 논리의 측면에서 String.format은 사실 이항 함수이다. 가변 인수를 취하는 모든 함수는 같은 원리가 적용된다. 가변 인수를 취하는 함수는 단항, 이항, 삼항 함수로 취급할 수 있다. 하지만 이를 넘어서는 인수를 사용할 경우 문제가 된다. void monad(Integer… args); void dyad(String name, Integer… args); 동사와 키워드 함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수다. 단항 함수는 함수와 인수가 동사, 명사 쌍을 이뤄야 한다. write(name) → 이름을 쓴다. writeField(name) → 이름이 필드. 위의 함수보다 더 명확해서 좋다. 함수 이름에 키워드를 추가해보자. assertEquals보다 assertExpectedEqualsActual(expected, actual)이 더 좋다. 그러면 순서를 기억하지 않아도 함수 이름으 보고 유추할 수 있다. 부수 효과를 일으키지 마라! 함수에서 한가지를 하겠다고 약속하고선 남몰래 다른 짓을 하면 안된다. 때로는 예상치 못하게 클래스 변수를 수정한다. 때로는 함수로 넘어온 인수나 시스템 전역 변수를 수정한다. 어느쪽이든 교활하고 해로운 거짓말이다. 많은 경우 시간적인 결합이나 순서 종속성을 초래한다. 시간적인 결합이 필요한 경우 함수 이름에 명시해야 한다. 출력 인수 일반적으로 출력 인수는 피해야 한다. 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 선택한다. 명령과 조회를 분리하라! 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다. 둘 다 하면 안된다. 객체 상태를 변경하거나 아니면 객체 정보를 반환하거나 둘 중 하나만 해야 한다. 둘 다 하게 된다면 의미가 모호해지기 때문이다. 그래서 명령과 조회를 분리해 혼란을 없애는 게 좋다. 오류 코드보다 예외를 사용하라! 명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다. 자칫하면 if문에서 명령을 표현식으로 사용하기 쉬운 탓이다. 오류 코드를 사용하게 되면 오류가 발생했을 때, 즉시 처리해야 한다. 그러면 if문이 중첩되어서 가독성이 떨어지게 된다. 이를 오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 깔끔해진다. Try/Catch 블록 뽑아내기 try/catch 블록은 원래 추하다. 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞는다. 그러므로 try/catch 블록을 별도의 함수로 뽑아내는 편이 좋다. 123456789101112131415161718public void delete(Page page)&#123; try&#123; deletePageAndAllReferences(page); &#125; catch(Exception e)&#123; logError(e); &#125;&#125;private void deletePageAndAllReferences(Page page) throws Exception&#123; deletePage(page); registry.deleteReference(page.name); configKeys.deleteKey(page.name.makeKey());&#125;private void logError(Exception e)&#123; logger.log(e.getMessage());&#125; 위에서 delete 함수는 모든 오류를 처리한다. 그래서 코드를 이해하기 쉽다.실제로 페이지를 제거하는 함수는 deletePageAndAllReferences() 함수이다.deletePageAndAllReferences 함수는 예외를 처리하지 않는다.이렇게 정상 동작과 오류 처리 동작을 분리하면 코드를 이해하고 수정하기 쉬워진다. 오류 처리도 한 가지 작업이다. 함수는 한 가지 작업만 해야 한다. 오류 처리도 한 가지 작업에 속한다. 그러므로 오류를 처리하는 함수는 오류만 처리해야 한다. 반복하지 마라! 중복은 문제다. 코드 길이가 늘어날 뿐 아니라 알고리즘이 변하면 네 곳이나 손을 봐야 한다. 중복을 없앴더니 모듈 가독성이 크게 높아졌다. 중복은 소프트웨어에서 모든 악의 근원이다. 객체 지향 프로그래밍은 코드를 부모 클래스로 올려서 중복을 없앤다.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"함수","slug":"함수","permalink":"http://victorywoolee/victorywoolee.github.io/tags/함수/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-13T03:13:02.479Z","updated":"2019-09-13T03:13:02.479Z","comments":true,"path":"2019/09/13/hello-world/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}