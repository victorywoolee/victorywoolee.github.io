{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://victorywoolee/victorywoolee.github.io","root":"/"},"pages":[],"posts":[{"title":"[ETC] GNB","slug":"What-is-GNB","date":"2019-09-16T13:15:48.000Z","updated":"2019-09-16T13:18:43.413Z","comments":true,"path":"2019/09/16/What-is-GNB/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/16/What-is-GNB/","excerpt":"","text":"GNB란? Global Navigation Bar의 줄임말이다. 사이트 전체에 동일하게 적용되는 네비게이션 바를 의미한다. 즉, 어느 페이지에 들어가든 공통적으로 사용할 수 있는 메뉴를 뜻한다. 그래서 의존성을 줄이고 모듈로 만들어서 필요한 곳에 사용하도록 만든다. 최상위 메뉴로 보통 상단에 위치한다.","categories":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/categories/ETC/"}],"tags":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/tags/ETC/"},{"name":"GNV","slug":"GNV","permalink":"http://victorywoolee/victorywoolee.github.io/tags/GNV/"}]},{"title":"[ConstraintLayout] 속성","slug":"Android-ConstraintLayout","date":"2019-09-16T05:05:48.000Z","updated":"2019-09-17T09:44:31.379Z","comments":true,"path":"2019/09/16/Android-ConstraintLayout/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/16/Android-ConstraintLayout/","excerpt":"","text":"안드로이드에서 뷰를 짤 때 사용하는 레이아웃은 많다.그 중에서 Constraint Layout은 이해하기 어렵지 않으며기존의 레이아웃들보다 좋은 기능을 많이 제공하고 있어 자주 사용된다. 유용한 속성들을 알아보자. 가이드 라인 뷰를 배치하기 위해 뷰그룹 내에 설정할 수 있는 일종의 기준선이다. orientation을 통해 가로/세로 방향을 적용할 수 있다. 위치를 정하는 방법은 두 가지다. 일반적인 dp, px과 같은 수치를 적용하는 것 퍼센트를 적용하는 것 1. 수치를 적용하는 것 layout_constraintGuide_begin : begin의 경우 레이아웃 내에서 세로 가이드라인이라면 왼쪽(start)에서부터 얼만큼 떨어져있는지, 가로 가이드라인이라면 위에서부터 얼만큼 떨어져있는지를 뜻한다. layout_constraintGuide_end : end는 이와 반대로 세로는 오른쪽(end)에서부터, 가로는 아래에서부터 얼만큼 떨어져있는지를 적용하면 된다. 2. 퍼센트를 적용하는 것 layout_constraintGuidePercent : 0.0 ~ 1.0까지 적용할 수 있으며, 이때는 무조건 왼쪽이나 위쪽에서 시작한다고 생각하면 된다. 레이아웃 내부로부터 왼쪽에서 40% 지점에 세로로 된 가이드라인을 적용하려면 아래와 같이 하면 된다. 123456&lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guide_line\" android:layout_width=\"1dp\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.4\" /&gt; start vs left의 차이Android는 레이아웃 방향을 우아하게 변환하여 오른쪽에서 왼쪽으로(RTL) UI를 사용하는 언어와 아랍어, 히브리어와 같은 읽기 방향을 지원하는 사용자 인터페이스를 구축할 수 있는 API를 제공한다. 이를 설정하기 위해서는 매니페스트 파일에서 android:supportRtl의 값을 true로 설정해주면 된다. 그러면 시스템은 앱을 RTL 레이아웃으로 표시할 수 있도록 RTL API를 활성화할 것이다. RTL 레이아웃으로 표시할 때 앱의 UI를 최적화해야 하는 경우, 아래와 같은 최적화가 있다.1. 첫 번째 방법 레이아웃에서 left, right 방향을 start, end로 변경해야 한다. ex) android:layout_marginLeft -&gt; android:layout_marginStart 2. 두 번째 방법 RTL 레이아웃을 완벽하게 최적화하기 위해 ldrtl 리소스를 사용해 완전히 별개의 레이아웃 파일을 제공할 수 있다. 드로잉 가능한 자원에 매우 적합하므로 읽는 방향에 해당하는 방향에 맞는 그래픽을 제공할 수 있다. ex) 기본 레이아웃 파일은 /res/layout/에 저장하고, RTL 최적화 레이아웃은 /res/layout-ldtrl에 저장할 수 있다. 즉, start와 end 속성은 RTL을 지원하는 레이아웃에 사용된다. RTL을 지원하는 레이아웃에서는 left와 right가 우리의 입장에서 반대로 동작하기 때문에 이보다는 start와 end가 더 맞는 개념이라고 생각한다. 그래서 이를 도입해서 혼란을 방지하고자 한 것으로 보인다. 참고 Google Developer","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Constraint Layout","slug":"Constraint-Layout","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Constraint-Layout/"}]},{"title":"[CleanCode] 4장","slug":"CleanCode04","date":"2019-09-15T09:45:54.000Z","updated":"2019-09-16T05:05:32.497Z","comments":true,"path":"2019/09/15/CleanCode04/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/15/CleanCode04/","excerpt":"","text":"이번에는 주석과 관련된 내용입니다.책에서는 코드와 관련해서 설명이 많이 나오지만, 코드를 모두 담기에는 어려워 일부분만 담았습니다.정확한 이해가 필요하시다면 책을 구매하는 것을 추천드립니다. 잘 달린 주석은 그 어떤 정보보다 유용하다. 경솔하고 근거 없는 주석은 코드를 이해하기 어렵게 만든다. 오래되고 조잡한 주석은 거짓과 잘못된 정보를 퍼뜨려 해악을 미친다. 부정확한 주석은 아예 없는 주석보다 훨씬 나쁘다. 주석은 나쁜 코드를 보완하지 못한다. 코드에 주석을 추가하는 이유는 코드 품질이 나쁘기 때문이다. 지저분하게 코드를 짰다면 주석을 다는게 아니라 코드를 정리해야 한다! 표현력이 풍부하고 깔끔하며 주석이 거의 없는 코드가 복잡하고 어수선하며 주석이 많이 달린 코드보다 훨씬 좋다. 코드로 의도를 표현하라! 코드로 의도를 표현하라! 주석으로 달려는 설명을 함수로 만들어 표현해도 충분하다. 12345// 직원에게 복지 혜택이 있는지 검사한다.if((employee.flags &amp;&amp; HOURLY_FALT) &amp;&amp; employee.age &gt; 65) if(employee.isEligibleForFullbenefis())// 위보다 아래 코드가 의도를 더 명확하게 표현한다. 좋은 주석 어떤 주석은 필요하거나 유익하다. 하지만 정말 좋은 주석은 주석을 달지 않을 방법을 찾아낸 주석이다. 법적인 주석 소스 파일 첫 머리에 들어가는 저작권 정보와 소유권 정보 정보를 제공하는 주석 기본적인 정보를 주석으로 제공하면 편리하다. 아래 주석은 추상 메소드가 반환할 값을 설명한다. 12protected abstract Responder responderInstance();// 테스트 중인 Responder 인스턴스를 반환한다. 하지만, 가능하다면 함수 이름에 정보를 담는 편이 더 좋다.예를 들어, 위 코드에서 함수 이름을 responderBeingTested로 바꾸면 주석이 필요없어진다. 의도를 설명하는 주석 때때로 주석은 구현을 이해학 도와주는 선을 넘어 결정에 깔린 의도까지 설명한다. 의미를 명료하게 밝히는 주석 때때로 모호한 인수나 반환값은 그 의미를 읽기 좋게 표현하면 이해하기 쉬워진다. 일반적으로는 인수나 반환값 자체를 명확하게 만드련 더 좋겠지만, 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속한다면 의미를 명료하게 밝히는 주석이 유용하다. 결과를 경고하는 주석 다른 프로그래머에게 결과를 경고할 목적으로 주석을 사용한다. 아래는 특정 테스트 케이스를 꺼야 하는 이유를 설명한다. 1234// 여유 시간이 충분하지 않다면 실행하지 마십시오.public void _testWithReallyBigFile()&#123; ...&#125; 요즘은 위의 방식보다는 @Ignore 속성을 이용해 테스트 케이스를 꺼버린다. 구체적인 설명은 @Ignore 속성에 문자열로 넣어준다. JUnit4가 나오기 전에는 메소드 이름 앞에 _ 기호를 붙이는 방법이 일반적인 관례였다. TODO 주석 앞으로 할 일을 //TODO 주석으로 남겨두면 편하다. 이를 통해 함수를 구현하지 않은 이유와 미래 모습을 설명할 수 있다. 12345// TODO 현재는 필요하지 않다.// 체크 아웃 모델을 도입하면 함수가 필요하다.public VersionInfo makeVersion()&#123; return null;&#125; TODO 주석은 프로그래머가 필요하다 여기지만 당장 구현하기 어려운 업무를 기술한다. 예를 들면, 더이상 필요 없는 기능을 삭제하라는 알림, 누군가에 문제를 봐달라는 요청 등이다. TODO로 떡칠한 코드는 바람직하지 않다. 중요성을 강조하는 주석 자칫 대수롭지 않다고 여겨질 뭔가의 중요성을 강조하기 위해서도 주석을 사용한다. 예를 들면 다음과 같은 경우다. 123String listItemContent = match.group(3).trim();// trim()은 중요하다. 이 함수는 문자열에서 시작 공백을 제거한다.// 문자열에 시작 공백이 있다면 다른 문자열로 인식되기 때문이다. 공개 API에서 Javadocs 설명이 잘 된 공개 API는 참으로 유용하고 만족스럽다. 표준 자바 라이브러리에서 사용한 Javadocs가 좋은 예다. Javadocs가 없다면 자바 프로그램을 짜기가 아주 어렵다. 나쁜 주석 대다수 주석이 이 범주에 속한다. 일반적으로 대다수 주석은 허술한 코드를 지탱하거나, 엉성한 코드를 변명하거나, 미숙한 결정을 합리화하는 등 프로그래머가 주절거리는 독백에서 크게 벗어나지 못한다. 주절거리는 주석 특별한 이유 없이 의무감으로 혹은 프로세스에서 하라고 하니까 마지못해 주석을 단다면 전적으로 시간낭비다. 주석을 달기로 결정했다면 충분한 시간을 들여서 최고의 주석을 달도록 노력한다. 주석이 이해가 안되어 다른 모듈까지 뒤져야 하는 주석을 독자와 제대로 소통하지 못하는 주석이다. 같은 이야기를 중복하는 주석 함수를 보고 의미를 해석할 수 있지만, 주석으로 함수에 대한 설명을 한다. 심지어 함수보다 의미를 잘 전달하지 못한다. 없는게 더 낫다. 즉, 주석이 더 많은 정보를 제공하지 못한다. 코드를 정당화하는 주석도 아니고, 의도나 근거를 설명하는 주석도 아니다. 코드보다 읽기가 쉽지도 않다. 오해할 여지가 있는 주석 때때로 의도는 좋았으나 프로그래머가 딱 맞을 정도로 엄밀하게는 주석을 달지 못하기도 한다. 의무적으로 다는 주석 모든 함수에 Javadocs를 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석기 그지없다. 이런 주석은 코드를 복잡하게 만들며, 거짓말을 퍼뜨리고 혼동과 무질서를 초래한다. 오히려 코드만 헷갈리게 만들며, 거짓말할 가능성을 높이며 잘못된 정보를 제공할 여지만 만든다. 이력을 기록하는 주석 예전에 사람들은 모듈을 편집할 때마다 모듈 첫머리에 주석을 추가한다. 그리하여 모듈 첫머리 주석은 지금까지 모듈에 가한 변경을 모두 기록하는 일종의 일지 혹은 로그가 된다. 이제는 그렇게 하지 않는다. 소스 코드 관리 시스템이 다양하기 때문이다. 완전히 제거하자. 있으나 마나 한 주석 너무 당연한 사실을 언급하며 새로운 정보를 제공하지 못하는 주석이 있다. 이는 제거해야 마땅하다. 무서운 잡음 때로는 Javadocs도 잡음이다. 함수나 변수로 표현할 수 있다면 주석을 달지 마라. 다음 코드를 살펴보자. 12// 전역 목록 &lt;smodule&gt;에 속하는 모듈이 우리가 속한 하위 시스템에 의존하는가?if(smodule.getDependSubsystems().contains(subSysMod.getSubSystem())) 위 코드에서 주석을 없애고 다시 표현하면 아래와 같다. 123ArrayLis moduleDependees = smoudle.getDependSubsystems();String ourSubSystem = subSysMod.getSubSystem();if(moduleDependees.contains(ourSubSystem)) 코드를 작성한 저자는 주석을 먼더 달고 주석에 맞춰 코드를 작성했는지도 모른다. 하지만 위와 같이 주석이 필요하지 않도록 코드를 개선하는 편이 낫다. 위치를 표시하는 주석 소스 파일에서 특정 위치를 표시하려 주석을 사용한다. 1// Actions //////////////// 위와 같은 배너 아래 특정 기능을 모아놓으면 유용한 경우도 있다. 하지만, 일반적으로 위와 같은 주석은 가독성만 낮추므로 제거해야 한다. 배너를 남용하면 흔한 잡음으로 여겨진다. 닫는 괄호에 다는 주석 닫는 괄호에 특수한 주석을 달기도 한다. 중첩이 심하고 장황한 함수라면 의미가 있을지도 모르지만 작고 캡슐화된 함수에는 잡음일 뿐이다. 그러므로 닫는 괄호에 주석을 달아야겠다는 생각이 든다면 대신에 함수를 줄이려 시도하자. 공로를 돌리거나 저자를 표시하는 주석 1/* Woo가 추가함 */ 소스 코드 관리 시스템(Git)은 누가 언제 무엇을 추가했는지 기억한다. 그래서 저자 이름으로 코드를 오염시킬 필요가 없다. 위와 같은 정보는 소스 코드 관리 시스템에 저장하는 편이 좋다. 주석으로 처리한 코드 주석으로 처리한 코드만큼 밉살스러운 관행도 드물다. 주석으로 처리된 코드는 다른 사람들이 지우기를 주저한다. 이유가 있어 남겨놓았으리라고, 중요하니까 지우면 안된다고 생각한다. 그래서 계속해서 쌓여만 간다. 안된다. 지우자! HTML 주석 HTML 주석은 혐오 그자체다. 주석을 읽기 쉬어야 하는 편집기/IDE에서조차 읽기가 어렵다. 전역 정보 주석을 달아야 한다면 근처에 있는 코드만 기술하라. 코드 일부에 주석을 달면서 시스템의 전반적인 정보를 기술하지 마라. 주석을 달 코드와 연관있는 주석을 달아야 한다. 너무 많은 정보 주석에 흥미로운 역사나 관련 없는 정보를 장황하게 늘어놓지 마라. 모호환 관계 주석과 주석이 설명하는 코드는 둘 사이 관계가 명백해야 한다. 이왕 공들여 주석을 달았다면 적어도 독자가 주석과 코드를 읽어보고 무슨 소린지 알아야 한다. 함수 헤더 짧은 함수는 긴 설명이 필요 없다. 짧고 한 가지만 수행하며 이름을 잘 붙은 함수가 주석으로 헤더를 추가한 함수보다 훨씬 좋다. 비공개 코드에서 Javadocs 공개 API는 Javadocs가 유용하지만 공개하지 않을 코드라면 Javadocs는 쓸모가 없다. 유용하지 않을 뿐만 아니라 Javadocs 주석이 요구하는 형식으로 인해 코드만 보기 싫고 산만해진다. 참고 Clean Code","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"주석","slug":"주석","permalink":"http://victorywoolee/victorywoolee.github.io/tags/주석/"}]},{"title":"[CleanCode] 3장","slug":"CleanCode03","date":"2019-09-15T04:20:20.000Z","updated":"2019-09-15T04:23:40.600Z","comments":true,"path":"2019/09/15/CleanCode03/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/15/CleanCode03/","excerpt":"","text":"해당 글은 Clean Code 책을 보면서 내용을 간단하게 정리한 글입니다.문제가 된다면 바로 삭제하도록 하겠습니다. 작게 만들어라! 함수를 만드는 첫째 규칙은 ‘작게’이다. 두번째 규칙은 ‘더 작게’이다. 함수가 하나의 이야기만을 표현하며 짧아야 한다. 블록과 들여쓰기 if문, else문, while문에 들어가는 블록은 한 줄이어야 한다는 의미이다. 대개 거기서 함수를 호출한다. 그러면 바깥을 감싸는 함수가 작아질 뿐 아니라, 블록 안에서 호출하는 함수 이름을 적절히 짓는다면, 코드를 이해하기도 쉬워진다. 즉, 중첩 구조가 생길만큼 함수가 커져서는 안된다는 뜻이다. 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안된다. 그래야 함수는 읽고 이해하기 쉬워진다. 한가지만 해라! 함수는 한 가지를 해야 한다. 그 한가지를 잘해야 한다. 그 한가지만을 해야 한다. 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다. 함수가 한 가지만 하는지 판단하는 방법이 있다. 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다. 함수당 추상화 수준은 하나로! 함수가 확실히 ‘한 가지’ 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다. 위에서 아래로 코드 읽기: 내려가기 규칙 코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다. 즉, 위에서 아애로 프로그램을 읽으면 추상화 수준이 한 번에 한 단계씩 낮아진다. 서술적인 이름을 사용하라! 워드는 “코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 된다.” 한 가지만 하는 함수에 좋은 이름을 붙인다면 이런 원칙을 달성함에 있어 성공했다. 함수가 작고 단순할수록 서술적인 이름을 고르기가 쉬워진다. 길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 길고 서술적인 이름이 서술적인 주석보다 좋다. 함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다. 그런 다음, 여러 단어를 사용해도 함수 기능을 잘 표현하는 이름을 선택한다. 이름을 붙일 때는 일관성이 있어야 한다. 함수 인수 함수에서 이상적인 인수 개수는 0개이다. 다음은 1개이고, 그 다음은 2개이다. 3개는 가능한 피하는 편이 좋다. 4개 이상은 특별한 이유가 필요하다. 인수는 개념을 이해하기 어렵게 만든다. 최선은 입력 인수가 없는 경우이며, 차선은 입력 인수가 1개뿐인 경우다. 많이 쓰는 단항 형식 함수에 인수 1개를 넘기는 이유는 가장 흔한 경우 두 가지이다. 1.하나는 인수에 질문을 던지는 경우다. boolean fileExists(“file”) 2.다른 하나는 인수를 뭔가로 변환해 결과를 반환하는 경우다. InputStream fileOpen(“file”) 명령과 조회를 분리하라. 다소 드물게 사용하지만, 아주 유용한 단항 함수 형식이 이벤트다. 이벤트 함수는 조심해서 사용한다. 이벤트라는 사실이 코드에 명확하게 드러나야 한다. 입력 인수를 변환하는 함수라면 변환 결과는 반환값으로 돌려준다. 플래그 인수 플래그 인수는 추하다. 함수로 부울 값을 넘기는 관례는 정말 끔찍하다. 왜냐면 함수가 한꺼번에 여러 가지를 처리한다고 알려주는 셈이기 때문이다. 플래그 인수를 사용해서 여러 가지 일을 처리하기 보다는 함수를 쪼개서 작은 일 하나를 함수로 처리하는 것이 낫다. 이항 함수 인수가 2인 함수는 인수가 1개인 함수보다 이해하기 어렵다. 예를 들어, writeField(name)는 writeField(outputStream, name)보다 이해하기 쉽다. 둘다 의미는 명백하지만 전자가 더 쉽게 읽히고 더 빨리 이해된다. 이항 함수가 무조건 나쁘다는 소리는 아니다. 프로그램을 짜다 보면 불가피한 경우도 생긴다. 하지만, 그만큼 위험이 따른다는 사실을 이해하고 가능하면 단항 함수로 바꾸도록 애써야 한다. 삼항 함수 인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다. 순서, 주춤, 무시로 야기되는 문제가 두 배 이상 늘어난다. 삼항 함수를 만들 때는 신중히 고려해야 한다. 인수 객체 인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어보자. 예를 들어, 다음 두 함수를 살펴보자. Circle makeCircle(double x, double y, double radius); Circle makeCircle(Point center, double radius); 위의 함수처럼 객체를 생성해 인수를 줄이는 방법이 눈속임이라 여겨질지 모르지만 그렇지 않다. 이전 예제에서 x와 y를 묶었듯이 변수를 묶어 넘기려면 이름을 붙여야 하므로 결국은 개념을 표혀하게 되는 것이다. 인수 목록 때로는 인수 개수가 가변적인 함수도 필요하다. String.format 메소드가 좋은 예다. String.format(“%s worke %.2f hours.”, name, hours); 위 예제처럼 가변 인수 전부를 동등하게 취급하면 List형 인수 하나로 취급할 수 있다. 이런 논리의 측면에서 String.format은 사실 이항 함수이다. 가변 인수를 취하는 모든 함수는 같은 원리가 적용된다. 가변 인수를 취하는 함수는 단항, 이항, 삼항 함수로 취급할 수 있다. 하지만 이를 넘어서는 인수를 사용할 경우 문제가 된다. void monad(Integer… args); void dyad(String name, Integer… args); 동사와 키워드 함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수다. 단항 함수는 함수와 인수가 동사, 명사 쌍을 이뤄야 한다. write(name) → 이름을 쓴다. writeField(name) → 이름이 필드. 위의 함수보다 더 명확해서 좋다. 함수 이름에 키워드를 추가해보자. assertEquals보다 assertExpectedEqualsActual(expected, actual)이 더 좋다. 그러면 순서를 기억하지 않아도 함수 이름으 보고 유추할 수 있다. 부수 효과를 일으키지 마라! 함수에서 한가지를 하겠다고 약속하고선 남몰래 다른 짓을 하면 안된다. 때로는 예상치 못하게 클래스 변수를 수정한다. 때로는 함수로 넘어온 인수나 시스템 전역 변수를 수정한다. 어느쪽이든 교활하고 해로운 거짓말이다. 많은 경우 시간적인 결합이나 순서 종속성을 초래한다. 시간적인 결합이 필요한 경우 함수 이름에 명시해야 한다. 출력 인수 일반적으로 출력 인수는 피해야 한다. 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 선택한다. 명령과 조회를 분리하라! 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다. 둘 다 하면 안된다. 객체 상태를 변경하거나 아니면 객체 정보를 반환하거나 둘 중 하나만 해야 한다. 둘 다 하게 된다면 의미가 모호해지기 때문이다. 그래서 명령과 조회를 분리해 혼란을 없애는 게 좋다. 오류 코드보다 예외를 사용하라! 명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다. 자칫하면 if문에서 명령을 표현식으로 사용하기 쉬운 탓이다. 오류 코드를 사용하게 되면 오류가 발생했을 때, 즉시 처리해야 한다. 그러면 if문이 중첩되어서 가독성이 떨어지게 된다. 이를 오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 깔끔해진다. Try/Catch 블록 뽑아내기 try/catch 블록은 원래 추하다. 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞는다. 그러므로 try/catch 블록을 별도의 함수로 뽑아내는 편이 좋다. 123456789101112131415161718public void delete(Page page)&#123; try&#123; deletePageAndAllReferences(page); &#125; catch(Exception e)&#123; logError(e); &#125;&#125;private void deletePageAndAllReferences(Page page) throws Exception&#123; deletePage(page); registry.deleteReference(page.name); configKeys.deleteKey(page.name.makeKey());&#125;private void logError(Exception e)&#123; logger.log(e.getMessage());&#125; 위에서 delete 함수는 모든 오류를 처리한다. 그래서 코드를 이해하기 쉽다.실제로 페이지를 제거하는 함수는 deletePageAndAllReferences() 함수이다.deletePageAndAllReferences 함수는 예외를 처리하지 않는다.이렇게 정상 동작과 오류 처리 동작을 분리하면 코드를 이해하고 수정하기 쉬워진다. 오류 처리도 한 가지 작업이다. 함수는 한 가지 작업만 해야 한다. 오류 처리도 한 가지 작업에 속한다. 그러므로 오류를 처리하는 함수는 오류만 처리해야 한다. 반복하지 마라! 중복은 문제다. 코드 길이가 늘어날 뿐 아니라 알고리즘이 변하면 네 곳이나 손을 봐야 한다. 중복을 없앴더니 모듈 가독성이 크게 높아졌다. 중복은 소프트웨어에서 모든 악의 근원이다. 객체 지향 프로그래밍은 코드를 부모 클래스로 올려서 중복을 없앤다.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"함수","slug":"함수","permalink":"http://victorywoolee/victorywoolee.github.io/tags/함수/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-13T03:13:02.479Z","updated":"2019-09-13T03:13:02.479Z","comments":true,"path":"2019/09/13/hello-world/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}