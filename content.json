{"meta":{"title":"VictoryWoo","subtitle":"VictoryWoo's Blog","description":null,"author":"Victory Woo","url":"http://victorywoolee/victorywoolee.github.io","root":"/"},"pages":[],"posts":[{"title":"[Android] ViewPager","slug":"Android-ViewPager","date":"2019-10-26T07:53:54.000Z","updated":"2019-10-26T08:45:52.762Z","comments":true,"path":"2019/10/26/Android-ViewPager/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/26/Android-ViewPager/","excerpt":"","text":"이번 글은 Android의 ViewPager 전부에 관해 다루지 않고 특정 속성에 대해서 알아보려고 한다. ViewPager는 보통 Tab, Fragment와 함께 사용하여 탭 클릭 시 다른 화면으로 전환하기 위해서 사용하곤 한다. Fragment를 로드하는 상황에서 조금 더 효율적으로 로드하기 위해 사용하는 속성에 대해 알아보자. setOffscreenPageLimit필자는 ViewPager와 Fragment를 이용해서 좌우 Swipe가 가능한 화면을 구성해야 했다. 그리고 TabLayout도 함께 사용했다. 그리고 화면이 켜질 때 Fragment를 로드해야 한다. 그런데 이 화면을 개발하다가 이상한 에러를 만났다. 그래서 필자는 Google에 검색했고, setOffscreenPageLimit이라는 속성을 사용해 숫자를 설정하면 된다는 답변만을 확인하고 사용되는 Fragment의 개수가 7개이기 때문에 7로 설정을 했다. 에러가 나지 않고 필자가 원하는 동작을 하긴 했지만, 저 속성이 무엇을 의미하는지 몰라 찾아보기로 했다. ViewPager는 디폴트 값으로 현재 보이는 페이지 좌우만 생성해놓고 사용하는 구조이다. 즉, 1번, 2번, 3번의 탭이 존재한다면 1번 탭에 있을 경우에는 2번 탭을 미리 생성해놓는다. 그리고 2번 탭에 있는 경우는 1번과 3번 탭을 미리 생성해놓는다. 3번 탭으로 오게 되면 2번 탭은 미리 생성하고 사용하지만, 1번 탭은 파괴한다. 이유는 간단한데, 메모리를 효율적으로 사용하기 위함이다. 하지만, 유지해야 하는 페이지가 있는데, 이처럼 파괴된다면 원하는 앱을 구현하기 힘들다. 그래서 아래와 같은 속성을 사용하면 된다. setOffscreenPageLimit는 View의 계층 구조에서 좌우에 유지해야 하는 페이지의 수를 설정할 수 있다. 이를 초과하는 페이지는 필요할 때, 어댑터에 의해서 다시 그려지게 된다. 즉, 이 속성은 최적화되어 제공된다. 페이지에 지원하거나 지연 로딩 메커니즘이 필요한 필요한 페이지의 갯수를 미리 알고 있는 경우, 해당 속성을 사용해 설정을 조정하면 페이징 애니메이션 및 상호 작용을 매끄럽게 구성할 수 있다. 한 번에 모두 활성화할 수 있는 적은 수의 페이지(3~4)가 있는 경우, 해당 페이지 좌우로 새로 생성된 뷰 하위 트리의 레이아웃을 그리는데 소요되는 시간이 줄어들어 효율적이다. 특히 페이지의 레이아웃이 복잡한 경우 이 Limit을 낮게 유지해야 한다. 이 설정의 기본값은 1이며, 좌우로 1개씩 미리 로딩한다는 의미이다. setOffscreenPageLimit을 3으로 설정한다면 좌우로 3개의 페이지를 미리 로딩해놓는다. 즉, 7개의 탭이 있고 그 중에서 4번째 탭에 위치해 있다면 좌우로 3개씩 페이지를 미리 로딩해 놓는 것이다. 메모리가 넉넉하다면 이렇게 하면 좋지만, 그렇지 않다면 2 정도로 해서 좌우로 2개씩의 페이지를 유지하는 것이 적당해 보인다. 이외의 페이지는 필요할 때 어댑터에 의해서 그려진다고 위에서 설명하였다. 해당 속성을 사용해서 프래그먼트 혹은 페이지를 생성하는 데 있어서 메모리를 조금 더 효율적으로 사용할 수 있을 것이다. 마지막으로 setOffscreenPageLimit에 0을 넣으면 어떻게 될까? 0을 넣는다는 것은 좌우의 페이지를 로딩하지 않고 페이지를 선택할 때마다 로딩하는 것을 의미한다. 하지만, 이 코드가 동작할까?? 결과는 아니다. 0을 넣어도 디폴트 값으로 지정된 1로 동작하게 되어 좌우에 1개의 페이지를 로드하게 된다. setUserVisibleHint 다음 시간에.. 참고 Android Developer ViewPager 완전정복 중 일부","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"ViewPager","slug":"ViewPager","permalink":"http://victorywoolee/victorywoolee.github.io/tags/ViewPager/"},{"name":"Fragment","slug":"Fragment","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Fragment/"}]},{"title":"[Android] descendantFocusability 속성","slug":"Android-descendantFocusability","date":"2019-10-26T07:29:48.000Z","updated":"2019-10-26T07:49:05.632Z","comments":true,"path":"2019/10/26/Android-descendantFocusability/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/26/Android-descendantFocusability/","excerpt":"","text":"안드로이드 개발을 하면서 xml을 사용해 레이아웃을 작성하는 것이 일반적이다. 그 중에서도 ScrollView나 NestedScrollView는 꽤 자주 사용한다. 그렇지 않은 개발자들도 있겠지만, 뭐 스크롤이 필요한 화면에서는 거의 필수적일 것이다. 필자도 ScrollView를 자주 사용하는데, 이를 사용하면서 겪은 이슈와 이를 해결한 방법에 대해 공유하려고 한다. 그렇게 깊은 내용도 아니고 많은 내용도 아니기 때문에 가볍게 읽기 좋다. ScrollView 먼저, ScrollView의 특징 중 하나는 자식을 하나만 가질 수 있다는 것이다. 그래서 LinearLayout, ConstraintLayout과 같은 ViewGroup을 자식으로 가지게 하고 그 자식 안에서 뷰를 구성한다. 필자도 이와 같은 일반적인 방법으로 뷰를 구성했고, 실행을 해봤는데 포커스가 다른 곳에 잡혀 화면의 최상단이 아닌 중간에 잡히는 경우가 있었다. 이는 뷰의 포커스를 부모가 가지는게 아니라 부모가 가진 자식이 포커스를 빼앗기 때문에 생기는 이슈였다. descendantFocusability라는 속성은 뷰가 포커스를 가질 때, ViewGroup과 그 자식들의 관계를 정의할 수 있는 속성이다. 그리고 다음의 상수 값을 가져야 한다고 문서에 정의되어 있다. afterDescendants(1) : ViewGroup은 해당 하위 항목이 없는 경우에만 포커스를 받는다. beforeDescendants(0) : ViewGroup은 하위 항목보다 먼저 포커스를 받는다. blocksDescendants(2) : ViewGroup은 하위 항목이 포커스를 받는 것을 차단한다. 문서를 통해서 원하는 속성이 3번째인 blocksDescendants이라는 것을 알 수 있다. 이를 통해서 ViewGroup의 하위 자식들이 포커스를 받지 않게 한다면 화면에 들어왔을 때, 최상단이 아닌 중간에 포커스가 잡히는 이슈를 해결할 수 있을 것이다. 이 속성은 ScrollView의 자식인 ViewGroup에 명시적으로 속성을 정의하면 된다. 최근 들어, 어떤 문제에 직면했을 때 해결하기 위한 답은 문서가 먼저라는 것을 느끼고 있다. 어느 사람의 블로그 글 보다는 문서를 더 중요하게 봐야겠다. 참고 Android Developer","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"descendantFocusability","slug":"descendantFocusability","permalink":"http://victorywoolee/victorywoolee.github.io/tags/descendantFocusability/"}]},{"title":"[Kotlin] 타입 시스템 - 널 가능성2","slug":"Chap6-2","date":"2019-10-20T11:09:51.000Z","updated":"2019-10-20T11:10:10.162Z","comments":true,"path":"2019/10/20/Chap6-2/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/20/Chap6-2/","excerpt":"","text":"","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Kotlin/"},{"name":"Type","slug":"Type","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Type/"}]},{"title":"[Kotlin] 타입 시스템 - 널 가능성","slug":"Chap6-1","date":"2019-10-19T14:20:47.000Z","updated":"2019-10-20T11:09:41.761Z","comments":true,"path":"2019/10/19/Chap6-1/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/19/Chap6-1/","excerpt":"","text":"코틀린은 자바와 달리 널에 대해서 민감하게 반응한다. 그래서 널이 될 수 있는 타입과 널이 될 수 없는 타입이 나눠져 있으며, 널과 관련한 문법을 제공해 개발자로 하여금 널과 관련된 처리를 하는데 편의성을 제공해준다. 이로 인해 가독성 또한 좋아진다. 널 가능성 널 가능성은 NullPointerException 오류(NPE)를 피할 수 있게 돕기 위한 코틀린 타입 시스템의 특성이다. 코틀린을 비롯한 최신 언어에서 null에 대한 접근 방법은 가능한 한 이 문제를 실행 시점에서 컴파일 시점으로 옮기는 것이다. 널이 될 수 있는지 여부를 타입 시스템에 추가함으로써 컴파일러가 여러 가지 오류를 컴파일 시 미리 감지해서 실행 시점에 발생할 수 있는 예외의 가능성을 줄일 수 있다. 1. 널이 될 수 있는 타입 널이 될 수 있는 타입을 지원한다. 널이 될 수 있는 타입은 프로그램 안의 프로퍼티나 변수에 null을 허용하게 만드는 방법이다. 예시를 통해 이해해보자. 다음은 자바로 짜여진 함수다. 123int strLen(String s)&#123; return s.lenght();&#125; 위 함수에 인자로 null을 넘기면 NPE가 발생한다. s가 널인지 검사를 해야할까?? 이 부분에 대해 생각해보면서 코틀린으로 작성된 함수를 보자. 123fun strLen(s: String) = s.length()fun strLen(s: String?) = s?.length() 위 함수에 대해서는 null이거나 널이 될 수 있는 인자를 넘기는 것은 금지되며, 넘길 경우 NPE가 발생한다. strLen 함수의 파라미터 s의 타입은 String이며, 항상 String의 인스턴스여야 한다. 이때, 컴파일러는 널이 될 수 있는 값을 strLen에게 인자로 넘기지 못하게 막는다. 따라서 strLen 함수가 실행 시점에 NPE을 발생시키지 않으리라 장담할 수 있다. String?, Int? 등 어떤 타이이든 타입 이름 뒤에 ?를 붙이면 그 타입의 변수나 프로퍼티에 null을 참조를 저장할 수 있다는 뜻이다.?가 없는 타입은 그 변수가 null 참조를 저장할 수 없다는 뜻이다. 모든 타입은 기본적으로 널이 될 수 없으며, 뒤에 ?가 붙어야 널이 될 수 있다. 널이 될 수 있는 타입의 변수가 있다면 그에 대해 수행할 수 있는 연산이 제한된다. 널이 될 수 있는 타입인 변수에 대해 변수.메소드()처럼 메소드를 직접 호출할 수 없다. (널에 대한 검사 혹은 널이 될 수 있는 값에 대한 처리가 필요.) 널이 될 수 있는 값을 널이 될 수 없는 타입의 변수에 대입할 수 없다. 널이 될 수 있는 타입의 값을 널이 될 수 없는 파라미터를 받는 함수에 전달할 수 없다. 널이 될 수 있는 타입은 널을 검사할 때 사용될 수 있으며, 이는 뒤쪽에서 알아보도록 하자. 2. 타입의 의미 자바의 String 타입의 변수에는 String과 null이 모두 들어갈 수 있다. 이 두 종류의 값은 완전히 다르다. 두 종류의 값에 대해 실행할 수 있는 연산도 완전히 다르다. 실제로 String이 들어있는 변수에 대해서는 String 클래스에 정의된 모든 메소드를 호출할 수 있다. 하지만, null이 들어있는 경우에는 사용할 수 있는 연산이 많지 않다. 이는 자바의 타입 시스템이 널을 제대로 다루지 못한다는 뜻이다. 변수에 선언된 타입이 있지만, 널 여부를 추가로 검사하기 전에는 그 변수에 대해 어떤 연산을 수행할 수 있을지 알 수 없다. 코틀린의 널이 될 수 있는 타입과 널이 될 수 없는 타입을 구분하면 각 타입의 값에 대해 어떤 연산이 가능할지 명확히 이해할 수 있고, 실행 시점에 예외를 발생시킬 수 있는 연산을 판단할 수 있다. 따라서 그런 연산을 아예 금지시키고 위 문제에 대한 종합적인 해법을 제공한다. 주의 : 실행 시점에 널이 될 수 있는 타입이나 널이 될 수 없는 타입의 객체는 같다. 널이 될 수 있는 타입은 널이 될 수 없는 타입을 감싼 래퍼 타입이 아니다. 모든 검사는 컴파일 시점에 수행된다. 따라서 코틀린에서는 널이 될 수 있는 타입을 처리하는 데 별도의 실행 시점 부가 비용이 들지 않는다. 3. 안전한 호출 연산자 ?. null 검사와 메소드 호출을 한 번의 연산으로 수행한다. 호출하려는 값이 null이 아니라면 ?.은 일반 메소드 호출처럼 작동한다. 호출하려는 값이 null이면 이 호출은 무시되고 null이 결과 값이 된다. ?. 연산자 사용 예시 1234567891011// ?. 연산자를 사용하지 않고 if문을 사용했을 경우.if(s == null)&#123; s.toUpperCase()&#125;else&#123; null&#125;// ?. 연산자를 사용했을 경우.// allCaps는 널이 될 수 있는 타입이다.val allCaps = s?.toUpperCase() 주의해야 할 점은 안전한 호출의 결과 타입도 널이 될 수 있는 타입이라는 것이다. 메소드 호출뿐 아니라 프로퍼티를 읽거나 쓸 때도 안전한 호출을 사용할 수 있다. 널이 될 수 있는 중간 객체가 여럿 있다면 한 식 안에서 안전한 호출을 연쇄해서 함께 사용하면 편하다. 자바에서 널 검사가 들어간 호출을 코틀린에서는 훨씬 간결하게 처리할 수 있다. 이로 인해 불필요한 if문의 사용을 줄일 수 있다. 4. 엘비스 연산자 ?: null 대신 사용할 디폴트 값을 지정할 때 편리하게 사용할 수 있다. 엘비스 연산자는 이항 연산자로 좌항을 계산한 값이 널인지 검사한다. 좌항 값이 널이 아니면 좌항 값을 결과로 하고, 좌항 값이 널이면 우항 값을 결과로 한다. 123fun foo(s: String?)&#123; val t: String = s ?: \"\"&#125; s가 널이면 빈 문자열을 t의 결과로 한다는 의미이다. 어떻게 보면 엘비스 연산자는 널을 특정 값으로 바꿔주는 역할을 하기도 한다. 엘비스 연산자를 객체가 널인 경우 널을 반환하는 안전한 호출 연산자와 함께 사용해서 객체가 널인 경우에 대비한 값을 지정하는 경우도 많다. 1234567fun strLenSafe(s: String?): Int = s?.length ?: 0println(strLenSafe(\"abc\"))println(strLenSafe(null))// 결과30 코틀린에서는 return이나 throw 등의 연산도 식이다. 따라서 엘비스 연산자의 우항에 return, throw 등의 연산을 넣을 수 있고, 엘비스 연산자를 더욱 편하게 사용할 수 있다. 이런 패턴은 함수의 전제 조건을 검사하는 경우에 유용하다. 5. 안전한 캐스트: as? 코틀린의 타입 캐스트 연산자인 as는 자바 타입 캐스트와 마찬가지로 대상 값을 as로 지정한 타입으로 바꿀 수 없으면 ClassCastException이 발생한다. as? 연산자는 어떤 값을 지정한 타입으로 캐스트한다. 값을 대상 타입으로 변환할 수 없으면 null을 반환한다. 타입 캐스트 연산자는 값을 주어진 타입으로 변환하려 시도하고 타입이 맞지 않으면 null을 반환한다. 안전한 캐스트는 일반적으로 캐스트를 수행한 뒤에 엘비스 연산자를 함께 사용하는 패턴이 일반적이다. 123456789101112131415161718192021222324class Person(val firstName: String, val lastName: String)&#123; override fun equals(o: Any?): Boolean&#123; // 타입이 일치하지 않으면 false를 반환한다. val otherPerson = o as? Person ?: return false // 안전한 캐스트를 하고 나면 otherPerson이 Person 타입으로 스마트 캐스트 된다. return otherPerson.firstName =- firstName &amp;&amp; otherPerson.lastName == lastName &#125; override fun hashCode(): Int&#123; return firstName.hashCode() * 37 + lastName.hashCode() &#125;&#125;val p1 = Person(\"Lee\", \"Seungwoo\")val p2 = Person(\"Lee\", \"Seungwoo\")// == 연산자는 equals()를 호출한다.println(p1 == p2)println(p1.equals(42))// 결과truefalse 타입을 캐스트한 다음에 해당 변수가 null을 반환하지 않으면 컴파일러는 어떤 값이 해당 타입이 맞다고 판단을 해서 자동으로 타입 캐스트를 진행한다. 이를 스마트 타입 캐스트라고 한다. 6. 널 아님 단언: !! 널이 될 수 있는 타입의 값을 다룰 때 사용할 수 있다. !!을 통해 어떤 값이든 널이 될 수 없는 타입으로 강제로 바꿀 수 있다. 실제 널에 대해서 !!를 적용하면 NPE가 발생한다. !!를 널에 대해 사용해서 발생하는 예외의 Stack trace에는 어떤 파일의 몇 번째 줄인지에 대한 정보는 들어있지만 어떤 식에서 예외가 발생했는지에 대한 정보가 들어있지 않다. 어떤 값이 널이었는지 확실히 하기 위해 여러 !! 단언문을 한 줄에 함께 쓰는 일을 피하는 것이 좋다. 12person.company!!.address!!.country// 이런식으로 코드를 작성하는 것을 피해야 한다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Kotlin/"},{"name":"Type","slug":"Type","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Type/"}]},{"title":"[ETC] Method 이름","slug":"Method-Name","date":"2019-10-19T04:28:36.000Z","updated":"2019-10-19T04:51:52.489Z","comments":true,"path":"2019/10/19/Method-Name/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/19/Method-Name/","excerpt":"","text":"개발을 하면서 메소드 이름을 그냥 내가 이해하기 쉬운 방향으로 작성을 했던 경향이 있었다. 이렇게 하는 방식이 나쁘지는 않다. 왜냐하면 혼자 프로젝트를 할 때는 상관이 없기 때문이다. 하지만, 이 프로젝트를 유지보수 하거나 다른 사람과 함께 하는 경우에는 이야기가 달라진다. 최근에 회사에서 기능을 구현하면서 메소드를 작성하는데 필자의 이런 특성이 나왔다. 그래서 다른 사람들이 함수가 무엇을 하는지 파악하기 힘들어했고, 네이밍을 보았을 때 함수는 한 가지 일을 하는데, 구현을 들여다보니 여러가지 일을 하는 경우도 많았다. 그래서 최대한 생각을 해보고 작성하도록 노력하고 있으며, 도움이 될만한 글을 참고하고자 했다. 기초적인 메소드 이름 만드는 법 일반적으로 메소드 이름을 동사 + 명사형 이름으로 만들 것을 권장하고 있다. 다음과 같다. getData(), setData(), calculateData() 하지만, 아래 내용을 이해한다면 이보다 더 나은 메소드 명을 작성할 수 있을 것이다. 객체는 수동적이다. 객체는 외부에서 메소드를 호출해주지 않으면 아무 일도 하지 않는다. 왜냐하면 객체는 수동적이기 때문이다. 따라서 메소드 명칭은 수동적인 객체에게 무언가를 시키는 형태의 이름이 되어야 한다. 즉, 객체에게 명령하는 형식의 이름이어야 한다. 메소드 명칭 = 명령형 동사 + 목적어 단순히 동사 + 명사형으로 생각하지 않는게 좋다. 예를 들어, getData()라는 메소드의 명칭은 “데이터를 가지고 온다”라는 의미로 해석할 수도 있지만, 좀 더 명확하게는 “데이터를 내놔!”이다. 이렇게 해석하는 것이 좋은 이유는 객체를 구현할 때 좀 더 구현을 정확하게 할 수 있기 때문이다. 객체를 구현할 때, getData() 메소드를 구현하면서 “데이터를 가지고 온다.”라고 해석하고 구현하기 시작하면 구현이 꼬이기 시작한다. 반대로 객체가 “데이터를 내놔!”라는 명령을 받았을 때, 해야 할 일을 getData() 메소드에 구현하면 된다고 생각하고 구현을 시작하면 구현이 명료해진다. 참고 좋은 메소드 이름 만드는 법","categories":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/categories/ETC/"}],"tags":[{"name":"Method 이름","slug":"Method-이름","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Method-이름/"},{"name":"좋은 이름 짓기","slug":"좋은-이름-짓기","permalink":"http://victorywoolee/victorywoolee.github.io/tags/좋은-이름-짓기/"}]},{"title":"[Android] TabLayout","slug":"Android-TabLayout","date":"2019-10-19T04:24:13.000Z","updated":"2019-10-26T07:49:04.812Z","comments":true,"path":"2019/10/19/Android-TabLayout/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/19/Android-TabLayout/","excerpt":"","text":"TabLayout Tip! 안드로이드에서 탭 레이아웃은 자주 사용되는 위젯이다. 그만큼 다양한 기능을 제공한다. 그래서 이번에 탭 레이아웃을 쓰면서 겪은 기능들을 정리하고자 한다. 1. tabIndicatorFullWidth 이는 탭 레이아웃의 인디케이터의 width를 설정할 수 있는 속성이며, true / false 값을 설정할 수 있다. 탭 레이아웃의 인디케이터는 탭 아이템의 크기만큼 차지하며 아무런 설정을 하지 않는다면 꽉 차게 나온다. 하지만, 디자인 스펙이 꽉 차는 것이 아닌 탭 아이템의 텍스트나 아이콘만큼만 width를 차지하도록 하고 싶을 경우에 해당 속성을 사용하면 된다. support library 28 이상을 쓴다면 tabIndicatorFullWidth의 속성을 false로 주면 된다. 그렇지 않다면 직접 코드로 인디케이터의 width를 설정해주어야 한다. 2. tabContentStart 이 속성을 몰랐다면 정말 오랜 시간 동안 삽질을 했을 것이다. 운이 좋게 스택 오버플로우에서 원하던 답변을 찾았고, 적용해본 결과 정상적으로 작동함을 확인했다. 다음과 같은 화면을 보자. 위 화면에서 Animals for adoption이라는 타이틀과 탭 레이아웃의 첫 번째 탭인 CATS가 왼쪽 라인이 동일한 위치로 맞추고 싶은 경우가 있을 것이다. 대부분의 디자인 스펙은 필자가 이야기한 것을 통일성 있게 맞추기 위해 디자인을 해서 개발자에게 알려줄 것이다. 그렇다면 어떻게 첫 번째 탭의 위치를 타이틀과 같은 위치로 맞출 수 있을까? 방법은 두 가지로 보이지만, 필자는 한 가지 방법만 시도해봤다. 그게 바로 위의 방법이다. tabContentStart를 이용해서 첫 탭의 위치를 왼쪽에서부터 얼만큼 떨어트릴지 정할 수 있다. 이 속성을 통해서 첫 탭을 원하는 위치에 맞게 지정할 수 있으며, 탭 간의 간격도 원하는대로 설정할 수 있다. 참고 Stack Overflow","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"TabLayout","slug":"TabLayout","permalink":"http://victorywoolee/victorywoolee.github.io/tags/TabLayout/"}]},{"title":"[ETC] Compile, Build","slug":"Compile-Build","date":"2019-10-19T03:12:59.000Z","updated":"2019-10-19T04:00:10.131Z","comments":true,"path":"2019/10/19/Compile-Build/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/19/Compile-Build/","excerpt":"","text":"간단한 개념을 정리하기 위한 공간입니다.Android Studio나 IntelliJ 같은 IDE를 많이 사용하고 실행 과정을 자동으로 처리해줘 편하게 해주기 때문에 컴파일과 빌드에 대한 차이점을 잊고 살았다. 최근에 갑자기 떠올라서 관련 개념을 정리하려고 한다. Compile 개발자가 작성한 소스 코드를 바이너리 코드로 변환하는 과정을 말한다. 목적 파일이 생성된다. 즉, 컴퓨터가 이해할 수 있는 기계어로 변환하는 작업이다. 이런 작업을 해주는 프로그램을 컴파일러라고 한다. 자바의 경우, JVM에서 실행 가능한 바이트 코드 형태의 클래스 파일이 생성된다. Link 프로젝트에서 개발을 진행하다 보면 여러 소스 파일을 작성한다. 예를 들어, A 소스 파일에서 B 소스 파일에 존재하는 함수를 호출하는 경우가 있다. 이때, A와 B 소스 파일을 각각 컴파일만 하면 A가 B에 존재하는 함수를 찾지 못하기 때문에 호출할 수 없다. 따라서 A와 B를 연결해주는 작업이 필요하고, 이런 작업을 링크라고 한다. static link(정적 링크) : 컴파일된 소스 파일을 연결해서 실행 가능한 파일을 만드는 것. dynamic link(동적 링크) : 프로그램 실행 도중 프로그램 외부에 존재하는 코드를 찾아서 연결하는 작업. 자바의 경우, JVM이 프로그램 실행 도중 필요한 클래스를 찾아서 클래스 패스에 로드해주는데 이는 동적 링크의 예다. Build 소스 코드 파일을 실행 가능한 소프트웨어 산출물로 만드는 일련의 과정을 말한다. 빌드의 단계 중 컴파일이 포함이 되어 있다. 컴파일은 빌드의 부분 집합이라 할 수 있다. 빋르 과정을 도와주는 도구를 빌드 툴이라고 한다. 빌드 툴 빌드 툴이 제공하는 기능은 다음과 같다. 전처리, 컴파일, 패키징, 테스팅, 배포 빌드 툴의 예 : Ant, Maven, Gradle 등 정리 우리는 소스 코드를 작성하고 파일로 저장한다. 저장한 소스 파일을 컴파일러를 이용해 컴파일하고 목적 파일을 생성한다. 컴파일러가 생성한 목적 파일들을 링커를 이용해 링크(연결)시킨다. 결과로 실행 가능한 목적 파일이 생성된다. 링커는 실행 가능한 목적 파일을 생성한다. 컴파일러가 생서하는 파일과 링커가 생성하는 파일의 차이는 생성한 목적 파일이 실행 가능하느냐의 차이에 있다. 컴파일과 링크의 과정을 합쳐 Build(빌드)라고 하고, 이때 사용되는 프로그램을 빌더라고 한다. 참고 컴파일과 빌드 차이점 컴파일 &amp; 링크 &amp; 빌드","categories":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/categories/ETC/"}],"tags":[{"name":"compile","slug":"compile","permalink":"http://victorywoolee/victorywoolee.github.io/tags/compile/"},{"name":"build","slug":"build","permalink":"http://victorywoolee/victorywoolee.github.io/tags/build/"},{"name":"Development","slug":"Development","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Development/"}]},{"title":"[Kotlin] 수신 객체 지정 람다","slug":"Chap5-5","date":"2019-10-13T07:59:27.000Z","updated":"2019-10-13T09:00:33.766Z","comments":true,"path":"2019/10/13/Chap5-5/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/13/Chap5-5/","excerpt":"","text":"이번에는 with과 apply에 대해서 알아본다. 매우 유용하며 코틀린 람다의 독특한 기능을 이해할 수 있다. 이 기능은 바로 수신 객체를 명시하지 않고 람다의 본문 안에서 다른 객체의 메소드를 호출할 수 있게 하는 것이다. 그런 람다를 수신 객체 지정 람다라고 부른다. 기존에 필자가 알고 있던 이 함수들은 범위 지정 함수라고 알고 있었고 with, apply, let, run과 같은 함수들이 있었다. 이번에 with과 apply는 책의 내용과 필자가 알고 있는 내용을 종합해서 정리하며 나머지 함수들도 정리할 예정이다. with 객체의 이름을 반복하지 않고 그 객체에 대해 다양한 연산을 수행할 수 있다. with() 함수를 사용하면 위의 기능을 사용할 수 있다. 인자로 받은 객체를 이어지는 블록(람다)의 수신 객체로 만든다. 그래서 람다 본문에서는 this를 사용해 수신 객체에 접근할 수 있다. 또한, this를 생략하고 수신 객체의 프로퍼티나 메소드에 접근하는 것도 가능하다. 블록(람다)의 값을 반환한다. 12345678910fun alphabet(): String&#123; val sb = StringBuilder() return with(sb)&#123; for(letter in 'A'..'Z')&#123; this.append(letter) &#125; append(\"\\n Now I know the alphabet! \") this.toString() &#125;&#125; 메소드를 호출하려는 수신 객체를 지정한다. 그리고 블록 안에서 원하는 함수나 프로퍼티에 접근할 수 있다. this를 명시해서 앞에서 지정한 수신 객체의 메소드를 호출하거나 this를 생략하고 호출할 수도 있다. 그리고 람다는 값을 반환할 수도 있다. Tip - 메소드 이름 충돌with에게 인자로 넘긴 객체의 클래스(위의 코드에서는 StringBuilder)와 with을 사용하는 코드가 들어있는 클래스 안(위의 코드에는 없지만 alphabet() 함수를 포함하는 클래스)에 이름이 같은 메소드가 있으면 어떤 일이 생길까? 이와 같은 경우 this 참조 앞에 레이블을 붙이면 호출하고 싶은 메소드를 명확하게 정의할 수 있다. alphabet 함수가 OuterClass의 메소드라고 하자. StringBuilder가 아닌 바깥쪽 클래스 즉, OuterClass에 정의된 toString()을 호출하고 싶다면 다음 구문을 사용하면 된다.this@OuterClass.toString() apply with 함수와 비슷한 역할을 한다. 주로 객체의 인스턴스를 만들면서 즉시 프로퍼티 중 일부를 초기화해야 하는 경우에 사용되며, with과의 차이점은 apply에게 전달된 객체(즉, 수신 객체)를 반환한다는 점이다. apply는 확장 함수로 정의되어 있다. apply의 수신 객체가 전달받은 람다의 수신 객체가 된다. 코틀린에서는 어떤 클래스가 정의돼 있는 라이브러리의 특별한 지원 없이도 그 클래스 인스턴스에 대해 apply를 활용할 수 있다. apply는 수신 객체 자체를 반환한다. 123456fun alphabet() = StringBuilder().apply&#123; for(letter in 'A'..'Z')&#123; append(letter) &#125; append(\"\\n Now I know the alphabet! \")&#125;.toString() 이처럼 수신 객체 지정 람다는 DSL(Domain Specific Language)을 만들 때 매우 유용한 도구이다. DSL에 대해서는 추후에 알아볼 예정이다. 요약 람다를 사용하면 코드 조각을 다른 함수에게 인자로 넘길 수 있다. 람다가 함수 인자인 경우 괄호 밖으로 람다를 빼낼 수 있고, 람다의 인자가 단 하나뿐인 경우 인자 이름을 지정하지 않고 it이라는 디폴트 이름으로 사용할 수 있다. 람다 안에 있는 코드는 그 람다가 들어있는 바깥 함수의 변수를 읽거나 쓸 수 있다. ::을 통해 멤버 참조를 사용할 수 있으며, 메소드, 생성자, 프로퍼티의 이름 앞에 붙여 쓸 수 있다. 이런 참조를 람다 대신 다른 함수에게 넘길 수 있다. filter, map, all, any 등의 함수를 사용하면 컬렉션에 대한 대부분의 연산을 직접 원소를 이터레이션하지 않고 수행할 수 있다. 시퀀스를 사용하면 중간 결과를 담는 컬렉션을 생성하지 않고도 컬렉션에 대한 여러 연산을 조합할 수 있다. 함수형 인터페이스(추상 메소드가 단 하나뿐인 SAM 인터페이스)를 인자로 받는 자바 함수를 호출할 경우, 람다를 함수형 인터페이스 인자 대신 넘길 수 있다. 수신 객체 지정 람다를 사용하면 람다 안에서 미리 정해둔 수신 객체의 메소드를 직접 호출할 수 있다. with 함수를 사용하면 어떤 객체에 대한 참조를 반복해서 언급하지 않으면서 그 객체의 메소드를 호출할 수 있다. 그리고 이어지는 블록 즉, 람다를 반환한다. apply 함수를 사용하면 어떤 객체라도 빌더 스타일의 API를 사용해 생성하고 초기화할 수 있다. 그리고 수신 객체를 반환한다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"},{"name":"수신 객체 지정 람다","slug":"수신-객체-지정-람다","permalink":"http://victorywoolee/victorywoolee.github.io/tags/수신-객체-지정-람다/"},{"name":"with, apply","slug":"with-apply","permalink":"http://victorywoolee/victorywoolee.github.io/tags/with-apply/"}]},{"title":"[Kotlin] 자바 함수형 인터페이스 활용","slug":"Chap5-4","date":"2019-10-13T06:33:19.000Z","updated":"2019-10-13T07:58:02.238Z","comments":true,"path":"2019/10/13/Chap5-4/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/13/Chap5-4/","excerpt":"","text":"추상 메소드가 단 하나만 있는 인터페이스를 함수형 인터페이스 또는 SAM 인터페이스라고 한다. SAM은 단일 추상 메소드라는 뜻이다. 자바 API에는 Runnable이나 Callable과 같은 함수형 인터페이스와 그런 함수형 인터페이스를 활용하는 메소드가 많다. 코틀린은 함수형 인터페이스를 인자로 취하는 자바 메소드를 호출할 때 람다를 넘길 수 있게 해준다. 따라서 코틀린 코드는 무명 클래스 인스턴스를 정의하고 활용할 필요가 없어 깔끔하고 코틀린다운 코드로 남아있을 수 있다. 자바 8 이전에는 setOnClickListener 메소드에게 인자로 넘기기 위해 무명 클래스의 인스턴스를 만들어서 사용해야만 했다. 123456button.setOnClickListener(new OnClickListener&#123; @Override public void onClick(View v)&#123; ... &#125;&#125;) 같은 구현에 대해서 코틀린에서는 무명 클래스 인스턴스 대신 람다를 넘길 수 있다. 1button.setOnClickListener&#123; view -&gt; ... &#125; 위의 코드가 동작하는 이유는 OnClickListener에 추상 메소드가 단 하나만 있기 때문이다. 관련된 개념과 용어는 서론에서 언급했다. 코틀린은 함수형 인터페이스를 인자로 취하는 자바 메소드를 호출할 때 람다를 넘길 수 있게 해준다. 따라서 코틀린 코드는 무명 클래스 인스턴스를 정의하고 활용할 필요가 없어서 깔끔하고 코틀린다운 코드를 작성할 수 있다. 주의코틀린 함수를 사용할 때는 코틀린 컴파일러가 코틀린 람다를 함수형 인터페이스로 변환해주지 않는다. 코틀린에는 함수 타입이 존재한다. 따라서 코틀린에서 함수를 인자로 받을 필요가 있는 함수는 함수형 인터페이스가 아니라 함수 타입을 인자 타입으로 사용해야 한다. 코틀린은 람다와 무명 객체 사이에 차이가 존재한다. 아래 코드를 보면서 확인해보자. 12345postponeComputation(1000, object : Runnable&#123; override fun run()&#123; println(42) &#125;&#125;) 위의 코드는 객체 식을 함수형 인터페이스 구현으로 넘긴다. 이렇게 객체를 명시적으로 선언하는 경우 메소드를 호출할 때마다 새로운 객체가 생성된다. 1postponeComputation(1000) &#123; println(42) &#125; 위와 같은 람다는 다르다. 람다에 대응하는 무명 객체를 전역으로 만들고 메소드를 호출할 때마다 반복 사용한다. 명시적인 object 선언을 하면서 람다와 동일한 코드를 작성하라면 Runnable 인스턴스를 변수에 저장하고 메소드를 호출할 때마다 그 인스턴스를 사용하게 하면 된다. 1234val runnable = Runnable &#123; println(42) &#125;fun handleComputation()&#123; postponeComputation(1000, runnable)&#125; 람다가 주변 영역의 변수를 포획한다면 매 호출마다 같은 인스턴스를 사용할 수 없다. 그런 경우 컴파일러는 매번 주변 영역의 변수를 포획한 새로운 인스턴스를 생성해준다. 향후에는 별도의 클래스를 만들지 않고 자바 8부터 도입된 람다 기능을 활용한 바이트 코드를 만들어낼 계획이라고 한다. SAM 생성자 람다를 함수형 인터페이스의 인스턴스로 변환할 수 있게 컴파일러가 자동으로 생성한 함수이다. 컴파일러가 자동으로 람다를 함수형 인터페이스 무명 클래스로 바꾸지 못하는 경우 SAM 생성자를 사용할 수 있다. SAM 생성자의 이름은 사용하려는 함수형 인터페이스의 이름과 같다. 함수형 인터페이스의 인스턴스를 반환하는 메소드를 만들고 싶다면, 람다를 직접 반환할 수 없다. 왜냐하면 리턴시 인터페이스에 대한 정보가 없기 때문에 반환하고픈 람다를 SAM 생성자로 감싸야 한다. 함수형 인터페이스의 인스턴스를 변수에 저장해서 사용하고 싶은 경우에도 SAM 생성자를 사용할 수 있다. 람다를 저장하는 방식과 유사한 방법이다. 1234567891011val listener = OnClickListener &#123; view -&gt; val text = when(view.id)&#123; R.id.btn1 -&gt; \"First btn\" R.id.btn2 -&gt; \"Second btn\" else -&gt; \"Unknown btn\" &#125; toast(text)&#125;btn1.setOnClickListener(this)btn2.setOnClickListener(this) 위\u001d의 방식은 SAM 생성자를 통해 람다를 함수형 인터페이스 인스턴스로 만들어 변수에 저장해 활용하는 방법이다. listener는 어떤 버튼이 클릭됐는지에 따라 적절한 동작을 수행한다. OnClickListener를 구현하는 객체 선언을 통해 리스너를 만들 수도 있지만, SAM 생성자를 쓰는 쪽이 더 간결하다. 주의람다에는 무명 객체와 달리 인스턴스 자신을 가리키는 this가 없다. 따라서 람다를 변환한 무명 클래스의 인스턴스를 참조할 방법이 없다. 컴파일러 입장에서 보면 람다는 그저 코드 블록일 뿐이고, 객체가 아니므로 객체처럼 람다를 참조할 수는 없다. 람다 안에서 this는 그 람다를 둘러싼 클래스의 인스턴스를 가리킨다. 그렇기 때문에 이벤트 리스너가 이벤트를 처리하다가 자기 자신의 리스너 등록을 해제해야 한다면 람다를 사용할 수 없다. 그런 경우 람다 대신 무명 객체를 사용해 리스너를 구현해야 한다. SAM 생성자를 사용하면 무명 객체로 변환할 수 있으므로 this가 자기 자신인 무명 객체를 가리킨다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"},{"name":"컬렉션 함수형 API","slug":"컬렉션-함수형-API","permalink":"http://victorywoolee/victorywoolee.github.io/tags/컬렉션-함수형-API/"}]},{"title":"[Kotlin] 지연(Lazy) 계산 컬렉션 연산","slug":"Chap5-3","date":"2019-10-13T04:46:39.000Z","updated":"2019-10-13T06:22:36.397Z","comments":true,"path":"2019/10/13/Chap5-3/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/13/Chap5-3/","excerpt":"","text":"전에 살펴본 map이나 filter 같은 몇가지 컬렉션 함수는 결과 컬렉션을 즉시 생성한다. 이는 컬렉션 함수를 연쇄시켜 사용하면 매 단계마다 계산 중간 결과를 새로운 컬렉션에 임시로 담는것을 뜻한다. 시퀀스를 사용하면 중간 임시 컬렉션을 사용하지 않고도 컬렉션 연산을 연쇄시켜 사용할 수 있다. 1people.map(Person::name).filter &#123; it.startsWith(\"A\") &#125; 코틀린 문서에는 map과 filter가 리스트를 반환한다고 명시되어 있다. 이는 위의 연쇄 호출이 리스트를 2개 만든다는 뜻이다. 한 리스트는 filter의 결과를, 다른 리스트는 map의 결과를 담는다. 원본 리스트의 개수가 적으면 큰 문제가 되지 않지만, 원소가 수백만개가 되면 효율이 떨어진다. 이를 더 효율적으로 만들기 위해서는 각 연산이 컬렉션을 직접 사용하는 대신 시퀀스를 사용하게 만들어야 한다. 1234people.asSequence() .map(Person::name) .filter &#123; it.startsWith(\"A\") &#125; .toList() 위의 코드는 원본 컬렉션을 시퀀스로 변환한다. 그리고 시퀀스도 컬렉션과 똑같은 API를 제공하기 때문에 데이터를 가공할 수 있다. 마지막으로 결과 시퀀스를 다시 리스트로 변환한다. 중간 결과를 저장하는 컬렉션이 생기지 않기 때문에 원소가 많은 경우 성능이 훨씬 좋아진다. Sequence 인터페이스의 강점은 그 인터페이스 위에 구현된 연산이 계산을 수행하는 방법 때문에 생긴다. 시퀀스의 원소는 필요할 때 비로소 계산된다. 따라서 중간 처리 결과를 저장하지 않고도 연산을 연쇄적으로 적용해서 효율적으로 계산을 수행할 수 있다. asSequence 확장 함수를 호출해 컬렉션을 시퀀스로 바꾸고 시퀀스를 리스트로 다시 변환할 때는 toList()를 사용한다. 큰 컬렉션에 대해서 연산을 연쇄시킬 때는 시퀀스를 사용하는 것을 규칙으로 삼아라. 관련된 부분은 뒤에서 조금 더 자세하게 다룰 예정이다. 뒤에서는 중간 컬렉션을 생성함에도 불구하고 코틀린에서 즉시 계산 컬렉션에 대한 연산이 더 효율적인 이유를 설명할 것이다. 하지만, 컬렉션에 들어있는 원소가 많으면 중간 원소를 재배열하는 비용이 커지기 때문에 지연 계산이 더 낫다. 시퀀스 연산 실행 시퀀스에 대한 연산은 중간 연산과 최종 연산으로 나뉜다. 중간 연산 : 다른 시퀀스를 반환한다. 그 시퀀스는 최초 시퀀스의 원소를 변환하는 방법을 알고 있다. 최종 연산 : 결과를 반환한다. 결과는 최초 컬렉션에 대해 변환을 적용한 시퀀스로부터 일련의 계산을 수행해 얻을 수 있는 컬렉션이나 원소, 숫자 또는 객체다. 1sequence.map&#123; ... &#125;.filter &#123; ... &#125;.toList() 위의 예제 코드에서 map과 filter를 적용한 부분이 중간 연산에 해당되고 마지막에 toList를 적용한 부분이 최종 연산에 해당된다. 중간 연산은 항상 지연 계산된다. 아래에서 확인해보자. 123listOf(1,2,3,4).asSequence() .map&#123; print(\"map($it) \") it * it &#125; .filter&#123; print(\"filter($it) \") it % 2 == 0 &#125; 위 코드를 실행하면 결과가 출력되지 않는다. 이는 map과 filter 변환이 늦춰져서 결과를 얻을 필요가 있을 때 즉, 최종 연산이 호출될 때 적용된다는 뜻이다. 그래서 마지막에 toList를 호출해 최종 연산을 수행해주면 다음과 같은 결과를 얻을 수 있다. 1map(1) filter(1) map(2) filter(4) map(3) filter(9) map(4) filter(16) 다음의 코드와 결과를 보고 시퀀스의 연산 순서에 대해서 생각해보자. 1234println(listOf(1,2,3,4).asSequence() .map&#123; it * it &#125; .find&#123; it&gt;3 &#125;)결과:4 같은 연산을 컬렉션에 수행한 경우 map의 결과가 먼저 평가돼어 최초 컬렉션의 모든 원소가 map을 통해서 변환된다. 두 번째 단계에서는 map을 적용해서 얻은 중간 컬렉션으로부터 술어를 만족하는 원소를 찾는다. 같은 연산을 시퀀스를 적용한 경우 지연 계산으로 인해 모든 연산은 각 원소에 대해 순차적으로 적용된다. 즉, 첫 번째 원소가 변환된 다음에 filter를 통해 걸러지는 처리가 되고 다시 두 번째 원소가 처리되며, 이와 같은 처리가 모든 원소에 대해 적용된다. 따라서 지연 계산으로 인해 원소 중 일부의 계산은 이뤄지지 않는다. 아래 결과는 즉시 계산과 지연 계산을 수행했을 때의 결과를 보여준다. 위에서 확인할 수 있듯이 컬렉션을 사용하면 리스트가 다른 리스트로 변환된다. 그래서 map 연산은 3,4를 포함해 모든 원소를 변환한다. 그 후 find가 술어를 만족하는 첫 번째 원소인 4를 찾는다. 시퀀스를 사용하면 find 호출이 원소를 하나씩 처리하기 시작한다. 최초 시퀀스로부터 수를 하나 가져와서 map에 지정된 변환을 수행한 다음에 find에 지정된 술어를 만족하는지 검사한다. 그래서 결과를 찾으면 남은 원소에 대해 연산을 하지 않아도 된다. 컬렉션에 대해 수행하는 연산의 순서도 성능에 영향을 끼친다. 다음의 코드를 보면 확실하게 알 수 있다. 아래는 이름이 어떤 길이보다 짧은 사람의 명단을 얻고 싶은 코드이다. map과 filter를 적용하는데 순서에 따라서 성능의 차이가 있다. 1234567891011121314val people = listOf(Person(\"Lee\",26), Person(\"Kim\",35), Person(\"Bob\",31),Person(\"Park\",30))// 1. map 다음에 filter 수행println(people.asSequence() .map(Person::name) .filter &#123; it.length &lt; 4 &#125; .toList())결과 : [Lee, Kim, Bob]// 2. filter 다음에 map 수행println(people.asSequence() .filter &#123; it.length &lt; 4 &#125; .map(Person::name) .toList())결과 : [Lee, Kim, Bob] map을 먼저 하면 모든 원소를 변환한다. 하지만, filter를 먼저 하면 부적절한 원소를 먼저 제외하기 때문에 그런 원소는 변환되지 않으며, 변환 횟수가 줄어들어 성능상 이점을 갖는다. 자바 스트림과 코틀린 시퀀스 비교 자바 8 스트림이 코틀린 시퀀스와 비슷한 개념으로 보인다. 코틀린에서 같은 개념을 따로 구현해 제공하는 이유는 안드로이드 등에서 예전 버전의 자바를 사용하는 경우 자바 8에 있는 스트림이 없기 때문이다. 또한, 자바 8을 사용하면 현재 코틀린 컬렉션과 시퀀스에서 제공하지 않는 중요한 기능을 사용할 수 있다. 스트림 연산을 여러 CPU에서 병렬적으로 실행하는 기능이다. 필요에 따라서 적절하게 선택하면 된다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"},{"name":"컬렉션 함수형 API","slug":"컬렉션-함수형-API","permalink":"http://victorywoolee/victorywoolee.github.io/tags/컬렉션-함수형-API/"}]},{"title":"[Kotlin] 컬렉션 함수형 API","slug":"Chap5-2","date":"2019-10-12T08:31:25.000Z","updated":"2019-10-13T04:46:23.504Z","comments":true,"path":"2019/10/12/Chap5-2/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/12/Chap5-2/","excerpt":"","text":"이번에는 함수형 프로그래밍과도 관련이 있는 내용을 배울 것이다. 컬렉션을 사용할 때 아주 편리하게 사용할 수 있는 것들도 있다. 함수형 프로그래밍에서는 람다나 다른 함수를 인자로 받거나 함수를 반환하는 함수를 고차 함수라고 한다. 고차 함수는 기본 함수를 조합해서 새로운 연산을 정의하거나, 다른 고차 함수를 통해 조합된 함수를 또 조합해서 더 복잡한 연산을 쉽게 정의할 수 있다는 장점이 있다. 이런 식으로 고차 함수와 단순한 함수를 조합해서 코드를 작성하는 기법을 컴비네이터 패턴이라고 브르고, 이 패턴에서 복잡한 연산을 만들기 위해 값이나 함수를 조합할 때 사용하는 고차 함수를 컴비네이터라 한다. 필수적인 함수1. filter filter : 컬렉션을 이터레이션(반복)하면서 주어진 람다에 각 원소를 넘겨서 람다가 true를 반환하는 원소만 모은다. 즉, 필터로 true를 반환하는 원소만 모은다. 결과는 입력 컬렉션의 원소 중에서 주어진 술어(참, 거짓을 반환하는 함수를 술어라고 한다.)를 만족하는 원소만으로 이뤄진 새로운 컬렉션이다. filter는 컬렉션에서 원치 않는 원소를 제거한다. 2. map map : 주어진 람다를 컬렉션의 각 원소에 적용한 결과를 모아서 새 컬렉션을 만든다. 즉, 값을 변환해주는 함수이다. map 함수는 어떤 값을 다른 타입 혹은 값으로 변환하고자 할 때 유용하게 사용할 수 있다. 이런 메소드는 멤버 참조도 적용할 수 있고 연쇄적으로 호출할 수 있다는 장점이 있다. 아래는 나이가 30살 이상인 사람의 이름을 출력하는 구문이다. 1people.filter&#123; it.age &gt; 30 &#125;.map(Person::name) 다음은 목록에서 가장 나이 많은 사람의 이름을 알고 싶다. 먼저, 목록에 있는 사람들의 나이의 최댓값을 구하고 나이가 그 최댓값과 같은 모든 사람을 반환하면 된다. 1people.filter &#123; it.age == people.maxBy(Person::age)!!.age &#125; 하지만, 위의 코드는 최댓값을 구하는 작업을 반복한다는 단점이 있다. 100명이 있다면 100번 최댓값을 찾는 연산을 반복한다. 따라서 아래처럼 미리 변수로 찾아놓은 후 filter에서 비교하는 편이 좋다. 꼭 필요하지 않은 경우 굳이 계산을 반복하지 않는게 좋다. 람다를 인자로 받는 함수에 람다를 넘기면 겉으로 볼 때는 단순해 보이는 식이 내부 로직의 복잡도로 인해 실제로는 엄청나게 불합리한 계산식이 될 때가 있다. 따라서 코드를 작성할 때 어떤 일을 하는지 명확히 이해해야 한다. 12val maxAge = people.maxBy(Person::age)!!.agepeople.filter &#123; it.age == maxAge &#125; all, any, count, find 함수 컬렉션에 대해 자주 수행하는 연산으로 컬렉션의 모든 원소가 어떤 조건을 만족하는지 판단하거나 컬렉션 안에 어떤 조건을 만족하는 원소가 있는지 판단하는 연산들이 있다. all : 컬렉션 안에 있는 모든 원소가 어떤 조건을 만족하는지 판단한다. any : 컬렉션 안에 있는 어떤 원소가 어떠한 조건을 만족하는지 판단한다. count : 조건을 만족하는 원소의 개수를 반환 find : 조건을 만족하는 첫 번째 원소를 반환 (조건을 만족하는 원소가 하나라도 있는 경우, 가장 먼저 조건을 만족한다고 확인된 원소를 반환) find는 firstOrNull과 같다. 조건을 만족하는 원소가 없으면 null이 나온다. 함수를 적재적소에 사용하라: count와 size count가 있지만, size가 익숙해서 자주 사용할 수 있다. 그래서 컬렉션을 필터링한 결과의 크기를 가져올 때 아래처럼 사용한다. 12println(people.filter(canBeInClub27).size)결과:1 하지만 이렇게 처리하면 조건을 만족하는 모든 원소가 들어가는 중간 컬렉션이 생긴다. 반면, count는 조건을 만족하는 원소의 개수만을 추적하지 조건을 만족하는 원소를 따로 저장하지 않는다. 따라서 count가 훨씬 효과적이다. groupBy 리스트를 여러 그룹으로 이루어진 맵으로 변경한다. 컬렉션의 모든 원소를 어떤 특성에 따라 여러 그룹으로 나누고 싶을 때 사용하면 좋다. 123val people = listOf(Person(\"lee\", 26), Person(\"kim\", 25), Person(\"Bob\",30), Person(\"Carol\",31))println(people.groupBy&#123; it.age &#125;) 위 연산의 결과는 컬렉션의 원소를 구분하는 특성이 age가 되며 키이다. 그리고 키 값에 따른 각 그룹이 값인 맵이다. 여기서는 Person 객체의 모임이다. age를 키 값으로 하며, 키에 따라서 그룹으로 분류된 리스트가 존재한다. 각 그룹은 리스트다. 따라서 groupBy의 결과 타입은 Map&lt;Int, List&gt;이다. flatMap, flatten 중첩된 컬렉션 안의 원소 처리 flatMap : 인자로 주어진 람다를 컬렉션의 모든 객체에 적용하고(또는 매핑하고) 람다를 적용한 결과 얻어지는 여러 리스트를 한 리스트로 한데 모은다. 다음의 예를 확인해보자.12345val books = listOf(Book(\"Thursday Next\", listOf(\"Jasper Fforde\")), Book(\"Mort\", listOf(\"Terry Pratchett\")), Book(\"Good Omens\", listOf(\"Terry Pratchett\",\"Neil Gaiman\")))println(books.flatMap &#123; it.authors &#125;.toSet())결과 : [Jasper Fforde, Terry Pratchett, Neil Gaiman] 위의 코드에서 책을 여러 작가가 함께 쓸 수도 있다. book.authors 프로퍼티는 작가를 모아둔 컬렉션이다. flatMap 함수는 모든 책의 작가를 평평한 리스트 하나로 모은다. 그리고 toSet은 flatMap의 결과 리스트에서 중복을 없애고 집합으로 만든다. 따라서 최종 출력에서는 Terry Pratchett를 한 번만 볼 수 있다. 리스트의 리스트가 있는데 모든 중첩된 리스트의 원소를 한 리스트로 모아야 한다면(위의 경우처럼) flatMap을 떠올릴 수 있을 것이다. 하지만, 특별히 변환해야 할 내용이 없다면 리스트의 리스트를 평ㄹ평하게 펼치기만 하면 된다. 그런 경우에는 listOfLists.flatten()처럼 flatten() 함수를 사용할 수 있다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"},{"name":"컬렉션 함수형 API","slug":"컬렉션-함수형-API","permalink":"http://victorywoolee/victorywoolee.github.io/tags/컬렉션-함수형-API/"}]},{"title":"[Android] SDK란?","slug":"Android-SDK","date":"2019-10-12T08:31:19.000Z","updated":"2019-10-19T03:13:12.994Z","comments":true,"path":"2019/10/12/Android-SDK/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/12/Android-SDK/","excerpt":"","text":"간단한 개념을 정리하기 위한 공간입니다. SDK란? Android SDK : Android Software Development Kit의 약자이다. 즉, 안드로이드 소프트웨어를 개발하기 위한 툴 킷을 의미한다. 구체적으로는 아래와 같은 것들이 포함된다. 안드로이드 API 안드로이드 개발을 보다 더 쉽게 하도록 접근을 허용하는 안드로이드 API들 안드로이드 응용 프로그램 개발에 필요한 각종 도구들 안드로이드 소스 코드를 실행 가능한 어플리케이션으로 만들기 위한 컴파일러나 에뮬레이터 등 샘플 코드들 안드로이드 API 사용법을 이해시키기 위한 예제 코드들 관련 문서 SDK를 사용하기 위한 각종 패키지나 클래스에 대한 설명 등 API란? API : Application Programming Interface의 약자로, 앱을 개발하기 위한 규칙이다. 앱에서 사용할 수 있도록 운영체제나 프로그래밍 언어가 제공하는 기능을 제어할 수 있게 만든 인터페이스, 개발자를 위한 인터페이스 운영체제가 응용프로그램을 위해 제공하는 함수의 집합으로 응용프로그램과 디바이스를 연결해주는 역할을 한다.","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"SDK","slug":"SDK","permalink":"http://victorywoolee/victorywoolee.github.io/tags/SDK/"},{"name":"개념","slug":"개념","permalink":"http://victorywoolee/victorywoolee.github.io/tags/개념/"}]},{"title":"[Kotlin] 람다","slug":"Chap5-1","date":"2019-10-12T06:22:11.000Z","updated":"2019-10-12T08:29:44.419Z","comments":true,"path":"2019/10/12/Chap5-1/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/12/Chap5-1/","excerpt":"","text":"람다 또는 람다 식은 기본적으로 다른 함수에 넘길 수 있는 작은 코드 조각을 의미한다. 람다를 사용하면 쉽게 공통 구조를 라이브러리 함수로 뽑아낼 수 있다. 주로 컬렉션 처리에서 많이 사용된다. 람다 식이 유용한 예제를 하나 살펴보고 문법에 대해서 알아보자. 사람들로 이뤄진 리스트가 있고 그 중에서 연장자를 찾아보자. 12345678910111213141516171819data class Person(val name: String, val age: Int)fun findTheOldest(people: List&lt;Person&gt;)&#123; var maxAge: Int=0 var theOldest: Person?=null for(person in people)&#123; if(person.age &gt; maxAge)&#123; maxAge = person.age theOldest = person &#125; &#125; println(theOldest)&#125;val people = listOf(Person(\"Lee\", 26),Person(\"Jung\",23))findTheOldest(people)Person(name=Lee,age=26) 코틀린을 썼지만, 자바처럼 작성했다. 그리고 코드가 길어진다. 코틀린에서는 훨씬 줄여서 쓸 수 있다. 123val people = listOf(Person(\"Lee\", 26),Person(\"Jung\",23))println(people.maxBy&#123;it.age&#125;)Person(name=Lee, age=26) 코드가 이전에 비해 훨씬 짧아진 것을 확인할 수 있다. maxBy 함수는 모든 컬렉션에 대해 호출할 수 있다. 또한, 단지 함수나 프로퍼티를 반환하는 역할을 수행하는 람다는 멤버 참조로 대치할 수 있다. 1people.maxBy(Person::age) 이처럼 람다 식을 사용하면 함수의 가독성을 높여준다. 그리고 코드가 더 짧아지며 이해하기가 쉽다. 람다 식의 문법 람다는 값처럼 여기저기 전달할 수 있는 동작의 모임이다. 람다를 따로 선언해서 변수에 저장할 수도 있지만, 함수에 인자로 넘기면서 바로 람다를 정의하는 경우가 대부분이다. 1&#123; x: Int, y: Int -&gt; x + y &#125; 람다 식은 중괄호로 둘러싸여 있으며, 인자 목록 주변에 괄호가 없다. -&gt; (화살표)가 인자 목록과 람다 본문을 구분해준다. 또한, 람다 식을 변수에 저장할 수 있으며, 저장된 변수를 다른 일반 함수처럼 다룰 수 있다. 람다 호출에는 부가 비용이 들지 않는다. 기본 구성 요소와 비슷한 성능을 낸다. 12val sum = &#123; x: Int, y: Int -&gt; x + y &#125;println(sum(1,2)) 도입부에서 살펴본 예제를 다시 확인해보자. 정식으로 람다를 작성하면 아래와 같은 코드이다. 1people.maxBy(&#123;p: Person -&gt; p.age&#125;) 중괄호 안에 있는 코드는 람다 식일고 그 람다 식을 maxBy 함수에 넘긴다. 람다 식은 Person 타입의 값을 인자로 받아서 인자의 age를 반환한다. 의미는 알겠지만,코드가 번잡하다. 우선 구분자가 많아 가독성이 떨어진다. 그리고 컴파일러가 문맥으로부터 유추할 수 있는 인자 타입을 굳이 적을 필요는 없다. 마지막으로 인자가 단 하나뿐인 경우 굳이 인자에 이름을 붙이지 않아도 된다. 그럼 위의 코드를 조금 더 깔끔한 람다 식으로 개선해보자. 코틀린에서는 함수 호출 시 맨 마지막 인자라 람다 식이라면 람다를 괄호 밖으로 뺄 수 있다. 1people.maxBy() &#123;p: Person -&gt; p.age&#125; 이처럼 람다가 어떤 함수의 유일한 인자이고 괄호 뒤에 람다를 썼다면 호출 시 빈 괄호를 없애도 된다. 1people.maxBy&#123;p: Person -&gt; p.age&#125; 이제 타입을 없애면 된다. 컴파일러가 타입을 유추할 수 있다면 굳이 명시할 필요가 없다. maxBy 함수의 경우 파라미터의 타입은 항상 컬렉션의 원소 타입과 같다. 1people.maxBy &#123; p -&gt; p.age &#125; 마지막으로 람다의 파라미터가 하나뿐이고 컴파일러가 그 타입을 추론할 수 있는 경우 it을 사용해 더 간결하게 코드를 작성할 수 있다. 1people.maxBy&#123; it.age &#125; Tipit은 람다 파라미터의 이름을 따로 지정하지 않은 경우에 자동으로 만들어지는 이름이다. 이는 코드를 아주 간단하게 만들어준다. 하지만, 남용하면 안된다. 특히 람다 안에 람다가 중첩되는 경우, 각 람다의 파라미터를 명시하는 편이 낫다. 파라미터를 명시하지 않으면 각각의 it이 가리키는 파라미터가 어떤 람다에 속했는지 파악하기 어려울 수 있다. 문맥에서 람다 파라미터의 의미나 파라미터의 타입을 쉽게 알 수 없는 경우에 파라미터를 명시적으로 선언하면 도움이 된다. 람다를 변수에 저장할 때는 파라미터의 타입을 추론할 문맥이 존재하지 않기 때문에 파라미터 타입을 명시해야 한다. 12val getAge = &#123;p: Person -&gt; p.age&#125;people.maxBy(getAge) 현재 영역에 있는 변수에 접근 람다를 함수 안에서 정의하면 함수의 파라미터뿐 아니라 람다 정의의 앞에 선언된 로컬 변수까지 람다에서 모두 사용할 수 있다. 자바와 다른 점 중 중요한 한가지는 코틀린 람다 안에서는 파이널 변수가 아닌 변수에 접근할 수 있다는 것이다. 또한 람다 안에서 바깥 변수를 변경해도 된다. 123456789101112131415161718fun printMessage(responses: Collection&lt;String&gt;)&#123; var clientErrors=0 var serverErrors=0 responses.forEach &#123; if(it.startsWith(\"4\"))&#123; clientErrors++ &#125;else if(it.startsWith(\"5\"))&#123; serverErrors++ &#125; &#125; println(\"$clientErrors client errors, $serverErrors server errors\")&#125;val responses = listOf(\"200 OK\", \"418 I'm a teapot\", \"500 Internal Server Error\")printMessage(responses)결과 : 1 client errors, 1 server errors 위에서 살펴본 prefix, clientErrors, serverErrors와 같이 람다 안에서 사용하는 외부 변수를 람다가 포획한 변수라고 부른다. 기본적으로 함수 안에 정의된 로컬 변수의 생명주기는 함수가 반환되면 끝난다. 하지만, 어떠 함수가 자신의 로컬 변수를 포획한 람다를 반환하거나 다른 변수에 저장한다면 로컬 변수의 생명주기와 함수 생명주기가 달라질 수 있다. 포획한 람다를 저장해서 함수가 끝난 뒤에 실행해도 람다의 본문 코드는 여전히 포획한 변수를 읽거나 쓸 수 있다. 파이널 변수를 포획한 경우에는 람다 코드를 변수 값과 함께 저장한다. 파이널이 아닌 변수를 포획한 경우에는 변수를 특별한 래퍼로 감싸서 나중에 변경하거나 읽을 수 있게 한 다음, 래퍼에 대한 참조를 람다 코드와 함께 저장한다. 멤버 참조 함수를 값으로 바꿀 수 있다. 이때 이중 콜론(::)을 사용한다. ::를 사용하는 식은 멤버 참조라고 부른다. 멤버 참조는 프로퍼티나 메소드를 단 하나만 호출하는 함수 값을 만들어준다. 아래 두 문장은 같은 식이다. 멤버 참조를 사용하는지와 람다 식을 사용하는지 차이만 있을 뿐이다. 또한, 최상위에 선언된(다른 클래스의 멤버가 아닌) 함수나 프로퍼티를 참조할 수도 있다. 1234567val getAge = Person::ageval getAge = &#123;p: Person -&gt; p.age&#125;fun salute() = println(\"Salute!!\")run(::salute)결과 : Salute!! 람다가 인자가 여럿인 다른 함수한테 작업을 위임하는 경우에 람다를 정의하지 않고 직접 위임 함수에 대한 참조를 제공하면 편리하다. 12345val action = &#123; person: Person, message: String -&gt; sendMail(person, message) &#125;val action = ::sendMail 또한, 생성자 참조를 사용하면 클래스 생성 작업을 연기하거나 저장해 둘 수도 있다. :: 뒤에 클래스 이름을 넣으면 생성자 참조를 만들 수 있다. 123456data class Person(val name: String, val age: Int)val createPerson = ::Person // Person의 인스턴스를 만드는 동작을 변수에 할당함으로써 값으로 저장한다.val p = createPerson(\"Lee\",26)println(p)결과 : Person(name=Lee, age=26) 확장 함수도 멤버 참조를 사용할 수 있다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"},{"name":"람다","slug":"람다","permalink":"http://victorywoolee/victorywoolee.github.io/tags/람다/"}]},{"title":"[Kotlin] object 키워드","slug":"Chap4-4","date":"2019-10-09T13:16:26.000Z","updated":"2019-10-12T05:50:12.989Z","comments":true,"path":"2019/10/09/Chap4-4/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/09/Chap4-4/","excerpt":"","text":"object 키워드를 다양한 상황에서 사용하지만, 모든 경우 클래스를 정의하면서 동시에 인스턴스를 생성한다는 공통점이 있다. object를 사용하는 상황을 다음과 같다. 싱글톤을 정의할 때 object를 사용한다. companion object(동반 객체)는 인스턴스 메소드는 아니지만, 어떤 클래스와 관련있는 메소드와 팩토리 메소드를 담을 때 주로 쓰인다. 동반 객체가 포함된 클래스 이름을 사용해 접근할 수 있다. 객체 식은 자바의 익명 내부 클래스 대신 쓰인다. 객체 선언 : 싱글톤 객체 선언을 통해 싱글톤을 언어에서 기본으로 지원한다. 객체 선언 = 클래스 선언 + 클래스에 속한 단일 인스턴스의 선언 123456789object Payroll&#123; val allEmployee = arrayListOf&lt;Person&gt;() fun calculateSalary()&#123; for(person in allEmployee)&#123; // 생략. &#125; &#125;&#125; 객체 선언은 object 키워드로 시작한다. 객체 선언은 클래스를 정의하고 그 클래스의 인스턴스를 만들어서 변수에 저장하는 모든 작업을 한 문장으로 수행한다. 클래스와 마찬 가지로 객체 선언(object) 안에도 프로퍼티, 메소드, 초기화 블록 등이 들어갈 수 있지만, 생성자는 쓸 수 없다. 이유는 일반 클래스 인스턴스와 달리 싱글톤 객체는 객체 선언문이 있는 위치에서 생성자 호출 없이 즉시 만들어지기 때문이다. 따라서 객체 선언(object)에는 생성자 정의가 필요 없다. 객체 선언도 클래스나 인스턴스를 상속할 수 있다. 일반 객체를 사용할 수 있는 곳에서는 항상 싱글톤 객체를 쓸 수 있다. 클래스 안에서 객체 선언을 할 수도 있다. 그런 객체도 인스턴스는 단 하나뿐이다.(즉, 바깥 클래스의 인스턴스마다 중첩 객체 선언에 해당하는 인스턴스가 하나씩 따로 생기는 것이 아니다.) 동반 객체 companion object라고 하며, 동반 객체라고도 부른다. 코틀린에는 자바에서의 static과 같은 개념이 없다. 그래서 정적인 멤버가 없다. 그래서 패키지 수준의 최상위 함수(자바의 정적 메소드 역할을 거의 대신한다.)와 객체 선언(자바의 정적 메소드 역할 중 코틀린 최상위 함수가 대신할 수 없는 역할이나 정적 필드를 대신할 수 있다.)을 활용한다. 대부분의 경우 최상위 함수를 활용하는 편은 더 권장한다. 최상위 함수는 클래스의 private 멤버에 접근할 수 없다. 클래스의 인스턴스와 상관없이 호출해야 하지만, 클래스 내부 정보에 접근해야 하는 함수가 필요할 때는 클래스에 중첩된 객체 선언의 멤버 함수로 정의해야 한다. 클래스 안에 정의된 객체에 companion 키워드를 붙이면 동반 객체로 만들 수 있다. 동반 객체의 프로퍼티, 메소드에 접근하기 위해서는 클래스 이름.동반 객체로 접근하면 된다. 이때 객체의 이름을 따로 지정하지 않아도 된다. 동반 객체는 자신을 둘러싼 클래스의 모든 private 멤버에 접근할 수 있다. 따라서 팩토리 패턴을 구현하기 적합하다. 아래는 이전에 예제로 다뤄봤던 코드이다. 두 클래스를 하나로 합치면서 사용자 객체를 여러가지 방법으로 제공한다. 12345678910class User &#123; val nickname: String constructor(email: String)&#123; nickname = email.substringBefore('@') &#125; constructor(facebookAccountId: Int)&#123; nickname = getFacebookName(facebookAccountId) &#125;&#125; 위의 로직을 좀 더 유용한 방법으로 표현하기 위해서 팩토리 패턴을 사용해보자. 생성자를 통해 객체를 생성할 수 없고 팩토리 메소드를 사용해야 한다. 123456789class User private constructor(val nickname: String)&#123; companion object&#123; fun newSubscribingUser(email: String) = User(email.substringBefore('@')) fun newFacebookUser(facebookAccountId: Int) = User(getFacebookName(facebookAccountId)) &#125;&#125; 동반 객체를 일반 객체처럼 사용 동반 객체는 클래스 안에 정의된 일반 객체다. 따라서 이름을 붙일 수도 있고, 인터페이스를 상속하거나, 동반 객체 안에 확장 함수와 프로퍼티를 정의할 수도 있다. 이름을 정의하지 않으면 동반 객체의 이름은 자동으로 Companion이 된다. 동반 객체에서 인터페이스 구현 동반 객체에서 인터페이스를 구현할 수 있다. 다음 코드를 확인해보자. 123456789interface JSONFactory&lt;T&gt;&#123; fun fromJSON(jsonText: String): T&#125;class Person(val name: String)&#123; companion object : JSONFactory&lt;Person&gt;&#123; override fun fromJSON(jsonText: String): Person = ... &#125;&#125; 동반 객체가 인터페이스를 구현하고 JSON으로부터 각 원소를 다시 만들어내는 추상 팩토리가 있다고 가정하면 Person 객체를 그 팩토리에게 쉽게 넘길 수 있다. 12345fun loadFromJSON&lt;T&gt; (factory: JSONFactory&lt;T&gt;) : T&#123; ...&#125;loadFromJSON(Person) 여기서 동반 객체가 구현한 JSONFactory의 인스턴스를 넘길 때 Person 클래스의 이름을 그대로 사용할 수 있다. 동반 객체는 일반 객체와 비슷한 방식으로 클래스에 정의된 인스턴스를 가리키는 정적 필드로 컴파일된다. 동반 객체 확장 확장 함수를 사용하는 것의 장점은 코드 기반의 다른 곳에서 정의된 클래스의 인스턴스에 대해 새로운 메소드를 정의할 수 있다는 것이다. 이 방법을 동반 객체에도 적용할 수 있다. 위에서 살펴본 Person의 관심사를 좀 더 명확하게 분리해보자. Person 클래스는 핵심 비즈니스 로직 모듈의 일부다. 하지만, 특정 데이터 타입에 의존하기를 원하지 않는다. 역직렬화 함수를 비즈니스 모듈이 아닌 클라이언트/서버 통신을 담당하는 모듈 안에 포함시키고 싶다. 1234567891011class Person(val name: String)&#123; companion object&#123; // 비어있는 동반 객체. &#125;&#125;fun Person.Companion.fronJSON(json: String): Person&#123; // 확장 함수를 선언.&#125;val p = Person.fromJSON(json) 이렇게 확장 함수를 정의함으로써 동반 객체 안에 fronJSON 함수를 정의한 것처럼 호출할 수 있다. 실제로 fromJSON 함수를 클래스 밖에 정의한 확장 함수이다. 동반 객체에 대한 확장 함수를 정의하기 위해서는 클래스 안에 비어있더라도 동반 객체를 선언해줘야 한다. 객체 식: 무명 내부 클래스를 다른 방식으로 작성 object 키워드는 무명 객체를 정의할 때도 사용된다. 무명 객체는 자바의 무명 내부 클래스를 대신한다. 안드로이드에서는 흔히 사용하는 이벤트 리스너가 한 예가 될 수 있다. 123456789window.addListener(object : Adapter()&#123; override fun mouseClicked(e: Event)&#123; ... &#125; override fun mouseEntered(e: Event)&#123; ... &#125;&#125;) 객체 식은 클래스를 정의하고 그 클래스에 속한 인스턴스를 생성한다. 하지만, 클래스나 인스턴스에 이름을 붙이지 않는다. 이 점이 object 키워드를 싱글톤 선언할 때 사용하는 방식과 다른 점이다. 보통 함수를 호출하면서 인자로 무명 객체를 넘기기 때문에 클래스와 인스턴스 모두 이름이 필요하지 않다. 하지만, 이름이 필요하다면 변수에 무명 객체를 할당해서 사용하면 된다. 무명 클래스는 여러 인터레이스를 구현하거나 클래스를 확장하면서 인터페이스를 구현할 수 있다. 객체 선언과 달리 무명 객체는 싱글톤이 아니다. 객체 식이 쓰일 때마다 새로운 인스턴스가 생성된다. 요약 인터페이스는 자바와 비슷하지만, 디폴트 구현을 포함할 수 있고, 프로퍼티도 포함할 수 있다. 모든 코틀린 선언은 기본적으로 final이며 public이다. final이 되지 않게 하려면 open을 붙여 변경하면 된다. 이를 통헤 상속과 오버라이딩이 가능하다. internal 선언은 같은 모듈 안에서만 볼 수 있다. 중첩 클래스는 기본적으로 내부 클래스가 아니다. 바깥쪽 클래스에 대한 참조를 중첩 클래스 안에 포함시키기 위해서는 inner 키워드를 중첩 클래스 앞에 붙여 내부 클래스로 만들어야 한다. sealed 클래스를 상속하는 클래스를 정의하려면 반드시 부모 클래스 정의 안에 중첩(또는 내부) 클래스로 선언하거나 같은 파일 안에 위치시키면 된다. 초기화 블록 init과 부 생성자 constructor를 사용하면 클래스 인스턴스를 더 유연하게 초기화할 수 있다. data class를 사용하면 컴파일러가 자동으로 equals, toString, hashCode, copy 등의 메소드를 생성해준다. field 식별자를 통해 프로퍼티 접근자인 게터와 세터 안에서 프로퍼티의 데이터를 저장하는 데 쓰이는 뒷받침하는 필드를 참조할 수 있다. 클래스 위임을 사용하면 위임 패턴을 구현할 때 필요한 준비 코드를 줄여 간단하게 코드를 구성할 수 있다. 객체 선언 object를 사용해 싱글톤 패턴을 구현할 수 있다. 동반 객체인 companion object는 자바의 정적 메소드와 필드 정의를 대신한다. 동반 객체도 객체이므로 인터페이스를 구현할 수 있으며, 외부에서 동반 객체에 대한 확장 함수와 프로퍼티를 정의할 수 있다. 객체 식인 object는 자바의 무명 내부 클래스를 대신한다. 하지만, 코틀린 객체 식은 여러 인스턴스를 구현하거나 객체가 포함된 영역에 있는 변수의 값을 변경할 수 있는 등 자바보다 더 많은 기능을 제공한다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"},{"name":"object","slug":"object","permalink":"http://victorywoolee/victorywoolee.github.io/tags/object/"}]},{"title":"[Kotlin] 데이터 클래스와 클래스 위임","slug":"Chap4-3","date":"2019-10-09T09:00:04.000Z","updated":"2019-10-09T12:19:02.945Z","comments":true,"path":"2019/10/09/Chap4-3/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/09/Chap4-3/","excerpt":"","text":"모든 클래스가 정의해야 하는 메소드 자바와 마찬가지로 코틀린 클래스도 toString, equals, hashCode 등을 오버라이드할 수 있다. 그리고 코틀린은 이런 메소드 구현을 자동으로 생성해 줄 수 있다. 한 가지 예를 통해서 이 메소드가 어떤 것인지에 대해 알아보자. 1class Client(val name: String, val postalCode: Int) 1. 문자열 표현: toString() 코틀린도 클래스 인스턴스의 문자열 표현을 얻을 방법을 제공하며 주로 디버깅과 로깅 시 해당 메소드를 사용한다. 기본 제공되는 방법은 객체 자체를 보여주기 때문에 toString을 오버라이드해서 기본 구현을 바꿔야 한다. 기본 문자열 표현을 바꿈으로써 더 많은 정보를 얻을 수 있다. 123class Client(val name: String, val postalCode: Int)&#123; override fun toString() = \"Client(name=$name, postalCode=$postalCode)\"&#125; 2. 객체의 동등성: equals() 서로 다른 두 객체가 내부에 동일한 데이터를 포함하는 경우 그 둘을 동등한 객체로 간주해야 할 수도 있다. 코틀린에서 == 연산자는 자바와 달리 참조 동등성을 검사하지 않고 객체의 동등성을 검사한다. 따라서 == 연산은 equals()를 호출하는 식으로 컴파일된다. 동등성 연산에 ==를 사용한다. 자바에서는 ==를 원시 타입과 참조 타입을 비교할 때 사용한다. 원시 타입의 경우 ==는 두 피연산자의 값이 같은지 비교한다.(동등성) 반면, 참조 타입의 경우 ==는 두 피연산자의 주소가 같은지를 비교한다.(참조 비교) 따라서 자바에서는 두 객체의 동등성을 알려면 equals()를 호출해야 한다. 코틀린에서는 == 연산자가 두 객체를 비교하는 가장 기본적인 방법이다. ==는 내부적으로 equals()를 호출해서 객체를 비교한다. 즉, 대상 내용 자체를 비교한다. 따라서 equals를 오버라이드하면 ==를 통해 안전하게 그 클래스의 인스턴스를 비교할 수 있다. 참조 비교를 위해서는 === 연산자를 사용할 수 있다. === 연산자는 자바에서 객체의 참조를 비교할 때 사용하는 == 연산자와 같다. 3. 해시 컨테이너: hashCode() 자바에서는 equals를 오버라이드할 때, hashCode도 함께 오버라이드 해야한다. JVM 언어에서는 hashCode가 지켜야 하는 제약이 있다. equals()가 true를 반환하는 두 객체는 반드시 같은 hashCode()를 반환해야 한다 processed 집합은 HashSet이다. HashSet은 원소를 비교할 때, 비용을 줄이기 위해 먼저 객체의 해시 코드를 비교하고 해시 코드가 같은 경우에만 실제 값을 비교한다. 아래의 두 Client 인스턴스는 해시 코드가 다르기 때문에 두 번째 인스턴스가 집합 안에 들어있지 않다고 판단한다. 해시 코드가 다를 때 equals()가 반환하는 값은 판단 결과에 영향을 끼치지 못한다. 즉, 원소 객체들이 해시 코드에 대한 규칙을 지키지 않는 경우, HashSet은 제대로 작동할 수 없다. 이 문제를 해결하기 위해서는 hashCode를 직접 구현하면 된다. 123val processed = hashSetOf(Client(\"이승우\", 9406))println(processed.contains(Client(\"이승우\", 9406)))// 결과 : false 위에서 살펴봤던 메소드를 코틀린 컴파일러는 자동으로 생성해준다. 데이터 클래스 코틀린에서 제공하는 data class는 data라는 변경자를 class 앞에 붙이면 된다. 이는 다음과 같은 메소드를 컴파일러 자동으로 만들어준다. 인스턴스 간 비교를 위한 equals HashMap과 같은 해시 기반 컨테이너에서 키로 사용할 수 있는 hashCode 클래스의 각 필드를 선언 순서대로 표시하는 문자열 표현을 만들어주는 toString 데이터 클래스와 불변성 copy equals와 hashCode는 주 생성자에 나열된 모든 프로퍼티를 고려해 만들어진다. 이때 주 생성자 밖에 정의된 프로퍼티는 equals나 hashCode를 계산할 때 고려의 대상이 되지 않는다. 데이터 클래스와 불변성 : copy() 코틀린 컴파일러가 생성해주는 메소드 중 하나이다. 데이터 클래스의 프로퍼티가 꼭 val일 필요는 없다. var 프로퍼티를 써도 되지만, 데이터 클래스의 모든 프로퍼티를 읽기 전용(val)으로 만들어서 불변 클래스로 만들라고 권장한다. HashMap 등의 컨테이너에 데이터 클래스 객체를 담는 경우에는 불변성이 필수적이다. data class 객체를 키로 하여 컨테이너에 담은 후 키로 쓰인 data class 객체의 프로퍼티를 변경할 경우에 컨테이너 상태가 잘못될 수 있기 때문이기도 하다. 또한, 불변 객체를 사용하면 프로그램에 대해 훨씬 쉽게 추론할 수 있다. 특히 다중스레드 프로그램의 경우 이런 성질은 더욱 중요하다. 불변 객체를 주로 사용하는 프로그램에서는 스레드가 사용 중인 데이터를 다른 스레드가 변경할 수 없으므로 스레드 동기화의 필요성이 줄어든다. data class 인스턴스를 불변 객체로 더 쉽게 활용할 수 있게 코틀린 컴파일러는 copy()라는 메소드를 제공한다. 이 메소드는 객체를 복사하면서 일부 프로퍼티를 바꿀 수 있게 해주는 copy 메소드다. 객체를 메모리상에서 직접 바꾸는 대신 복사본을 만드는 편이 낫다. 복사본은 원본과 다른 생명주기를 가지며, 복사를 하면서 일부 프로퍼티 값을 바꾸거나 복사본을 제거해도 프로그램에서 원본을 참조하는 다른 부분에 영향을 끼치지 않는다. 클래스 위임 : by 키워드 사용대규모 객체지향 시스템을 설계할 때 시스템을 취약하게 만드는 문제는 보통 구현 상속에 의해 발생한다. 하위 클래스가 상위 클래스의 메소드 중 일부를 오버라이드하면 하위 클래스는 상위 클래스의 세부 구현 사항에 의존한다. 시스템이 변함에 따라 상위 클래스의 구현이 바뀌거나 새로운 메소드가 추가되기도 한다. 그 과정에서 하위 클래스가 상위 클래스에 대해 갖고 있던 가정이 깨져 코드가 정상적으로 동작하지 못하는 경우가 생길 수 있다. 그래서 코틀린은 모든 클래스를 기본적으로 final로 취급하여 상속을 염두에 두고 open 변경자가 붙은 열린 클래스만 확장할 수 있다. 열린 상위 클래스의 소스 코드를 변경할 때는 open 변경자를 보고 해당 클래스를 다른 클래스가 상속하리라 예상할 수 있으므로, 변경 시 하위 클래스를 깨지 않기 위해 좀 더 조심할 수 있다. 하지만 종종 상속을 허용하지 않는 클래스에 새로운 동작을 추가해야할 때가 있는데 이때 사용하는 일반적인 방법이 데코레이터 패턴이다. 데코레이터 패턴과 관련된 내용은 직접 찾아보길 바란다! 이런 방법의 단점은 준비 코드가 상당히 많이 필요하다는 점이다. 예를 들어, Collection과 같은 단순한 인터페이스를 구현하면서 아무 동작도 변경하지 않는 데코레이터를 만들 때조차도 코드가 복잡해진다. 123456789class DelegatingCollection&lt;T&gt;: Collection&lt;T&gt; &#123; private val innerList = arrayListOf&lt;T&gt;() override val size: Int get() = innerList.size override fun isEmpty(): Boolean = innerList.isEmpty() override fun contains(element: T): Boolean = innerList.contains(element) override fun iterator(): Iterator&lt;T&gt; = innerList.iterator() override fun containsAll(elements: Collection&lt;T&gt;): Boolean = innerList.containsAll(elements)&#125; 이와 같은 위임을 언어가 제공하는 일급 시민 기능으로 지원한다는 점이 코틀린의 특징 중 하나이다. 코틀린은 인터페이스를 구현할 때 by 키워드를 통해 그 인터페이스에 대한 구현을 다른 객체에 위임한다는 사실을 명시할 수 있다. 아래는 위임을 사용해 코드를 재작성한 것이다. 1class DelegatingCollection&lt;T&gt;(innerList: Collection&lt;T&gt; = ArrayList&lt;T&gt;()): Collection&lt;T&gt; by innerList 클래스 안에 있던 모든 메소드 및 프로퍼티 정의가 사라졌다. 컴파일러가 그런 전달 메소드를 자동으로 생성하며 자동 생성한 코드의 구현은 DelegatingCollection에 있던 구현과 비슷하다. 컴파일러가 자동으로 해줄 수 있는 작업을 굳이 해야할 이유가 없다. 만약, 메소드 중 일부의 동작을 변경하고 싶은 경우에 메소드를 오버라이드하면 컴파일러가 생성한 메소드 대신 오버라이드한 메소드가 쓰인다. 기존 클래스의 메소드에 위임할 때, 기본 구현으로 충분한 메소드는 따로 오버라이드할 필요가 없다. 12345678910111213class CountingSet&lt;T&gt;(val innerSet: MutableCollection&lt;T&gt; = HashSet&lt;T&gt;()): MutableCollection&lt;T&gt; by innerSet&#123; var objectsAdded: Int = 0 override fun add(element: T): Boolean&#123; objectsAdded++ return innerSet.add(element) &#125; override fun addAll(c: Collection&lt;T&gt;): Boolean&#123; objectsAdded += c.size return innerSet.addAll(c) &#125;&#125;","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"},{"name":"데이터 클래스","slug":"데이터-클래스","permalink":"http://victorywoolee/victorywoolee.github.io/tags/데이터-클래스/"},{"name":"클래스 위임","slug":"클래스-위임","permalink":"http://victorywoolee/victorywoolee.github.io/tags/클래스-위임/"}]},{"title":"[Kotlin] 뻔하지 않은 프로퍼티와 생성자","slug":"Chap4-2","date":"2019-10-09T05:01:27.000Z","updated":"2019-10-09T08:59:24.713Z","comments":true,"path":"2019/10/09/Chap4-2/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/09/Chap4-2/","excerpt":"","text":"생성자 주 생성자 : 클래스를 초기화할 때 주로 사용하는 간략한 생성자로, 클래스 본문 밖에서 정의한다. (괄호 {} 밖에서 정의한다.) 부 생성자 : 클래스 본문 안에서 정의한다. (괄호 {} 안에서 정의한다.) 초기화 블록 : 초기화 로직을 추가할 수 있다. 클래스 초기화 클래스 이름 뒤에 오는 괄호롤 둘러싸인 부분은 주 생성자라고 부른다. 주 생성자에서는 생성자 파라미터를 지정하고 그 생성자 파라미터에 의해 초기화되는 프로퍼티를 정의하는 두 가지 목적에 쓰인다. constructor : 주 생성자, 부 생성자를 정의 init : 초기화 블록을 시작한다. 클래스의 객체가 만들어질 때, 실행될 초기화 코드가 들어간다. 주로 주 생성자와 함께 사용된다. 주 생성자는 제한적이기 때문에 별도의 코드를 포함할 수 없으므로 초기화 블록이 필요하다. 12345678class User constructor(_nickname: String)&#123; val nickname: String // 초기화 블록. init&#123; nickname = _nickname &#125;&#125; 위의 코드에서 nickname 프로퍼티를 초기화하는 코드를 nickname 프로퍼티 선언에 포함시켜서 초기화 블록을 제거할 수 있다. 그리고 주 생성자 앞에 가시성 변경자가 없다면 constructor 키워드를 생략할 수 있다. 123class User(_nickname: String)&#123; val nickname = _nickname&#125; 파라미터가 하나인 주 생성자이면서 프로퍼티를 주 생성자의 파라미터로 초기화한다. 프로퍼티를 초기화하는 식이나 초기화 블록 안에서만 주 생성자의 파라미터를 참조할 수 있다. 주 생성자의 파라미터로 프로퍼티를 초기화한다면 주 생성자 파라미터 앞에 val 키워드를 추가하여 프로퍼티 정의와 초기화를 간략하게 쓸 수 있다. 123class User(val nickname: String)// val은 이 파라미터에 상응하는 프로퍼티가 생성된다는 뜻이다. // 따라서 프로퍼티의 정의를 하고 초기화도 할 수 있다. 클래스의 인스턴스를 만들 때는 new 키워드 없이 생성 가능하다. 클래스가 상위 클래스를 상속받았다면 주 생성자에서 상위 클래스의 생성자를 호출해야 한다. 1234567open class User(name: String)&#123; ...&#125;class FacebookUser(name: String) : User(name)&#123; ...&#125; 클래스를 정의할 때 별도로 생성자를 정의하지 않으면 컴파일러가 자동으로 아무 일도 하지 않는 디폴트 생성자를 만들어준다. 비록 생성자는 인자를 받지 않지만, 해당 클래스를 상속받은 하위 클래스는 상위 클래스의 생성자를 호출해야만 한다. 이런 규칙으로 인해 상위 클래스 이름 뒤에는 빈 괄호가 꼭 들어가야 한다. (인자가 없다면, 인자가 있다면 생성자에 인자를 넣어준다.) 인터페이스의 경우 생성자가 없기 때문에 상속 받을 경우, 인터페이스의 이름만 명시해주면 된다. 12345open class Buttonclass RadioButton: Button()&#123; ...&#125; Tip모든 생성자 파라미터에 디폴트 값을 지정하면 컴파일러가 자동으로 파라미터가 없는 생성자를 만들어준다. 자동으로 만들어진 파라미터 없는 생성자는 디폴트 값을 이용해 클래스를 초기화한다.이와 같이 코틀린이 제공하는 파라미터 없는 생성자는 의존성 주입(DI, Dependency Injection) 프레임워크 등과의 통합을 쉽게 해준다. 이유는 파라미터가 없는 생성자를 통해 객체를 생성해 라이브러리를 사용할 수 있게 도와주기 때문이다. 부 생성자 코틀린에서는 생성자가 여럿 있는 경우가 많지 않다. 자바에서 오버로드한 생성자가 필요한 상황 중 상당수는 코틀린의 디폴트 파라미터 값와 이름 붙은 인자를 사용하면 해결된다. 생성자가 2개인 View 클래스가 있다고 하고 아래와 같은 코드의 구조를 보인다. 주 생성자는 없고 constructor 키워드를 가진 2개의 부 생성자를 가지고 있다. View 클래스를 확장한 Button 클래스에서는 super() 키워드를 이용해 부 생성자에서 상위 클래스의 생성자를 호출해 객체 생성을 위임한다. (자신에 대응하는 상위 클래스의 생성자를 호출한다.) 12345678910111213141516171819open class View&#123; constructor(ctx: Context)&#123; &#125; constructor(ctx: Context, attr: AttributeSet)&#123; &#125;&#125;class Button: View&#123; constructor(ctx: Context) : super(ctx)&#123; &#125; constructor(ctx: Context, attr: AttributeSet) : super(ctx,attr)&#123; &#125;&#125; this()를 통해 클래스 자신의 다른 생성자를 호출할 수도 있다. 다음은 파라미터 중 하나의 값에 디폴트 값을 넘겨 같은 클래스의 다른 생성자를 호출해 생성을 위임한다. 클래스에 주 생성자가 없다면 모든 부 생성자는 반드시 상위 클래스를 초기화하거나 다른 생성자에게 생성을 위임해야 한다. 부 생성자가 필요한 이유는 자바 상호운용성이다. 또는 클래스 인스턴스를 생성할 때, 파라미터 목록이 다른 생성 방법이 여럿 존재하는 경우다. 부 생성자를 사용할 때, 주의 사항이 있다. 이는 주 생성자가 아니므로 파라미터를 프로퍼티처럼 사용할 수 없다. 그래서 클래스 본문에서 참조해 사용할 수 없다. 생성자 파라미터를 프로퍼티처럼 사용하기 위해서는 주 생성자에서 선언해서 사용이 가능하다. 인터페이스에 선언된 프로퍼티 구현 인터페이스에 추상 프로퍼티 선언을 할 수 있다. 이 인터페이스를 구현하는 클래스가 추상 프로퍼티의 값을 얻을 수 있는 방법을 제공해야 한다. 아래 인터페이스가 있고 이를 구현한 클래스가 존재한다. 123456789101112131415161718192021interface User&#123; val nickname: String&#125;// 별명을 저장.// 주 생성자에 있는 프로퍼티class PrivateUser(override val nickname: String) : User// 이메일과 함께 저장.// 커스텀 게터class SubscribingUser(val email: String) : User&#123; override val nickname get() = eamil.substringBefore('@')&#125;// 페이스북 계정의 ID를 저장.// 함수를 이용한 프로퍼티 초기화 식class FacebookUSer(val accountId: Int) : User&#123; override val nickname = getFacebookName(accountId)&#125; Privateuser 주 생성자 안에 프로퍼티를 선언해 간결한 구문을 보여준다. SubscribingUser 커스텀 게터로 nickname 프로퍼티를 설정한다. 필드에 값을 저장하지 않고 매번 이메일 주소에서 별명을 계산한다. FacebookUser getFacebookName() 함수를 호출해 초기화한다. 페이스북에 접속해 인증을 거친 후 데이터를 가져와야 하기 때문에 비용이 많이들 가능성이 있다. 따라서 객체를 초기화하는 단계에서 한 번만 호출한다. 인터페이스에는 추상 프로퍼티뿐 아니라 게터와 세터가 있는 프로퍼티를 선언할 수 있다. 하지만, 게터와 세터는 필드를 참조할 수 없다. 이유는 필드가 초기화되어 있지 않기 때문이다. 필드가 있다는 것은 인터페이스에 상태를 추가한다는 의미인데, 인터페이스는 상태를 가질 수 없다. 게터와 세터에서 뒷받침하는 필드에 접근 값을 저장하는 동시에 어떠한 로직을 실행할 수 있게 하기 위해서는 접근자 안에서 프로퍼티를 뒷받침하는 필드에 접근할 수 있어야 한다. 간단한 예를 확인해보자. 123456789class User(val name: String)&#123; val address: String = \"not yet\" set(value: String)&#123; println(\"Address was changed for $name: \"$field\" -&gt; \"$value\". \"\"\".trimIndent()) field = value // 뒷받침하는 필드 값을 변경한다. &#125;&#125; field를 통해서 뒷받침하는 필드에 접근할 수 있다.(즉, address에 접근 가능.) 게터에서는 field 값을 읽을 수만 있고, 세터에서는 field 값을 읽거나 쓸 수 있다. 변경 가능 프로퍼티의 게터와 세터 중 한쪽만 직접 정의해도 된다. 접근자의 가시성 변경 get(), set() 앞에 가시성 변경자를 추가해 접근자의 가시성을 변경할 수 있다. 아래는 추가된 단어의 길이를 반환하는 함수가 있다. 이는 클라이언트에게 제공되므로 public으로 선언되 외부에 공개한다. 다만, 단어 길이의 합을 외부에서 바꾸지 못하도록 하기 위해서 게터는 그대로 냅두고, 세터의 가시성을 private으로 지정한다. 1234567891011121314class LengthCounter&#123; var counter: Int = 0 private set // 이 클래스의 밖에서 counter의 값을 바꿀 수 없다. fun addWord(word: String)&#123; counter += word.length &#125;&#125;val lengthCounter = LengthCounter()lengthCounter.addWord(\"Hi!\")println(lengthCounter.counter)// 결과:3","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"},{"name":"생성자","slug":"생성자","permalink":"http://victorywoolee/victorywoolee.github.io/tags/생성자/"}]},{"title":"[Android] Compose","slug":"Android-Compose","date":"2019-10-05T08:07:49.000Z","updated":"2019-10-06T13:21:00.377Z","comments":true,"path":"2019/10/05/Android-Compose/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/05/Android-Compose/","excerpt":"","text":"왜??선언적 프로그래밍이 UI 프로그래밍에 있어서 부상하고 있는 이유는 갈수록 복잡해지고 다양해지는 UI/UX 때문이라고 할 수 있다. 특히 애니메이션 같은 부분은 명령형으로 처리하기 매우 까다롭다. 가장 중요한 뷰의 상태라는 것에만 신경쓰고, 상세한 부분들은 프레임워크가 알아서 해주기를 기대하는 것이다. 기존의 안드로이드 UI 시스템에는 다음과 같은 문제가 있다. 안드로이드 프레임워크와 강하게 묶여있다. 안드로이드에서 제공하는 다양한 라이브러리들은 각자 버전이 따로 업데이트 된다. 그리고 개발자들은 다른 라이브러리를 신경쓰지 않고 필요한 버전만 해당 라이브러리에 적용해서 사용할 수 있다. 반면에, UI는 SDK와 함께 버전업이 되기 때문에 새로운 기능을 사용하려면 SDK를 함께 업데이트해야 한다. 하지만, SDK에는 UI만 있는게 아니기 때문에 버전을 올리기가 쉽지 않다. 예를 들면, 마시멜로에서 생긴 권한 체크가 그 중 한가지이다. 복잡한 코드와 클래스 구조 View.java의 소스는 거의 3만줄에 육박한다. 그만큼 복잡하며 길다. 그리고 특정 뷰에 어울리지 않는 동작들이 있다. 예를 들면, Button이 TextView의 속성을 그대로 가지고 있다. 그래서 버튼 안의 텍스트를 선택하거나 수정하는 등의 동작이 가능하다. 설명 영상에서는 이를 API Regret이라고 표현했다. 너무 많은 코드 커스텀 뷰를 작성하게 된다면 작성해야 하는 파일이 많다. 새로운 속성을 추가하기 위해서는 접근해야 하는 곳이 많다. CustomView.kt layout.xml attrs.xml styles.xml 이렇게 커스텀 뷰에 대해서 분산되어 있는 코드로 인해 수정과 유지보수를 위한 비용이 많이 든다. 일관되지 않은 데이터 흐름MVP, MVVM, MVI 등의 프론트엔드 아키텍처는 데이터 흐름을 일관되게 유지하는 것을 목적으로 하고 있다고 할 수 있다. 이러한 아키텍처들은 대부분 뷰에 상태를 두지 않고, 뷰의 변화를 관찰하는 개체가 뷰의 상태를 관리한다. 이를 통해서 데이터의 흐름이 한 방향으로 흐르도록 할 수 있다. 반면, 안드로이드 UI 시스템은 이러한 아키텍처들과는 다소 상반되는 구조를 가지고 있다. 안드로이드의 뷰들은 각자만의 상태를 가지고 있고, 스스로 상태를 제어한다. 이렇다보니 코드를 깔끔하게 만들지 않는다면 UI를 구현할 때나 디버깅을 할 때 힘들다. 목표??위에서 봤듯이 꽤 큰 문제들이 있다. Compose는 이러한 문제를 어떻게 해결할 수 있을까? SDK와 UI를 분리 SDK와 UI를 분리함으로써 서로 의존성을 갖지 않게 하여 UI를 업데이트하는데 편리함을 갖게 될 수 있다. 재사용 가능하고 간단한 View 구조 불필요한 상속을 없애고, 보일러플레이트 코드를 제거하는 것을 목표로 한다. 재사용 가능하고 작성한 대로 출력되는 직관적인 UI 코드를 작성하는 것이 목표다. 적은 코드 커스텀 뷰를 작성할 때처럼 layout, attr, style과 같은 파일로 분산시켜 작성하는 것에서 하나의 UI 코드를 작성함으로써 수정 및 유지보수의 비용을 줄일 수 있다. 하나의 데이터 흐름 State는 하나의 Owner만 갖으며, 하나의 Owner만 State를 변경한다. Owner가 이벤트를 감지하고 변경을 주도한다. Compose??1. UI 작성을 위한 선언적 방법 Jetpack에 포함된 Compose는 UI 개발을 단순화하도록 설계된 번들 툴킷이다. 반응형 프로그래밍 모델과 Kotlin 프로그래밍 언어의 간결함 및 사용 편의성을 결합한다. 주의해야할 점은 Compose가 아직 초기 알파 단계 버전이기 때문에 실제 프로덕션에 사용하는 것을 권장하지는 않는다. 2. 핵심 원칙 Concise and Idiomatic Kotlin(간결하고 관용적인 코틀린) 코틀린이 제공하는 이점으로 간결하고 안전하며 Java 언어와 완벽하게 상호 운용된다. 작성해야 하는 상용구 코드의 양을 대폭 줄이도록 설계되어 앱 코드에 집중하고 전체 클래스의 오류를 피할 수 있다. Declarative(선언적) 레이아웃을 그리는 것부터 생성을 포함해서 UI 구성 요소를 정의하는데 선언적인 방법을 사용한다. UI를 컴포저블 함수로 표현하면 프레임워크는 뷰 계층에 대한 자동 업데이트를 하고 UI 최적화를 처리한다. Compatible(호환) 기존의 View와 호완되므로 모든 Android 및 Jetpack API에 직접 접근해 원하는대로 혼합시키고 일치시킬 수 있다. Enable Beautiful Apps(아름다운 앱 사용) 처음부터 Material Design과 애니메이션으로 설계되어 모션이 가득한 멋진 앱을 만들 수 있다. Accelerate Development(개발 가속화) 적은 코드를 작성하고 Apply Changes 및 라이브 미리보기와 같은 도구를 사용해 개발을 가속화할 수 있다. 3. 핵심적인 아이디어 UI as a function 어떤 입력을 받아 결과를 반환하는 함수의 아이디어를 UI로 확장해서 어떤 입력을 받아 UI 구조를 반환하는 함수라고 생각하면 된다. 함수는 어떠한 상태도 가지고 있지않고, 외부의 어떤 상태도 변경해서는 안된다. 그저 자신이 그려야할 UI의 계층을 반환할 뿐이다. -&gt; 순수함수 또한, Kotlin의 함수로 UI를 표현하기 때문에 XML에서는 불가능한 프로그래밍 언어의 다양한 기능을 UI를 작성하는데 활용할 수 있다. 123fun Greeting(name: String)&#123; Text(\"Hello $name\")&#125; Composable is composable Compose의 UI 위젯을 사용하기 위해서는 @Composable 어노테이션을 붙여줘야 한다. 그리고 이 함수는 다른 Composable 함수를 포함할 수 있다. 1234@Composablefun Greeting(name: String)&#123; Text(\"Hello $name\")&#125; Observable Model 데이터의 변경이 생길 때마다 직접 UI를 업데이트하는 건 번거로운 작업이다. 이런 문제를 해결하기 위해 RxJava나 LiveData와 같은 Observable을 사용하면 된다. 123vm.state.observe(this) &#123; state -&gt; updateUi(state)&#125; Compose에서는 데이터가 바뀔 때마다 UI를 변경시키기 위해서 LiveData를 사용하는 방법을 쓸 수도 있다. 123vm.name.observe(this) &#123; name -&gt; Greeting(name)&#125; 그려야할 데이터가 많다면 각 데이터에 대해 일일히 LiveData를 만들어줘야 하기 때문에 불편하다. 이런 경우에는 data class에 @Model 어노테이션을 붙여주어 값이 변경될 때마다 해당 값을 참조하고 있는 Composable 함수가 다시 Compose 된다고 한다. 2가지 주요 구성 요소 레이아웃, 입력, 텍스트, 애니메이션, 스타일, 위젯 및 그래픽이 포함된 핵심 UI 툴킷이 포함된 UI 라이브러리를 포함해야 한다. 컴포저블 기능을 수행하고 UI 계층 구조를 자동으로 업데이트하는 사용자 정의 Kotlin 컴파일러 플러그인, Compose 컴파일러를 포함해야 한다. Compose Application은 애플리케이션 데이터를 UI 계층으로 변환하는 Composable한 함수로 구성되어있다. @Composable 어노테이션을 추가해 컴포저블한 함수를 만들 수 있다. 기본적으로 Compose는 사용자 정의 Kotlin 컴파일러 플러그인을 사용하므로 기본 데이터가 변경되면 업데이트 가능한 UI 계층을 생성하기 위해 작성 가능한 기능을 다시 호출할 수 있다. 실행Compose는 아직 pre-alpha 단계다. 그래서 다른 라이브러리처럼 간단하게 dependency를 추가해서 사용할 수 없다. 대신에 오픈 소스를 가져와서 직접 빌드해야 한다. repo AOSP(Android Open Source Project)에서는 repo라는 툴을 사용해 버전 관리를 한다. Git과 비슷하지만, 안드로이드에 좀 더 적합하게 만들었다고 한다. 다음 명령어를 통해 repo를 설치하면 된다. 12$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; repo$ chmod a+x repo source 초기화 및 소스 코드의 Sync를 맞춘다.12$ repo init -u https://android.googlesource.com/platform/manifest -b androidx-master-dev$ repo sync -j8 -c 시작 소스를 내려받고 /frameworks/support/ui 위치로 이동해서 안드로이드 스튜디오를 실행하면 된다. 평소에 사용하는 버전이 아니라 지정된 버전을 사용해야 하기 때문에 studiow를 통해 안드로이드 스튜디오를 실행하면 된다고 한다. 12$ cd androidx-master-dev/frameworks/support/ui$ ./studiow API - Annotations Composable 이 어노테이션을 붙인 함수는 Compose의 기본이 되는 Composable Widget으로써 기능한다. 반환 타입을 따로 정의하지 않는다. 코틀린 컴파일러 플러그인을 통해서 구현된다. 따라서 컴파일 전과 후의 코드는 완전히 다르고, 우리가 일반적으로 알던 코틀린의 실행 흐름과 다르게 동작할 수 있다. Model 위젯에서 사용되는 데이터를 정의할 수 있다. 이 모델이 변경될 경우 위젯이 다시 렌더링된다. API - EffectsEffect는 위젯을 그리는 단계에서 어떠한 코드를 실행하고 싶을 때 사용한다. 이해하기 위해서 Compose의 실행 흐름을 이해할 필요가 있다 Execution Flow 1) Composition Phase 이 단계에서는 어떤 위젯을 그릴 것인지 선언한다. 선언적 프로그래밍 패러다임에는 지연 실행이라는 개념이 있는데, 최대한 실제 실행을 뒤로 미루는 것을 말한다. 이렇게 화면에 렌더링을 한다라는 실제 실행을 하기 이전에 어떻게 그릴 것인가를 정의하는 단계이다. 2) Execution Phase Compostion Phase에서 정의했던 Component의 그래프를 화면에 렌더링하는 단계이다. 123456789101112@Modeldata class Counter(val number: Int=0)&#123; fun increment(): Counter = Counter(number + 1)&#125;@Composablefun CounterWidget()&#123; var counter = Counter() Text(text = \"Counter : $&#123;counter.value&#125;\") Button(onClick = &#123;counter = counter.increment()&#125;)&#125; CounterWidget에는 counter라는 로컬 변수, 즉 상태가 존재한다. Text에서는 그것을 보여주고 Button에서는 그 값을 업데이트하고 있다. @Model로 모델 클래스임을 명시했으니 모든게 완벽하다. 버튼을 누르면 값이 증가하는 동작을 실행할 것 같지만 그렇지 않다. 앞서 @Composable 어노테이션을 이야기할 때, 코드가 일반적인 코틀린의 실행 흐름과는 다르게 동작할 수 있다고 언급했었다. Compose의 위젯들은 일종의 Context 위에서 실행된다. 따라서 위젯에서 필요한 데이터 역시 이 Context 위에 올라가 있어야 한다. 이를 도와주는게 Effect라는 것을 사용하면 가능하다. 123456789101112@Modeldata class Counter(val number: Int=0)&#123; fun increment(): Counter = Counter(number + 1)&#125;@Composablefun CounterWidget()&#123; var counter = +memo&#123; Counter() &#125; Text(text = \"Counter : $&#123;counter.value&#125;\") Button(onClick = &#123;counter = counter.increment()&#125;)&#125; 이전의 코드에서 memo Effect와 해당 Effect를 resolve하는 +(unaryPlus) 연산자 오버로딩 함수를 붙여주면 제대로 동작함을 확인할 수 있다. Effect의 이름 Effect는 개념적으로 리턴 값을 가지고 있는 Composable 함수이고 이게 Compose의 실행 흐름에 일종의 효과를 적용하는 것과 비슷해서 Effect라고 지은 것으로 추측된다. Defined Effects 몇 가지 미리 정의되어 있는 Effect들이 존재하며 다음과 같다. 실제 사용 예는 대부분 실행 단계에서 필요한 어떤 값을 가져오기 위한 목적으로 쓴다. Memo 단순히 어떤 실행 블록을 기억하는 역할을 한다.123fun &lt;T&gt; memo(calculation: () -&gt; T) = effectOf&lt;T&gt;&#123; context.remember(calculation)&#125; calculation 코드 블록에서 반환하는 클래스에 @Model이 붙어있지 않으면 Composition이 다시 이루어져도 이 코드 블록은 재실행되지 않는다. State memo와 비슷하지만, 단순히 어떤 코드 블록을 기억하는 목적이 아니라 위젯에서 사용할 Local State의 개념을 가지고 있는 Effect이다. State는 Compose의 모델 클래스이고, 단순히 어떤 값을 wrapping하고 있는 클래스다. 123456fun &lt;T&gt; state(init: () -&gt; T) = memo &#123; State(init()) &#125;@Modelclass State&lt;T&gt; internal constructor(value: T) : Framed &#123; /* ... */&#125; Lifecycle Effects 그 외 3 가지 Composition의 라이프사이클에 관련된 Effect가 존재한다. onActive : Composition이 처음 실행될 때 호출되고, 그 이후로는 호출되지 않는다. onDispose : 해당 위젯이 더 이상 화면에서 보이지 않을 때 호출된다. onCommit : Compostion이 실행될 때마다 호출된다. 선언형 프로그래밍과 명령형 프로그래밍 명령형 프로그래밍 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 방식 알고리즘을 명시하고 목표는 명시하지 않는다.123val container = binding.containercontainer.removeAllViews()containter.setBackgroundColor(Color.BLUE) 원하는 상태를 만들기 위해 명령문을 사용한다. 위의 코드는 container에게 모든 뷰를 제거, 백그라운드 색상을 지정하는 등의 명령을 내린다. 제어 흐름이 명확하다는 장점이 있지만, 반대로 어떤 상태에 도달하려는 것인지 명확하지 않다. 선언형 프로그래밍 제어 흐름이 아니라 어떤 상태를 원하는지 서술한다.123456return State( backgroundColor = Color.RED, children = [ createNewButton() ]) 이런 방식이 제대로 동작하기 위해서는 이전 상태와 다음 상태를 비교하고 전환을 수행하는 기능을 프레임워크가 제공해야 한다. 리액트가 이런 방식으로 동작한다고 한다. 상태를 비교하고 상태가 다를 경우 해당 부분만 렌더링한다. 참고 Google Developer Android Studio Jetpack Compose &amp; Sample App How to install Repo @tura velog","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Jetpack/"},{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Compose","slug":"Compose","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Compose/"}]},{"title":"[CleanCode] 8장","slug":"CleanCode08","date":"2019-10-04T13:24:51.000Z","updated":"2019-10-05T01:46:20.302Z","comments":true,"path":"2019/10/04/CleanCode08/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/04/CleanCode08/","excerpt":"","text":"외부 코드 사용하기 인터페이스 제공자와 인터페이스 사용자 사이에는 특유의 긴장이 존재한다. 패키지 제공자나 프레임워크 제공자는 적용성을 최대한 넓히려 애쓴다. 더 많은 환경에서 돌아가야 더 많은 고객이 구매하기 때문이다. 반면, 사용자는 자신의 요구에 집중하는 인터페이스를 바란다. 이런 긴장으로 인해 시스템 경계에서 문제가 생길 소지가 많다. Map은 굉장히 다양한 인터페이스로 수많은 기능을 제공한다. Map이 제공하는 기능성과 유연성은 확실히 유용하지만, 그만큼 위험부담이 크다. ex)12Map sensors = new HashMap(); // Map 생성Sensor s = (Sensor) sensors.get(sensorId); // Sensor 객체를 가져온다. 위와 같은 코드가 한 번이 아니라 여러 차례 나온다. 즉, Map이 반환하는 Object를 올바른 유형으로 변환할 책임은 Map을 사용하는 클라이언트에 있다. 그래도 코드는 올바르게 동작한다. 하지만, 깨끗한 코드라 보기 어렵다. 제네릭을 사용하면 코드 가독성이 높아진다. 12Map&lt;String, Sensor&gt; sensors = new HashMap&lt;Sensor&gt;();Sensor s = sensors.get(sensorId); 하지만, 위의 방법도 결국 사용자에게 필요하지 않은 기능까지 제공한다는 문제가 남아있다. Map&lt;String, Sensor&gt;아래는 Map을 조금 더 깔끔하게 사용한 코드다. Sensors 사용자는 제네릭이 사용되었는지 여부에 신경 쓸 필요가 없다. 제네릭의 사용 여부는 Sensors 안에서 결정한다. 1234567public class Sensors&#123; private Map sensors = new HashMap(); public Sensor getById(String id)&#123; return (Sensor) sensors.get(id); &#125;&#125; 경계 인터페이스인 Map은 Sensors 안으로 숨긴다. 따라서 Map 인터페이스가 변하더라도 나머지에는 영향을 미치지 않는다. 제네릭을 사용하든 말든 문제가 되지 않는다. Sensors 클래스 안에서 객체 유형을 관리하고 변환하기 때문이다. 또한, Sensors 클래스는 프로그램에 필요한 인터페이스만 제공한다. 그래서 코드는 이해하기 쉽지만 오용하기는 어렵다. Sensors 클래스는 나머지 프로그램이 설계 규칙과 비즈니스 규칙을 따르도록 강제할 수 있다. Map과 같은 경계 인터페이스를 사용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다. Map 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않는다. 경계 살피고 익히기 외부 코드를 익히기는 어렵다. 외부 코드를 통합하기도 어렵다. 곧바로 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히면 어떨까? 이를 학습 테스트라 부른다. 학습 테스트는 프로그램에서 사용하려는 방식대로 외부 API를 호출한다. 통제된 환경에서 API를 제대로 이해하는지를 확인하는 셈이다. 학습 테스트는 API를 사용하려는 목적에 초점을 맞춘다. 학습 테스트는 공짜 이상이다 학습 테스트에 드는 비용은 없다. 오히려 필요한 지식만 확보하는 손쉬운 방법이다. 이해도를 높여준다. 투자하는 노력보다 얻는 성과가 크다. 학습 테스트를 이용한 학습이 필요하든 그렇지 않든, 실제 코드와 동일한 방식으로 인터페이스를 사용하는 테스트 케이스가 필요하다. 이런 경계 테스트가 있다면 패키지의 새 버전으로 이전하기 쉬워진다. 그렇지 않다면 낡은 버전을 필요 이상으로 오랫동안 사용하려는 유혹에 빠지게 된다. 아직 존재하지 않는 코드를 사용하기 경계와 관련해 또 다른 유형은 아는 코드와 모르는 코드를 분리하는 경계다. 아직 존재하지 않는 코드를 위해 인터페이스를 사용해 설계를 먼저 한다. 우리가 바라는 인터페이스를 구현하면 우리가 인터페이스를 전적으로 통제한다는 장점이 생긴다. 또한 코드 가독성도 높아지고 코드 의도도 분명해진다. 깨끗한 경계 경계에 위치하는 코드는 깔끔히 분리한다. 또한 기대치를 정의하는 테스트 케이스도 작성한다. 통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 좋다. 자칫하면 외부 코드에 휘둘리고 만다. 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자. 새로운 클래스로 경계를 감싸거나 Adapter 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하자. 어느 방법이든 코드 가독성이 높아지며, 경계 인터페이스를 사용하는 일관성도 높아지며, 외부 패키지가 변했을 때, 변경할 코드도 줄어든다.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"경계","slug":"경계","permalink":"http://victorywoolee/victorywoolee.github.io/tags/경계/"}]},{"title":"[CleanCode] 7장","slug":"CleanCode07","date":"2019-10-04T08:39:45.000Z","updated":"2019-10-04T12:04:16.120Z","comments":true,"path":"2019/10/04/CleanCode07/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/04/CleanCode07/","excerpt":"","text":"깨끗한 코드와 오류 처리는 연관성이 있다. 상당수 코드 기반은 전적으로 오류 처리 코드에 좌우된다. 여기저기 흩어진 오류 처리 코드 때문에 실제 코드가 하는 일을 파악하기가 거의 불가능하다는 의미다. 오류 처리는 중요하다. 하지만, 오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워진다면 깨끗한 코드라 부르기 어렵다. 오류 코드보다 예외를 사용하라 예외를 처리하지 않고 오류를 처리하고 보고하는 방법은 제한적이다. 오류 플래그를 설절하거나 호출자에게 오류 코드를 반환하는 방법이 전부다. 이와 같은 방법은 호출자 코드가 복잡해진다. 함수를 호출한 즉기 오류를 확인해야 하기 때문이다. 이 단계는 잊어버리기 쉽다. 오류가 발생하면 예외를 던지는 편이 낫다. 그러면 호출자 코드가 깔끔해진다. 예외를 던지면 코드가 확실히 깨끗해진다. 코드 품질도 나아진다. Try-Catch-Finally 작성해라 try 블록에 들어가는 코드를 실행하면 어느 시점에서든 실행이 중단된 후 catch 블록으로 넘어갈 수 있다. try 블록은 트랜잭션과 비슷하다. try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성 있게 유지해야 한다. 그러므로 예외가 발생할 코드를 짤때는 try-catch-finally 문으로 시작하는 편이 낫다. 그러면 try 블록에서 무슨 일이 생기든지 호출자가 기대하는 상태를 정의하기 쉬워진다. 미확인을 사용하라 자바가 처음에 나왔을 때는 사람들이 확인된 예외를 멋진 아이디어라고 생각했다. 당시에는 그랬지만, 지금은 아니다. 확인된 오류가 치르는 비용에 상응하는 이익을 제공하는지 철저히 따져봐야 한다. 확인된 예외는 OCP를 위반한다. 예를 들어, 메소드에서 확인된 예외를 던졌는데 catch 블록이 세 단계 위에 있다면 그 사이 메소드 모두가 선언부에 해당 예외를 정의해야 한다. 즉, 하위 단계에서 코드를 변경하면 상위 단계 메소드 선언부를 전부 고쳐야 한다. 모듈과 관련된 코드가 전혀 바뀌지 않았더라도 (선언부가 바뀌었으므로) 모듈을 다시 빌드한 다음 배포해야 한다는 말이다. 대규모 시스템에서 호출이 일어나는 방식을 생각해보자. 최상위 함수가 아래 함수를 호출한다. 아래 함수는 그 아래 함수를 호출한다. 단계를 내려갈수록 호출하는 함수의 수가 늘어난다. 이제 최하위 함수를 변경해 새로운 오류를 던진다고 가정하자. 확인된 오류를 던진다면 함수는 선언부에 throws 절을 추가해야 한다. 그러면 변경한 함수를 호출하는 함수 모두가 catch 블록에서 새로운 예외를 처리하거나 선언부에 throw 절을 추가해야 한다. 결과적으로 취하위 단계에서 최상위 단계까지 연쇄적인 수정이 일어난다. throws 경로에 위치하는 모든 함수가 최하위 함수에서 던지는 예외를 알아야 하므로 캡슐화가 깨진다. 오류를 원거리에서 처리하기 위해 예외를 사용한다는 사실을 감안한다면 이처럼 확인된 예외가 캡슐화를 깨버리는 현상은 참으로 유감스럽다. 예외에 의미를 제공하라 예외를 던질 때는 전후 상황을 충분히 덧붙인다. 그러면 오류가 발생한 원인과 위치를 찾기가 쉬워진다. 호출자를 고려해 예외 클래스를 정의하라 오류를 분류하는 방법은 수없이 많다. 오류가 발생한 위치로 분류할 수도 있고, 오류가 발생한 컴포넌트로 분류한다. 또는 유형으로도 분류가 가능하다. 하지만, 애플리케이션에서 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야 한다. 아래는 외부 라이브러리를 호출하는 try-catch-finally문을 포함한 코드이다. 12345678910111213141516ACMEPort port = new ACMEPort(12);try&#123; port.open();&#125; catch(DeviceResponseException e)&#123; reportPortError(e); logger.log(\"Device response exception\", e);&#125; catch(ATM1212UnlockedException e)&#123; reportPortError(e); logger.log(\"Unlock exception\", e);&#125; catch(GMXError e)&#123; reportPortError(e); logger.log(\"Device response exception\", e);&#125; finally&#123; ...&#125; 중복이 심하지만 놀랍지 않다. 대다수 상황에서 우리가 오류를 처리하는 방식은 (오류를 일으킨 원인과 무관하게)비교적 일정하다. 오류를 기록한다. 프로그램을 계속 수행해도 좋은지 확인한다. 위의 경우는 예외를 대응하는 방식이 예외 유형과 무관하게 거의 동일하다. 그래서 코드를 고치기 쉽다. 123456789LocalPort port = new LocalPort(12);try &#123; port.open();&#125; catch(PortDeviceFailure e)&#123; reportError(e); logger.log(e.getMessage(), e)&#125; finally&#123; ...&#125; LocalPort 클래스가 ACMEPort 클래스가 던지는 예외를 잡아 변환하는 감싸주는 클래스다. LocalPort 클래스처럼 ACMEPort를 감싸는 클래스는 유용하다. 이렇게 외부 API를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어든다. 나중에 다른 라이브러리로 갈타도 비용이 적다. 또한, 감싸기 클래스에서 외부 API를 호출하는 대신 테스트 코드를 넣어주는 방법으로 프로그램을 테스트하기도 쉬워진다.123456789101112131415161718192021222324public class LocalPort&#123; private ACMEPort innerPort; public LocalPort(int portNumber)&#123; innerPort = new ACMEPort(portNumber); &#125; public void open()&#123; try&#123; innerPort.open(); &#125; catch(DeviceResponseException e)&#123; reportPortError(e); logger.log(\"Device response exception\", e); &#125; catch(ATM1212UnlockedException e)&#123; reportPortError(e); logger.log(\"Unlock exception\", e); &#125; catch(GMXError e)&#123; reportPortError(e); logger.log(\"Device response exception\", e); &#125; finally&#123; ... &#125; &#125;&#125; 정상 흐름을 정의하라 비즈니스 논리와 오류 처리가 잘 분리된 코드가 깨끗하다. 그리고 간결한 알고리즘이 보이기 시작한다. 하지만, 그러다 보면 오류 감지가 프로그램 언저리로 밀려난다. 외부 API를 감싸 독자적인 예외를 던지고 코드 위에 처리기를 정의해 중단된 계산을 처리한다. 대개는 멋진 방식이지만, 때로는 중단이 적합하지 않은 때도 있다. 특수 상황을 처리할 필요가 없다면 더 좋고, 코드가 훨씬 깔끔해진다. 특수 사례 패턴은 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식이다. 그러면 클라이언트 코드가 예외적인 상황을 처리할 필요가 없어진다. 클래스나 객체가 예외적인 상황을 캡슐화해서 처리하므로. null을 반환하지 마라 null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다. null 확인을 중간에 빼먹는다면 애플리케이션이 통제 불능에 빠지게 될지도 모른다. 메소드에서 null을 반환하고픈 유혹이 든다면 그 대신 예외를 던지거나 특수 사례 객체를 반환한다. 사용하려는 외부 API가 null을 반환한다면 감싸기 메소드를 구현해 예외를 던지거나 특수 사례 객체를 반환하는 방식을 고려한다. 123456List&lt;Employee&gt; employees = getEmployees();if(employees != null)&#123; for (Employee e: employees)&#123; totalPay += e.getPay(); &#125;&#125; 위에서 getEmployees()는 null을 반환할 수도 있다. 하지만, 반드시 null을 반환할 필요가 있을까? getEmployees()를 변경해 빈 리스트를 반환한다면 코드가 훨씬 깔끔해진다. 12345678910public List&lt;Employee&gt; getEmployees()&#123; if(직원이 없다면)&#123; return Collections.emptyList(); &#125;&#125;List&lt;Employee&gt; employees = getEmployees();for (Employee e: employees)&#123; totalPay += e.getPay();&#125; Collections.emptyList()가 있어 미리 정의된 읽기 전용 리스트를 반환한다. null을 반환하는 부분을 변경하면 위 코드처럼 깔끔하게 처리할 수 있으며 NullPointerException이 발생할 가능성도 줄어든다. null을 전달하지 마라 메소드로 null을 전달하는 방식을 null을 반환하는 것보다 더 나쁘다. 정상적인 인수로 null을 기대하는 API가 아니라면 메소드로 null을 전달하는 코드는 최대한 피한다. 대다수 프로그래밍 언어는 호출자가 실수로 넘기는 null을 적절하게 처리하는 방법이 없다. 그렇다면 애초에 null을 넘기지 못하도록 금지하는 정책이 합리적이다. 즉, 인수로 null이 넘어오면 코드에 문제가 있다는 의미다. 이런 정책을 따르면 그만큼 부주의한 실수를 저지를 확률도 작아진다. 결론깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다. 이 둘은 상충하는 목표가 아니다. 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다. 오류 처리를 프로그램 논리와 분리하면 독립적인 추론이 가능해지며 코드 유지보수성도 크게 높아진다.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"오류 처리","slug":"오류-처리","permalink":"http://victorywoolee/victorywoolee.github.io/tags/오류-처리/"}]},{"title":"[Kotlin] 클래스와 인터페이스","slug":"Chap4-1","date":"2019-10-04T06:35:18.000Z","updated":"2019-10-12T05:53:56.163Z","comments":true,"path":"2019/10/04/Chap4-1/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/04/Chap4-1/","excerpt":"","text":"클래스 계층 정의1. 코틀린 인터페이스 추상 메소드 뿐 아니라 구현이 있는 메소드도 정의할 수 있다. 아무런 상태(필드)도 들어갈 수 없다. 인터페이스의 선언은 자바와 같으며, extends(상속)와 implements(구현)은 코틀린에서는 모두 콜론(:) 키워드를 사용해 클래스 확장과 인터페이스 구현을 모두 처리한다. override 변경자는 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메소드를 오버라이드한다는 표시다. 꼭 사용해야 한다. 디폴트 구현은 단지 메소드 본문은 시그니처 뒤에 작성하면 된다. 1234interface Clickable&#123; fun click() // 일반 메소드 선언 fun showOff() = println(\"I'm clickable!! \") // 디폴트 구현이 있는 메소드&#125; 위 인터페이스를 구현하는 클래스는 click에 대한 구현을 제공해야 한다. 반면, showOff() 메소드의 경우 새로운 동작은 정의할 수도 있고 그냥 정의를 생략해서 디폴트 구현을 사용할 수도 있다. 그러면 다른 인터페이스가 showOff()와 같은 구현을 포함한다고 가정해보자. 1234interface Focusable&#123; fun setFocus(b: Boolean) = println(\"I $&#123;if (b) \"got\" else \"lost\"&#125; focus. \") fun showOff() = println(\"I'm focusable!! \")&#125; 이제 한 클래스에서 이 두 인터페이스를 함께 구현하면 어떻게 될지 궁금하다. 두 인터페이스 모두 디폴트 구현이 들어있는 showOff() 메소드가 있다. 어느쪽 showOff() 메소드가 선택될까? 결론은 어느쪽도 선택되지 않는다. 클래스가 구현하는 두 상위 인터페이스에 정의된 showOff() 구현을 대체할 오버라이딩 메소드를 직접 제공하지 않으면 컴파일 오류가 발생한다. 이처럼 코틀린 컴파일러는 두 메소드를 아우르는 구현을 하위 클래스에 직접 구현하게 강제한다. 123456789class Button: Clickable, Focusable&#123; override fun click() = println(\"I was clicked!! \") override fun showOff() &#123; super&lt;Clickable&gt;.showOff() super&lt;Focusable&gt;.showOff() // 상위 타입의 이름을 꺽쇠 괄호 사이에 넣어서 super를 지정하면 // 어떤 상위 타입의 메소드를 호출할 지 지정할 수 있다. &#125;&#125; super.showOff()처럼 꺽쇠 괄호 안에 기반 타입 이름을 지정한다. 상속한 구현 중 단 하나만 호출해도 된다면 상위 타입의 메소드를 하나만 지정해도 된다. 2. open, final, abstract 변경자 취약한 기반 클래스라는 문제는 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우에 생긴다. 어떤 클래스가 자신을 상속하는 방법에 대해 정확한 규칙(어떤 메소드를 어떻게 오버라이드해야 하는지 등)을 제공하지 않는다면 그 클래스의 클라이언트는 기반 클래스를 작성한 사람의 의도와 다른 방식으로 메소드를 오버라이드할 위험이 있다. 모든 하위 클래스를 분석하는 것은 불가능하므로 기반 클래스를 변경하는 경우, 하위 클래스의 동작이 예기치 않게 바뀔 수도 있다는 면에서 기반 클래스는 취약하다. 위와 같은 문제를 고려해 코틀린의 클래스와 메소드는 기본적으로 final이다. 어떤 클래스의 상속을 허용하려면 클래스 앞에 open 변경자를 붙여야 한다. 그와 더불어 오버라이드를 허용하고 싶은 메소드 앞에도 open 변경자를 붙여야 한다. 123456789101112// open을 통해서 상속 가능하도록 열려 있음.open class RichButton: Clickable&#123; // final로 하위 클래스에서 오버라이드할 수 없다. fun disable() &#123; &#125; // open을 통해서 오버라이드 가능하도록 열려있다. open fun animate() &#123; &#125; // 상위 클래스에서 선언된 열려있는 메소드를 오버라이드한다. // 오버라이드한 메소드는 기본적으로 열려있다. override fun click() &#123; &#125;&#125; 주의해야 할 점은 기반 클래스나 인터페이스의 멤버를 오버라이드하는 경우 그 메소드는 기본적으로 열려있다. 오버라이드하는 메소드의 구현을 하위 클래스에서 오버라이드하지 못하게 금지하려면 오버라이드하는 메소드 앞에 final 변경자를 붙여 닫혀 있도록 만들어야 한다. 1234open class RichButton: Clickable &#123; final override fun click() &#123; &#125; // 이렇게 함으로써 오버라이드한 메소드는 열려있지 않게 된다.&#125; Tip스마트 캐스트는 타입 검사 뒤에 값이 변경될 수 없는 변수에만 적용이 가능하다. 클래스 프로퍼티의 경우 val이면서 커스텀 접근자가 없는 경우에만 사용할 수 있다는 의미다. 이 요구 사항은 프로퍼티가 final이어야만 한다는 뜻이기도 하다. final이 아니라면 그 프로퍼티를 다른 클래스가 상속하면서 커스텀 접근자를 정의함으로써 스마트 캐스트의 요구 사항을 깰 수도 있기 때문이다. abstract abstract를 사용해 추상 클래스를 선언할 수 있으며, 추상 클래스는 인스턴스화 할 수 없다. 구현이 없는 추상 멤버가 있어 하위 클래스에서 추상 멤버를 오버라이드 해야 한다. 추상 멤버는 항상 열려있다. 따라서 open을 명시할 필요가 없다. 1234567891011abstract class Animated &#123; abstract fun animate() open fun stopAnimating()&#123; &#125; fun animateTwice()&#123; &#125;&#125; 추상 클래스에 속하는 비추상 함수는 기본적으로 final이지만, 원한다면 open으로 오버라이드를 허용할 수 있다. 상속 제어 변경자 인터페이스 멤버의 경우 final, open, abstract를 사용하지 않는다. 인터페이스 멤버는 항상 열려있으며, final로 변경할 수 없다. 인터페이스 멤버에게 본문이 없으면 자동으로 추상 멤버가 되지만, 그래도 따로 abstract를 명시적으로 지정할 필요가 없다. final : 오버라이드할 수 없으며, 이는 클래스 멤버의 기본 변경자다. open : 오버라이드할 수 있으며, 반드시 open을 명시해야 오버라이드할 수 있다. abstract : 반드시 오버라이드해야 하며, 추상 클래스의 멤버에만 이 변경자를 붙일 수 있다. 추상 멤버에는 구현체가 있으면 안된다. override : 상위 클래스나 상위 인스턴스의 멤버를 오버라이드하는 것을 나타낸다. 오버라이드하는 멤버는 기본적으로 열려있다. 하위 클래스의 오버라이드를 금지하라면 final을 명시해야 한다. 가시성 변경자 : 기본적으로 공개 클래스 외부 접근을 제어한다. 어떤 클래스의 구현에 대한 접근을 제한함으로써 그 클래스에 의존하는 외부 코드를 깨지 않고도 클래스 내부 구현을 변경할 수 있다. public, protected, private이 있다. 기본 변경자는 모두 공개된다. 즉, public이다. 코틀린은 패키지를 가시성 제어에 사용하지 않는다. internal은 모듈 내부에서만 볼 수 있다는 뜻이다. 모듈 : 한 번에 한꺼번에 컴파일되는 코틀린 파일들을 의미한다. 자바에서는 패키지가 같은 클래스를 선언하기만 하면 외부의 다른 프로젝트에서 접근이 가능하기 때문에 캡슐화가 깨지기 쉽다. 하지만, 모듈 내부 가시성은 모듈의 구현에 대해 진정한 캡슐화를 제공한다는 장점이 있다. 최상위 선언에 대해 private 가시성을 허용한다. 코틀린의 가시성 변경자 public(기본) : 클래스 멤버와 최상위 선언 모두 모든 곳에서 볼 수 있다. internal : 클래스 멤버, 최상위 선언 모두 같은 모듈 안에서만 볼 수 있다. protected : 클래스 멤버는 하위 클래스 안에서만 볼 수 있으며, 최상위 선언에 적용할 수 없다. private : 클래스 멤버는 같은 클래스 안에서만 볼 수 있으며, 최상위 선언에 적용되면 같은 파일 안에서만 볼 수 있다. 유의해야할 점은 자바에서는 같은 패키지 안에서 protected 멤버에 접근할 수 있지만, 코틀린은 그렇지 않다는 것이다. 코틀린에서 protected 멤버는 오직 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 보인다. 클래스를 확장한 함수는 그 클래스의 private이나 protected 멤버에 접근할 수 없다. 내부 클래스와 중첩된 클래스 클래스 안에 다른 클래스를 선언할 수 있다. 클래스 안에 다른 클래스를 선언하면 도우미 클래스를 캡슐화하거나 코드 정의를 그 코드를 사용하는 곳 가까이에 두고 싶을 때 유용하다. 코틀린의 중첩 클래스는 명시적으로 요청하지 않는 한 바깥쪽 클래스 인스턴스에 대한 접근 권한이 없다. 책의 예제 참고 자바에서는 클래스 안에 정의한 클래스는 자동으로 내부 클래스가 된다. 따라서 내부의 클래스는 바깥 클래스에 대한 참조를 묵시적으로 포함한다. 그 참조로 인해 내부 클래스를 직렬화할 수 없다. 바깥 클래스를 직렬화할 수 없으므로 바깥 클래스에 대한 참조가 내부 클래스의 직렬화를 방해한다. 자바의 내부 클래스 특징 살펴보기 문제를 해결하기 위해서는 내부 클래스를 static으로 선언해야 한다. 중첩 클래스를 static으로 선언하면 그 클래스를 둘러싼 바깥쪽 클래스에 대한 묵시적인 참조가 사라진다. 코틀린에서 중첩된 클래스가 기본적으로 동작하는 방식은 위와 반대이다. 1234567class Button: View &#123; override fun getCurrentState(): State = ButtonState() override fun restoreState(state: State) &#123; .. &#125; class ButtonState: State &#123; .. &#125;&#125; 코틀린 중첩 클래스에 아무런 변경자가 붙지 않으면 자바 static 중첩 클래스와 같다.(즉, 바깥쪽 클래스에 대한 참조가 없다.) 이를 내부 클래스로 변경해서 바깥쪽 클래스에 대한 참조를 포함하게 만들기 위해서는 inner 변경자를 붙이면 된다. 클래스 B 안에 정의된 클래스 A 자바에서는 코틀린에서는 중첩 클래스(바깥쪽 클래스에 대한 참조를 저장하지 않음) static class A class A 내부 클래스(바깥쪽 클래스에 대한 참조를 저장함) class A inner class A 클래스 계층을 만들되 그 계층에 속한 클래스의 수를 제한하고 싶은 경우 중첩 클래스를 쓰면 편리하다. 봉인된 클래스 클래스 계층 정의 시 계층 확장 제한 아래에서는 상위 클래스인 Expr에 숫자를 표현하는 Num과 덧셈 연산을 표현하는 Sum이라는 두 하위 클래스가 존재한다. When 식에서 이 모든 하위 클래스를 처리하면 편리하지만, When 식에서 Num과 Sum이 아닌 경우를 처리하는 else 분기를 반드시 넣어야 한다.1234567891011interface Exprclass Num(val value: Int): Exprclass Sume(val left: Expr, val right: Expr): Expr fun eval(e: Expr) : Int = when(e)&#123; is Num -&gt; e.value is Sum -&gt; eval(e.right) + eval(e.left) else -&gt; throw IllegalArgumentException(\"Unknown expression\") &#125; 코틀린 컴파일러는 when을 사용해 Expr 타입의 값을 검사할 때 꼭 디폴트 분기인 else 분기를 덧붙이게 강제한다. 위의 코드는 else 분기에서 반환할 만한 의미 있는 값이 없으므로 예외를 던진다. 항상 디폴트 분기를 추가하는게 편하지 않다. 그리고 디폴트 분기가 있으면 클래스 계층에 새로운 하위 클래스를 추가하더라도 컴파일러가 when이 모든 경우를 처리하는지 제대로 검사할 수 없다. 혹여나 실수로 새로운 클래스에 대한 처리를 잊어버리더라도 디폴트 분기가 선택되기 때문에 심각한 버그가 발생할 수 있다. 이런 문제에 대한 해답은 sealed 클래스다. 상위 클래스에 sealed 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다. sealed 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스 안에 중첩시켜야 한다. 12345678910sealed class Expr&#123; class Num(val value: Int): Expr() class Sume(val left: Expr, val right: Expr): Expr()&#125; fun eval(e: Expr) : Int = when(e) &#123; is Expr.Num -&gt; e.value is Expr.Sum -&gt; eval(e.right) + eval(e.left) &#125; when 식이 sealed 클래스의 모든 하위 클래스를 검사하므로 별도의 디폴트(else) 분기가 없어도 된다. sealed 클래스는 자동으로 open이 되어 상속 가능하다. 외부에 자신을 상속한 클래스를 둘 수 없다. sealed 클래스에 속한 값에 대해 디폴트 분기를 사용하지 않고 when 식을 사용하면 나중에 sealed 클래스의 상속 계층에 새로운 하위 클래스를 추가해도 when 식이 컴파일되지 않는다. 따라서 when 식을 고쳐야 한다. 내부적으로 Expr 클래스는 private한 생성자를 가진다. 그 생성자는 클래스 내부에서만 호출할 수 있다. sealed 인터페이스를 정의할 수는 없다. 왜그럴까? 봉인된 인터페이스를 만들 수 있다면 그 인터페이스를 자바 쪽에서 구현하지 못하게 막을 수 있는 수단이 코틀린 컴파일러에게 없기 때문이다. 코틀린 1.1부터는 sealed 클래스와 같은 파일의 아무데서나 상위 클래스를 상속한 하위 클래스를 만들 수 있고, 데이터 클래스로 하위 클래스를 정의할 수도 있다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"}]},{"title":"[Kotlin] 문자열과 정규식 다루기","slug":"Chap3-2","date":"2019-10-03T15:59:40.000Z","updated":"2019-10-04T06:34:26.272Z","comments":true,"path":"2019/10/04/Chap3-2/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/04/Chap3-2/","excerpt":"","text":"해당 포스팅은 코틀린 인 액션 책을 보며 정리한 내용입니다. 주관적인 생각이 포함되어 있으니 다른 의견이 있으시다면 적극적으로 알려주시면 감사합니다. 문자열과 정규식 다루기 다양한 확장 함수를 제공함으로써 표준 자바 문자열을 더 잘 다룰 수 있게 해준다. 1. 문자열 나누기 코틀린에서는 자바의 split 대신에 여러 가지 다른 조합의 파라미터를 받는 split 확장 함수를 제공한다. 이는 정규식을 파라미터로 받는 함수는 String이 아닌 Regex 타입의 값을 받는다. 아래는 마침표나 대시로 문자열을 분리하는 예이다.12345678println(\"12.345-6.A\".split(\"\\\\.|-\".toRegex()))// toRegex()를 통해 명시적으로 정규식을 만든다.// 결과 : [12, 345, 6, A]println(\"12.345-6.A\".split(\".\",\"-\"))// 간단한 정규식일 경우, 구분 문자열을 하나 이상 인자로 받는 오버로딩된 함수를 호출하면 된다.// 결과 : [12, 345, 6, A] 코드 다듬기 로컬 함수와 확장 코틀린에서는 함수에서 추출한 함수를 원 함수 내부에 중첩시킬 수 있다. 그렇게 하면 문법적인 비용을 들이지 않고도 깔끔하게 코드를 조직할 수 있다. 중복 코드를 로컬 함수를 통해 제거할 수 있다. 중복되는 부분을 함수로 작성하고 함수 내에서 중첩시켜서 로컬 함수로 만든다. 이를 통해 중복 부분을 제거할 수 있다. 하지만, 중첩된 함수의 깊이가 깊어지면 코드를 읽기 어려워진다. 따라서 일반적으로 한 단계만 함수를 중첩시킨다. 요약 자체 컬렉션 클래스를 정의하지 않지만, 자바 클래스를 확장해서 더 풍부한 API를 제공한다. 함수 파라미터의 디폴트 값을 정의하면 오버로딩한 함수를 정의하지 않아도 된다. 이름 붙인 인자를 사용해 함수 호출 시의 가독성을 높일 수 있다. 코틀린은 클래스 멤버가 아니라 최상위 함수와 프로퍼티를 직접 선언할 수 있다. 이를 활용해 코드 구조를 더 유연하게 만들 수 있다. 확장 함수와 프로퍼티를 사용하면 외부 라이브러리에 정의된 클래스를 포함해 모든 클래스의 API를 그 클래스의 소스 코드를 바꿀 필요 없이 확장할 수 있다. 확장 함수를 사용해도 실행 시점에 부가 비용이 들지 않는다. 중위 호출을 통해 인자가 하나 밖에 없는 메소드나 확장 함수를 더 깔끔한 구문으로 호출할 수 있다. 정규식과 일반 문자열을 처리할 때 다양한 문자열 처리함수를 제공한다. 3중 따옴표 문자열을 사용하면 이스케이프와 같은 처리를 깔끔하게 할 수 있다. 로컬 함수를 사용해 코드를 더 깔끔하게 유지하면서 중복을 제거할 수 있다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"}]},{"title":"[Kotlin] 함수 정의와 호출","slug":"Chap3-1","date":"2019-09-29T13:08:18.000Z","updated":"2019-10-04T05:35:19.373Z","comments":true,"path":"2019/09/29/Chap3-1/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/29/Chap3-1/","excerpt":"","text":"해당 포스팅은 코틀린 인 액션 책을 보며 정리한 내용입니다. 주관적인 생각이 포함되어 있으니 다른 의견이 있으시다면 적극적으로 알려주시면 감사합니다. 코틀린에서 컬렉션코틀린는 자체 컬렉션을 제공하지 않는다. 대신에 기존 자바의 컬렉션을 활용할 수 있다. 이는 자바 코드와 상호작용하기가 훨씬 쉽다는 것을 의미한다. 자바에서 코틀린 함수를 호출하거나 코틀린에서 자바 함수를 호출할 때 자바와 코틀린을 서로 변환할 필요가 없다. 하지만, 코틀린에서는 좀 더 다양한 기능을 제공하기도 한다. 예를 들면, 리스트에서 가장 마지막 원소를 가져오거나 수로 이뤄진 컬렉션에서 최대값을 찾을 수 있다. 이름 붙인 인자 매개변수가 많은 함수를 호출할 때, 내가 전달하는 인자가 어떤 역할을 하는지 확인하기 어려운 경우가 많다. 우리가 함수의 시그니처를 외우거나 IDE가 함수 시그니처를 표시해서 도움을 줄 수 있겠지만, 함수 호출 코드 자체는 여전히 모호하다. 코틀린에서는 이러한 문제를 해결하기 위해서 작성한 함수를 호출할 때는 함수에 전달하는 인자 중 일부(또는 전부)의 이름을 명시할 수 있다. 일반적으로 인자 중 어느 하나라도 이름을 명시하고 나면 혼동을 줄이기 위해 나머지 인자도 모두 이름을 붙여주는 것이 좋다. 1joinToString(collection, separator = \" \", prefix = \" \", postfix = \" \") 디폴트 파라미터 값 자바에서는 일부 클래스에서 오버로딩한 메소드가 많아진다는 문제가 있다. 오버로딩을 통해 편의를 줄 수 있지만, 많아진다면 결국 중복이라는 결과를 얻게 된다. 코틀린에서는 함수 선언에서 디폴트 파라미터 값을 지정할 수 있으므로 오버로드 중 상당수를 피할 수 있다. 함수를 선언하는 곳에서 지정된다. 위에서 함수 호출만 작성했던 joinToString() 함수를 작성해보자. 아무 접두사나 접미사 없이 콤마로 원소를 구분한다. 123456fun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String = \",\". prefix: String = \" \", postfix: String = \" \"): String 함수를 호출할 때, 모든 인자를 쓸 수도 있고 일부를 생략해서 쓸 수도 있다.12345678joinToString(list, \", \", \"\",\"\")// 결과 : 1, 2, 3joinToString(list)// 결과 : 1, 2, 3joinToString(list, \"; \")// 결과 : 1; 2; 3 이름 붙은 인자를 사용하면 인자 목록의 중간에 있는 인자를 생략하고 지정하고 싶은 인자를 이름을 붙여 순서와 상관없이 호출할 수 있다. 디폴트 값과 자바 자바에는 해당 개념이 없어서 코틀린 함수를 호출하는 경우에는 그 코틀린 함수가 디폴트 파라미터 값을 제공하더라도 모든 인자를 명시해야 한다. 그래서 자바에서 코틀린 함수를 자주 호출해야 한다면, 편하게 호출할 수 있는 방법에 대해 생각해봐야 한다. @JvmOverloads 어노테이션을 함수에 추가하면 코틀린 컴파일러가 자동으로 맨 마지막 파라미터부터 하나씩 생략한 오버로딩한 메소드를 추가해주어 자바에서 디폴트 파라미터를 사용하는 코틀린 함수를 쉽게 호출할 수 있다. 정적인 유틸리티 클래스 없애기 : 최상위 함수와 프로퍼티 코틀린에서는 함수가 클래스 안에 없어도 된다. 다양한 정적 메소드를 모아두며 특별한 상태나 인스턴스 메소드는 없는 클래스가 생겨난다. JDK의 Collections 클래스가 전형적인 예이다. 코틀린에서는 무의미한 클래스가 필요없다. 대신 함수를 직접 소스 파일의 최상위 수준, 모든 다른 클래스의 밖에 위치시키면 된다. 최상위 함수를 선언해보자. 아래와 같이 join.kt 파일을 만들어보자.1234package stringsfun joinToString()&#123; // 생략.&#125; 이 함수가 어떻게 실행될까? JVM이 클래스 안에 들어있는 코드만을 실행할 수 있기 때문에 컴파일러는 이 파일을 컴파일할 때 새로운 클래스를 정의해준다. 그러면 자바 등의 다른 JVM 언어에서 호출하고 싶다면 코드가 어떻게 컴파일되는지 알아야 joinToString과 같은 최상위 함수를 사용할 수 있다. 코틀린이 join.kt를 컴파일하는지 보여주기 위해 join.kt를 컴파일한 결과와 같은 클래스를 자바 코드로 써보면 다음과 같다. 123456package strings;public class JoinKt&#123; public static String joinToString()&#123; // 생략. &#125;&#125; 코틀린 컴파일러가 생성하는 클래스의 이름은 최상위 함수가 들어있던 코틀린 소스 파일의 이름과 대응한다. 코틀린 파일의 모든 최상위 함수는 이 클래스의 정적인 메소드(static)가 된다. 따라서 자바에서 joinToString()을 호출하기 쉽다.JoinKt.joinToString(list,&quot;, &quot;,&quot;&quot;,&quot;&quot;); 최상위 프로퍼티 함수와 마찬가지로 프로퍼티도 파일의 최상위 수준에 놓을 수 있다. 이런 프로퍼티의 값은 정적 필드에 저장된다. 최상위 프로퍼티를 활용해 코드에 상수를 추가할 수도 있다. const 키워드를 사용하면 프로퍼티를 public static final 즉, 상수로 선언할 수 있으며 이 필드로 컴파일하게 만들 수 있다.(단, 원시 타입과 String 타입의 프로퍼티만 const로 지정할 수 있다.)12345const val NUMBER = 10 public static final int NUMBER = 10; // 위의 두 문장은 같다. 확장 함수와 확장 프로퍼티 기존 코드와 코틀린 코드를 자연스럽게 통합하는 것은 어려운 목표다. 코틀린을 기존 자바 프로젝트에 통합하는 경우에는 코틀린으로 직접 변환할 수 없거나 미처 변환하지 않은 기존 자바 코드를 처리할 수 있어야 한다. 이런 기존 자바 API를 재작성하지 않고도 코틀린이 제공하는 여러 편리한 기능을 사용할 수 있다면 좋을 것이다. 바로 확장 함수 가 그런 역할을 해준다. 확장 함수는 어떤 클래스의 멤버 메소드인 것처럼 호출할 수 있지만, 그 클래스의 밖에 선언된 함수이다. fun String.lastChar(): Char = this.get(this.length - 1) 위의 함수는 문자열의 마지막 문자를 반환하는 함수이다. 확장 함수를 만드는 것은 간단하다. 추가하려는 함수 이름 앞에 그 함수가 확장할 클래스의 이름을 덧붙이면 된다. 클래스의 이름을 수신 객체 타입이라고 한다. 확장 함수가 호출되는 대상이 되는 값(객체) 수신 객체라 부른다. 위의 코드에서 String이 수신 객체 타입이고, this가 수신 객체이다. 수신 객체 타입 : 확장이 정의될 클래스 수신 객체 : 그 클래스에 속한 인스턴스 객체 12println(\"kotlin\".lastChar())// 호출 String이 어떤 언어로 작성되었는가는 중요하지 않다. 자바 클래스로 컴파일한 클래스 파일이 있는 한 그 클래스에 원하는 대로 확장을 추가할 수 있다. this를 생략할 수 있다. 1fun String.lastChar(): Char = get(length - 1) 확장 함수가 캡슐화를 깨지는 않는다. 클래스 안에서 정의한 메소드와 달리 확장 함수 안에서는 클래스 내부에서만 사용할 수 있는 private, protected 멤버를 사용할 수 없다. 호출하는 쪽에서는 확장 함수와 멤버 메소드를 구분할 수 없고, 호출하는 메소드가 확장 함수인지 멤버 메소드인지 여부가 중요하지 않다. 임포트와 확장 함수 확장 함수를 정의했다고 프로젝트의 모든 소스 코드에서 사용할 수 있는 건 아니다. 확장 함수를 사용하기 위해서 그 함수를 다른 클래스나 함수와 마찬가지로 임포트해야만 한다. 자바와 마찬가지로 임포트할 때 동일한 구문을 사용하면 된다. 개별 함수를 임포트할 수도 있으며, *를 사용한 임포트도 잘 작동한다. 그리고 as 키워드를 사용해 임포트한 클래스나 함수를 다른 이름으로 부를 수 있다.123import strings.lastCharimport strings.*import strings.lastChar as last 다른 여러 패키지에 이름이 같은 함수가 많은데 한 파일 안에서 그런 함수들을 함께 써야 하는 경우 이름을 바꿔서 임포트하면 편리하다. 일반적인 클래스나 함수라면 다른 방법도 있다. 해당 클래스나 함수를 부를 때 전체 이름을 쓰면 된다. 하지만, 확장 함수는 코틀린 문법상 반드시 짧은 이름을 써야 한다. 따라서 임포트시 이름을 바꾸는 방법이 확장 함수의 이름 충돌을 해결하는 좋은 방법이 된다. 자바에서 확장 함수 호출 내부적으로 확장 함수는 수신 객체를 첫 번째 인자로 받는 정적 메소드다. → 실행 시점 부가 비용이 들지 않는다. 자바에서 확장 함수를 사용하기 편리하다. 1char c = StringUtilKt.lastChar(\"Java\") 코틀린은 아래와 같다. 1val c = \"Java\".lastChar() 가변 인자 함수 인자의 개수가 달라질 수 있는 함수 정의 파라미터 앞에 vararg 변경자를 붙인다. 이미 배열에 들어있는 원소를 가변 길이 인자로 넘길 때도 코틀린과 자바 구문이 조금 다르다. 코틀린에서는 배열을 명시적으로 풀어서 배열의 각 원소가 인자로 전달되게 해야 한다. 기술적으로는 스프레드 연산자가 그런 작업을 해준다. 실제로 전달하려는 배열 앞에 *를 붙이면 된다.12345fun main(args: Array&lt;String&gt;)&#123; val list = listOf(\"args:\", *args) // 스프레드 연산자가 배열의 내용을 펼쳐준다. println(list)&#125; 값의 쌍 다루기 중위 호출과 구조 분해 선언 to는 중위 호출이라는 특별한 방식으로 to라는 일반 메소드를 호출한 것이다. 중위 호출 시에는 수신 객체와 유일한 메소드 인자 사이에 메소드 이름을 넣는다. (이때 객체, 메소드 이름, 유일한 인자 사이에는 공백이 들어가야 한다.) 아래의 두 호출은 동일하다. 12341.to(\"one\")// to 메소드를 일반적인 방식으로 호출함.1 to \"one\"// to 메소드를 중위 호출 방식으로 호출함. 인자가 하나뿐인 일반 메소드나 인자가 하나뿐인 확장 함수에 중위 호출을 사용할 수 있다. 함수(메소드)를 중위 호출에 사용하게 허용하고 싶으면 infix 변경자를 함수(메소드) 앞에 추가해야 한다. 이어지는 내용으로 to 함수는 Pair 인스턴스를 반환한다. 이는 코틀린 표준 라이브러리 클래스로 두 원소로 이루어진 쌍을 표현한다. Pair의 내용으로 두 변수를 즉시 초기화할 수 있다. 123456val (number, name) = 1 to \"Lee\"// 루프에서 구조 분해 선언 사용for ((index, element) in collection.withIndex())&#123; println(\"$index: $element\")&#125; 이와 같은 기능을 구조 분해 선언이라고 한다. 구조 분해 선언은 Pair나 Map 객체에서 key와 value를 분해해서 한 번에 변수를 담을 때 사용할 수 있다. 또한, 반복문과 같은 루프에서도 사용할 수 있다. to 함수는 타입과 관계 없이 임의의 순서쌍을 만들 수 있다. 즉, to의 수신 객체가 제네릭하다. listOf와 마찬가지로 mapOf에도 원하는 개수만큼 인자를 전달할 수 있지만, 각 인자가 키와 값으로 이뤄진 순서쌍이어야 한다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"}]},{"title":"[ETC] 함수와 메소드의 차이","slug":"Function-Method-Dif","date":"2019-09-29T09:42:09.000Z","updated":"2019-09-29T09:49:24.251Z","comments":true,"path":"2019/09/29/Function-Method-Dif/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/29/Function-Method-Dif/","excerpt":"","text":"개발을 하다보면 함수와 메소드라는 말을 자주 접하고 듣는다. 어찌보면 개발자에게 있어서 없어서는 안되는 것이기도 하다. 그런데 어떤 상황에서는 함수라고 하고 어떤 상황에서는 메소드라고 한다. 둘의 차이가 뭔지 궁금해서 해당 글을 포스팅해본다. 함수(Function) 특정 작업을 수행하는 코드 조각이다. 전역이던 지역이던 독립된 기능을 수행하는 단위다. 함수가 메소드를 포함하고 있다. 함수가 더 포괄적인 개념이다. 메소드(Method) 클래스, 구조체, 열거형에 포함되어 있는 함수를 메소드라고 부른다. 다른말로 클래스 함수라고도 한다. 예제12345678910111213// 함수fun printFunction()&#123; println(\"Fuction\")&#125;class Person&#123; val name: String = \"Victory\" // 메소드 fun printMethod()&#123; println(\"$name Method\") &#125;&#125;","categories":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/categories/ETC/"}],"tags":[{"name":"함수","slug":"함수","permalink":"http://victorywoolee/victorywoolee.github.io/tags/함수/"},{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/tags/ETC/"},{"name":"메소드","slug":"메소드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/메소드/"},{"name":"함수와 메소드 차이","slug":"함수와-메소드-차이","permalink":"http://victorywoolee/victorywoolee.github.io/tags/함수와-메소드-차이/"}]},{"title":"[Clean Code] 6장","slug":"CleanCode06","date":"2019-09-27T15:28:28.000Z","updated":"2019-09-29T09:40:00.689Z","comments":true,"path":"2019/09/28/CleanCode06/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/28/CleanCode06/","excerpt":"","text":"자료 추상화아래의 두 코드 차이를 살펴보자. 두 클래스 모두 2차원 점을 표현한다. 그런데 한 클래스는 구현을 외부로 노출하고 다른 클래스는 구현을 완전히 숨긴다. 구체적인 Point 클래스 1234public class Point&#123; public double x; public double y;&#125; 추상적인 Point 클래스 12345678public interface Point&#123; double getX(); double getY(); void setCartesian(double x, double y); double getR(); double getTheta(); void setPolar(double r, double theta);&#125; 추상적인 Point 클래스에서는 직교 좌표계를 사용하는지 극좌표계를 사용하는지 알 수 없다. 둘 다 아닐 수도 있다. 그럼에도 불구하고 인터페이스는 자료구조를 명백하게 표현한다. 사실, 자료 구조 이상을 표현한다. 클래스 메소드가 접근 정책을 강제한다. 또한, 좌표를 읽을 때는 각 값을 개별적으로 읽어야 한다. 하지만 좌표를 설정할 때는 두 값을 한꺼번에 설정해야 한다. 구체적인 Point 클래스는 직교좌표계를 사용하며 구현을 노출한다. 변수를 private으로 선언하더라도 각 값마다 조회, 설정 함수를 제공한다면 구현을 외부로 노출하는 셈이다. 변수 사이에 함수라는 계층을 넣는다고 구현이 감춰지지는 않는다. 구현을 감추기 위해서는 추상화가 필요하다. 그저 조회, 설정 함수로 변수를 다룬다고 클래스가 되지 않는다. 그보다는 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다. 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋다. 인터페이스나 조회,설정 함수만으로는 추상화가 이뤄지지 않는다. 개발자는 객체가 포함하는 자료를 표현할 수 있는 가장 좋은 방법을 심각하게 고민해야 한다. 아무 생각 없이 조회, 설정 함수를 추가하는 방법이 가장 나쁘다. 자료/객체 비대칭 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다. 자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다. 아래는 객체 지향적인 도형 클래스다. area()는 다형성 메소드다. 그러므로 새 도형을 추가해도 기존 함수에 아무런 영향을 미치지 않는다. 반면, 새 함수를 추가하고 싶다면 도형 클래스 전부를 고쳐야 한다. 12345678910111213141516171819202122232425262728public class Square implements Shape&#123; private Point topLeft; private double side; public double area()&#123; return side * side; &#125;&#125;public class Rectangle implements Shape&#123; private Point topLeft; private double height; private double width; public double area()&#123; return height * width; &#125;&#125;public class Circle implements Shape&#123; private Point center; private double radius; public final double PI = 3.14159; public double area()&#123; return PI * radius * radius; &#125;&#125; 자료 구조를 사용하는 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다. 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다. 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 상속 받는 클래스에서 모든 클래스를 고쳐야 한다. 디미터 법칙 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다. 객체는 자료를 숨기고 함수를 공개한다. 즉, 객체는 조회 함수로 내부 구조를 공개하면 안된다는 의미다. 그러면 내부 구조를 숨기지 않고 노출하는 셈이 된다. 좀 더 정확하게 표현해서 “클래스 C의 메소드 f는 다음과 같은 객체의 메소드만 호출해야 한다.“고 주장한다. 클래스 C f가 생성한 객체 f 인수로 넘어온 객체 C 인스턴스 변수에 저장된 객체 위 객체에서 허용된 메소드가 반환하는 객체의 메소드는 호출하면 안된다. 낮선 사람은 경계하고 친구랑만 놀라는 의미다. 기차 충돌 여러 객차가 한 줄로 이어진 기차처럼 보이는 코드이다. 일반적으로 조잡하다 여겨지는 방식이므로 피하는 편이 좋다. 흔히 아래와 같은 코드를 기차 충돌이라 부른다. 1final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath(); 위의 코드는 아래와 같이 나누는 편이 좋다. 123Options opts = ctxt.getOptions();File scratchDir = opts.getScratchDir();final String outputDir = scratchDir.getAbsolutePath(); 위의 코드에서는 함수 하나가 아는 지식이 굉장히 많다. 즉 함수가 많은 객체를 탐색할 줄 안다는 의미다. 위 코드가 디미터 법칙을 위반하는지 여부는 ctxt, Options, ScratchDir이 객체인지 아니면 자료 구조인지에 달렸다. 객체라면 내부 구조를 숨겨야 하므로 확실히 디미터 법칙을 위반한다. 반면, 자료구조라면 당연히 내부 구조를 노출하므로 디미터 법칙이 적용되지 않는다. 위 코드는 조회 함수를 사용해서 혼란을 일으킨다. 코드를 아래와 같이 구현했다면 디미터 법칙을 거론할 필요가 없어진다. 1final String outputDir = ctxt.options.scratchDir.absolutePath; 자료 구조는 무조건 함수 없이 공개 변수만 포함하고 객체는 비공개 변수와 공개 함수를 포함한다면 문제는 훨씬 간단하다. 하지만, 단순한 자료 구조에도 조회 함수와 설정 함수를 정의하라 요구하는 프레임워크와 표준이 존재한다. 잡종 구조 혼란으로 말미암아 절반은 객체, 절반은 자료 구조인 잡종 구조가 나온다. 이런 잡종 구조는 새로운 함수는 물론이고 새로운 자료 구조도 추가하기 어렵다. 단점만 모아놓았다. 그러므로 잡종 구조는 피하는 편이 좋다. 구조체 감추기 만약 위에서 사용했던 ctxt, options, scratchDir이 진짜 객체라면 앞의 예제처럼 줄줄이 사탕으로 엮어서는 안된다. 객체라면 내부 구조를 감춰야 하기 때문이다. 그렇다면 임시 디렉토리의 절대 경로는 어떻게 얻어야 좋을까? 다음 두 코드를 참고해보자.12ctxt.getAbsolutePathofScratchDirectoryOption();ctxt.getScratchDirectoryOption().getAbsolutePath(); 첫 번째 방법은 ctxt 객체에 공개해야 하는 메소드가 너무 많아진다. 두 번째 방법은 getScratchDirectoryOption()이 객체가 아니라 자료 구조를 반환한다고 가정한다. 어느 방법도 내키지 않는다. ctxt가 객체라면 뭔가를 하라고 말해야지 속을 드러내라고 말하면 안된다. 임시 디렉토리의 절대 경로는 왜 필요할까? 이유는 임시 파일을 생성하기 위한 목적이 있기 때문이다. 그렇다면 ctxt 객체에 임시 파일을 생성하라고 시키면 어떨까? 1BufferedOutputStream bos = ctxt.creteScratchFileStream(classFileName); 이는 객체에게 맡기기에 적당한 임무로 보인다. ctxt는 내부 구조를 드러내지 않으며, 모듈에서 해당 함수는 자신이 몰라야 하는 여러 객체를 탐색할 필요가 없다. 따라서 디미터 법칙을 위반하지 않는다.ㄴ 자료 전달 객체 자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다. 자료 전달 객체(Data Transfer Object, DTO)라고 한다. 데이터베이스와 통신하거나 소켓에서 받은 메시지의 구문을 분석할 때 유용하다. 흔히 DTO는 데이터베이스에 저장된 가공되지 않은 정보를 애플리케이션 코드에서 사용할 객체로 변환하는 일련의 단계에서 처음으로 사용하는 구조체다. 활성 레코드 DTO의 특수형 형태다. 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료 구조지만, 대게 save나 find와 같은 탐색 함수도 제공한다. 활성 레코드는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과다. 활성 레코드에 비즈니스 규칙 메소드를 추가하면 자료 구조도 아니고 객체도 아닌 잡종 구조가 나오기 때문에 이렇게 만드는 것은 바람직하지 않다. 활성 레코드는 자료 구조로 취급한다. 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체는 따로 생성한다. 결론 객체는 동작을 공개하고 자료를 숨긴다. 그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면, 기존 객체에 새 동작을 추가하기는 어렵다. 자료 구조는 별다른 동작 없이 자료를 노출한다. 그래서 기존 자료 구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다. 시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다. 다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다. 우수한 소프트웨어 개발자는 편견없이 이 사실을 이해해 직면한 문제에 최적인 해결책을 선택한다.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"객체와 자료구조","slug":"객체와-자료구조","permalink":"http://victorywoolee/victorywoolee.github.io/tags/객체와-자료구조/"}]},{"title":"[ETC] Freeze","slug":"Freeze","date":"2019-09-27T14:45:17.000Z","updated":"2019-09-27T15:04:40.602Z","comments":true,"path":"2019/09/27/Freeze/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/27/Freeze/","excerpt":"","text":"회사에서 들은 용어 중 Feture Freeze라는 말이 있다. 이 말을 들으면서 어떤 의미인지 알겠지만, 정확하게 정리가 안되서 간단하게 정리하고 넘어가려고 이 글을 작성한다. 해당 글은 필자의 생각을 바탕으로 작성한 글로 잘못된 내용이 포함되었을 수 있습니다. 의견이 있으면 댓글을 남겨주세요! Feature Freeze검색해보니까 한글로 된 자료는 거의 찾아보기 힘들다. Feature Freeze와 Code Freeze라는 용어가 있는데 필자가 생각하기에는 두 용어 거의 비슷한 것으로 보인다. 어떤 기능을 개발할 때, 브랜치를 나눠 작업을 한다. 이때, 브랜치를 Feature 단위로 나눈다고 한다. Feature가 하나의 작은 작업 단위라고 생각하면 될 것이다. 예를 들면, 로그인 기능을 개발한다고 하자. 간단하게 아래와 같은 작업이 필요할 것이다. 로그인 UI 작성 로그인 기능 구현 로그인 상태 판단 간단하게 생각나는 대로 적었을 때, 3개로 나눌 수도 있다. 더 쪼갤 수도 있고 2번과 3번을 합칠 수도 있다. 이때 작업 단위 하나 하나를 Feature라고 부른다. 그리고 로그인 기능이 이번에 배포에 포함된다고 해보자. 수요일이 정기 배포일이라고 한다면 배포에 포함될 기능들이 완료되어 feature 브랜치로 모여야 한다. 그리고 develop과 master에 merge가 되고 배포가 이루어져야 한다. 이 과정을 Feature Freeze 혹은 Code Freeze라고 한다. 배포를 하기 위해 진행했던 작업들(코드)이 합쳐지고 배포가 이루어지는 일련의 과정을 의미하는 것이다.","categories":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/categories/ETC/"}],"tags":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/tags/ETC/"},{"name":"Freeze","slug":"Freeze","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Freeze/"}]},{"title":"[Android] EditText","slug":"Android-EditText","date":"2019-09-27T14:24:29.000Z","updated":"2019-09-27T14:37:41.124Z","comments":true,"path":"2019/09/27/Android-EditText/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/27/Android-EditText/","excerpt":"","text":"EditTextAndroid에서 사용자 입력, 검색을 받기 위해서 EditText를 사용한다. 기본적으로는 키보드가 올라오면 엔터키 자리가 줄바꿈으로 되어있을 것이다. 하지만, 기획과 개발에서 요구하는 사항에 따라서 해당 엔터키가 특정 동작을 하길 원할 수도 있다. 나는 검색 관련 기능을 구현하면서 엔터키가 검색 버튼이며 검색 기능을 동작했으면 했다. 그래서 엔터키를 검색 아이콘으로 변경했다. xml과 코드 상에서 모두 변경 가능하며 아래는 xml에서 변경하는 방식이다. 1234567891011&lt;EditText android:id=\"@+id/search_query\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:background=\"@color/transparent\" android:imeOptions=\"actionSearch\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toStartOf=\"@id/btn_clear\" app:layout_constraintStart_toEndOf=\"@id/btn_back\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_goneMarginEnd=\"16dp\" /&gt; 그리고 엔터키가 검색 동작임을 확인해서 원하는 기능을 구현할 수 있다. 아래와 같이 리스너를 달아주어 어떤 이벤트인지와 입력되는 값을 캐치할 수 있다. 123456searchQuery.setOnEditorActionListener &#123; query, id, _ -&gt; if(EditorInfo.IME_ACTION_SEARCH == id)&#123; viewModel.searchDestination(query.text.toString()) &#125; true &#125; 리스너를 달아주고 들어오는 이벤트의 id가 위에서 설정했던 actionSearch와 같다면 viewModel의 쿼리를 날려 검색 결과를 보여주는 간단한 기능이다. 참고 imeOptions 종류","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"EditText","slug":"EditText","permalink":"http://victorywoolee/victorywoolee.github.io/tags/EditText/"}]},{"title":"[ETC] Super App","slug":"SuperApp","date":"2019-09-27T14:00:57.000Z","updated":"2019-09-27T14:23:05.724Z","comments":true,"path":"2019/09/27/SuperApp/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/27/SuperApp/","excerpt":"","text":"이 글은 슈퍼앱이라는 단어를 듣고 무엇인지 생각해보고 검색해서 어느 글을 참고해서 정리한 글입니다. 플랫폼의 시대는 저물고 있다.조금은 슬픈 이야기지만, 플랫폼의 시대는 저물고 있다. 2000년대와 2010년대 초반까지 가장 화두가 되는 키워드는 플랫폼이었다. ‘누가 세상에 없는 서비스를 만들어내는가?‘와 같은 여태까지 없던 새로움이 승부를 결정짓는 중요한 포인트였다. 페이스북, 유튜브, 위챗, 인스타그램 등과 같은 플랫폼은 각자의 장점을 가지고 오랜 기간동안 많은 사용자를 모았다. 이를 통해서 굉장한 가치를 쌓아나갔다. 하지만, 최근에는 많은 스타트업도 있고 이 중에서 플랫폼도 많이 늘어나고 있다. 그래서 포화상태에 이르렀다. 이 사이에서 새로움을 찾는 것은 힘들다. 말 그대로 플랫폼의 시대는 저물고 있으며, 이제는 기술력과 컨텐츠, 그리고 슈퍼앱의 시대가 오고 있다. PC? 이젠 모바일이지.2010년부터 빠르게 진행된 스마트폰 보급 덕분에 모바일 시장은 엄청난 속도로 성장했다. 그래서 모바일 개발자들도 많이 늘어났다. 어느 리서치의 결과에 따르면 모바일을 통한 소비가 2014년도를 기준으로 계속 성장하고 있음을 밝혔다. PC에서 모바일로 변화하게 된 가장 큰 원인은 접근성의 차이다. 스마트폰이 보편화됨에 따라 예전에는 PC 웹에서만 가능하던 일들이 이제는 손에 들려있는 핸드폰에서도 가능하게 되었기 때문이다. 정보 검색에서부터 자료 수집, 관련 자료 시청, 상품 주문, 결제까지 할 수 있게 되었다. 슈퍼앱?이제 슈퍼앱에 대해 이야기를 해보자. 검색을 하면 슈퍼앱이라는 단어가 위챗과 많은 연관이 있는 것으로 보인다. 그 이유는 위챗은 위챗 하나로 다른 앱들은 필요 없고 위챗에서 생활에 필요한 전반적인 서비스를 이용할 수 있게 만들기 위해 슈퍼앱으로 만들려는 목표를 가졌다고 한다. 스마트폰이 많이 활성화됨에 따라서 사람들의 일상 대부분은 스마트폰을 통해서 이루어진다. 음식 주문, 옷 결제, 연락, 약속 등등 대부분을 스마트폰으로 할 수 있다. 이런 편의를 제공하기 위한 앱들도 많다. 하지만, 앱이 너무 많아서 사용자들은 이런 저런 앱을 깔았다 지우기도 한다. 자주 사용하지 않는 앱의 경우 삭제할 가능성이 크다. 이와 같은 사용자의 불편함을 해소 할 수 있는 방안이 슈퍼앱인 것이다. 회사 생활을 하다보니 처음 들어보는 용어가 많다. 그리고 들어본 것 같지만 의미를 모르는 것도 많다. 이런 용어나 새로운 개념에 대해서도 정리하는 공간을 만들 것이다. 개발만 공부한다고 다가 아니라는 것을 느끼는 요즘이다.","categories":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/categories/ETC/"}],"tags":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/tags/ETC/"},{"name":"Super App","slug":"Super-App","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Super-App/"}]},{"title":"[Android] Two-Way Data Binding","slug":"Android-Two-Way-Binding","date":"2019-09-23T05:48:31.000Z","updated":"2019-09-27T13:59:35.700Z","comments":true,"path":"2019/09/23/Android-Two-Way-Binding/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/23/Android-Two-Way-Binding/","excerpt":"","text":"해당 글은 데이터 바인딩에 대한 사전 지식을 가지고 있으면 이해가 수월합니다. 위의 그림을 통해서 알 수 있듯이 View와 ViewModel이 데이터바인딩을 통해 느슨하게 연결되고 Model은 View가 아닌 ViewModel과 통신하게 된다. 원칙적으로 View는 ViewModel에게 일방적으로 작업을 던지고 ViewModel은 직접적으로 View를 알지 못하기 때문에 데이터바인딩을 통해서만 View가 갱신된다. 그래서 대부분의 상황에서 ViewModel의 변화로 인해 ViewModel -&gt; View 방향으로 전달되는 일방통행의 데이터바인딩이 만들어진다. 하지만, 그림에서도 볼 수 있듯이 반대의 경우도 가능하다. 2-way 데이터바인딩은 여기서 나오는 개념이며 양방향 데이터바인딩이라고도 한다. 이에 대해 알아보기 위해서 구글 공식 문서를 찾아봤지만, 생각보다 설명이 친절하지 않았다. 그래도 일단 공식 문서의 내용을 정리해보겠다. Google DeveloperTwo Way DataBinding은 다음과 같이 두 가지 방식으로 구현할 수 있다. ObservableField를 사용하는 방법 notifyPropertyChanged() 메소드를 사용하는 방법 1. @Bindable과 notifyPropertyChanged()를 사용하는 방법단방향 데이터바인딩을 사용해 xml의 속성에 값을 설정하고 해당 속성의 변경에 반응하도록 설정할 수 있다. 코드는 아래와 같다. 12345&lt;CheckBox android:id=\"@+id/rememberMeCheckBox\" android:checked=\"@&#123;viewmodel.rememberMe&#125;\" android:onCheckedChanged=\"@&#123;viewmodel.rememberMe&#125;\"/&gt; 체크 박스를 이용해서 처음 상태는 뷰모델의 rememberMe 상태로 초기화를 하고 변경되면 뷰모델의 rememberMe를 참조해서 속성의 변경에 반응하도록 설정할 수 있다. 양방향 데이터바인딩을 사용하면 위의 과정을 단축시킬 수 있다. 1234&lt;CheckBox android:id=\"@+id/rememberMeCheckBox\" android:checked=\"@=&#123;viewmodel.rememberMe&#125;\"/&gt; @={} 표기법은 = 표기법이 기존의 단방향 데이터바인딩과의 차이점이다. 그리고 이는 속성에 대한 데이터 변경사항을 수신하고 동시에 사용자 업데이트를 듣는다. 레이아웃에 있는 뒤쪽의 데이터의 변화에 반응하기 위해, 레이아웃 변수를 Observable 구현으로 만들 수 있다. 보통 BaseObservable()을 구현하고 코드에서 @Bindable 어노테이션을 사용한다. 12345678class User: BaseObservable()&#123; @get:Bindable var firstName: String = \"\" set(value) &#123; field = value notifyPropertyChanged(BR.firstName) &#125;&#125; 사용하려는 Class에서 BaseObservable을 상속받는다. firstName이라는 변수를 @get:Bindable 어노테이션을 이용해 바인딩을 통해서 값을 가져올 수 있도록 설정한다. 사용자 지정 set()을 사용해서 값을 할당하고 notifyPropertyChanged() 메소드를 통해서 데이터바인딩을 통해서 만들어진 파일에서 firstName이라는 변수가 변경되었다는 것을 알려서 갱신을 한다. 중요한 포인트는 set()할 때는 값을 할당하고 notifyPropertyChanged() 메소드를 통해서 변경되었다는 것을 알려주는 것이고, @get:Bindable 어노테이션을 통해서 접근이 가능하도록 연결 통로를 마련해줘야 한다. 2. ObservableField를 사용하는 방법 이 방법도 1번과 비슷한 방법이지만, 조금 다르다. @Bindable과 notifyPropertyChanged() 메소드를 사용하지 않는다. 대신에 사용하려는 프로퍼티를 ObservableField 타입으로 선언한다. 1234567891011class User: BaseObservable()&#123; var user: ObservableField&lt;String&gt; = ObservableField(\"\") fun getInformation(): String&#123; return user.get()!! &#125; fun setInformation(name: String)&#123; user.set(name) &#125;&#125; ObservableField를 이용할 때는 get() 메소드를 이용해서 프로퍼티의 값을 가져온다. 값을 할당할 때는 set() 메소드를 이용해서 프로퍼티에 값을 할당한다. 주의해야할 점은 ObservableField를 초기화할 때, 빈 생성자로 초기화를 하면 객체가 생성되지 않는다. 기본값을 넘겨주어 초기화를 진행해야 객체가 생성된다. ObservableField의 get() 메소드는 Nullable하기 때문에 주의해서 처리해야 한다. 형태와 값을 가져오고 할당하는 코드가 조금 다르지만 결국 같은 결과를 보여준다. 어떤 방법을 사용할지는 개발자의 몫이다. 조금 더 생각해보면 코드를 간단히 할 수도 있을 것 같다. 이 부분은 조금 더 생각해보기로 하자. ObservableField를 사용하는 경우, BaseObervable()을 상속받지 않고 프로퍼티를 선언만해서 사용하는 방법도 가능하다. 그리고 추가될 내용으로는 양방향 데이터바인딩에서 바인딩 어댑터를 사용하는 방법을 알아볼 예정이다. 참고 Google Developer Google Developer 안드로이드의 2-way 데이터바인딩","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Data Binding","slug":"Data-Binding","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Data-Binding/"},{"name":"Two way Binding","slug":"Two-way-Binding","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Two-way-Binding/"}]},{"title":"[Clean Code] 5장","slug":"CleanCode05","date":"2019-09-22T10:48:14.000Z","updated":"2019-09-22T12:21:28.153Z","comments":true,"path":"2019/09/22/CleanCode05/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/22/CleanCode05/","excerpt":"","text":"형식 맞추기와 관련된 내용입니다. 프로그래머라면 형식을 깔끔하게 맞춰 코드를 짜야한다. 코드 형식을 맞추기 위해 간단한 규칙을 정하고 그 규칙을 착실히 따라야 한다. 팀으로 일한다면 팀이 합의해 규칙을 정하고 모두가 그 규칙을 따라야 한다. 형식을 맞추는 목적 코드 형식을 중요하다. 이는 의사소통의 일환이다. 의사소통은 전문 개발자의 일차적인 의무다. 원활한 소통을 장려하는 코드 형식은 무엇일까? 생각해봐야 한다. 적절한 행 길이를 유지하라 코드의 길이가 길지 않게 유지하더라도 큰 규모의 시스템을 구축할 수 있다. 일반적으로 큰 파일보다는 작은 파일이 이해하기 쉽다. 신문 기사처럼 작성하라 이름은 간단하면서도 설명이 가능하게 짓는다. 이름만 보고도 올바른 모듈을 살펴보고 있는지 아닌지를 판단할 정도로 신경써서 짓는다. 소스 파일의 첫 부분은 고차원 개념과 알고리즘을 설명한다. 아래로 내려갈수록 의도를 세세하게 표현한다. 마지막에는 가장 저차원 함수와 세부 내역이 나온다. 개념은 빈 행으로 분리하라 거의 모든 코드는 왼쪽에서 오른쪽으로 그리고 위에서 아래로 읽힌다. 각 행은 수식이나 절을 나타내고 일련의 행 묶음은 완결된 생각 하나를 표현한다. 생각 사이는 빈 행을 넣어 분리해야 마땅하다. 빈 행은 새로운 개념을 시작하는 시각적 단서가 되면서 가독성을 높여준다. 세로 밀집도 바로 위의 줄바꿈이 개념을 분리한다면 세로 밀집도는 연관성을 의미한다. 즉, 서로 밀접한 코드 행은 세로 가까이 놓여야 한다는 뜻이다. 수직 거리 함수 연관 관계와 동작 방식을 이해하려고 어디에 있는지 찾고 기억하느라 시간과 노력을 소모하는 것은 낭비다. 서로 밀접한 개념은 세로로 가까위 둬야 한다. 물론 두 개념이 서로 다른 파일에 속한다면 규칙이 통하지 않는다. 하지만 타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 마땅하다. 이게 바로 protected 변수를 피해야 하는 이유 중 하나다. 같은 파일에 속할 정도로 밀접한 두 개념은 세로 거릴 연관성을 표현한다. 여기서 연관성이란 한 개념을 이해하는데 다른 개념이 중요한 정도다. 연관성이 깊은 두 개념이 멀리 떨어져 있으면 코드를 읽는 사람이 소스파일과 클래스를 여기저기 뒤지게 되어 혼란스러워진다. 변수 선언 변수는 사용하는 위치에 최대한 가까이 선언한다. 루프를 제어하는 변수는 흔히 루프 문 내에 선언한다. 드물게 다소 긴 함수에서 블록 상단이나 루프 직전에 변수를 선언하는 사례도 있다. 인스턴스 변수 클래스 맨 처음에 선언한다. 변수간에 세로로 거리를 두지 않는다. 위치가 어디가 되었던 간에 잘 알려진 위치에 인스턴스 변수를 모은다는 사실이 중요하다. 종속 함수 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까에 배치한다. 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다. 그러면 프로그램이 더 자연스럽게 읽힌다. 이를 통해 모듈 전체의 가독성이 높아진다. 개념적 유사성 친화도가 높을수록 코드를 가까이 배치한다. 친화도가 높은 요인은 여러가지다. 위의 경우처럼 종속함수가 한 예가 된다. 변수와 그 변수를 사용하는 함수도 된다. 또한, 비슷한 동작을 수행하는 일군의 함수가 그 예가 된다. 세로 순서 일반적으로 함수 호출 종속성은 아래 방향으로 유지한다. 다시 말해, 호출되는 함수를 호출하는 함수보다 아래에 배치한다. 그러면 소스 코드 모듈이 고차원에서 저차원으로 자연스럽게 내려간다. 중요한 개념을 표현할 때는 세세한 사항을 최대한 배제한다. 세세한 사항은 가장 마지막에 표현한다. 그러면 독자가 소스 파일에서 첫 함수 몇개만 읽어도 개념을 파악하기 쉬워진다. 가로 형식 맞추기 프로그래머는 명백하게 짧은 행을 선호한다. 짧은 행이 바람직하다. 120자 정도의 행 길이를 제한하는 것이 추천된다. 가로 공백과 밀집도 가로로는 공백을 사용해 밀접한 개념과 느슨한 개념을 표현한다. 1234public void max(int a, int b)&#123; int size = a; return size*2 + b;&#125; 할당 연산자를 강조하려고 앞뒤에 공백을 줬다. 이로 인해 두 가지 주요 요소가 확실히 나뉜다는 사실이 더욱 분명해진다. 반면, 함수 이름과 이어지는 괄호 사이에는 공백을 넣지 않았다. 함수와 인수는 서로 밀접하기 때문이다. 공백을 넣으면 한 개념이 아니라 별개로 보인다. 가로 정렬 별로 유용하지 못하다. 이를 통해서 코드가 엉뚱한 부분을 강조해 진짜 의도가 가려진다. 인수 목록이 많아 코드가 가로로 길어진다면 정렬이 필요한게 아니라 목록 길이가 길기 때문에 목록을 정리해야 한다. 즉, 클래스를 쪼개야 한다. 들여 쓰기 범위로 이뤄진 계층을 표현하기 위해 코드를 들여쓴다. 왼쪽으로 코들르 맞춰 코드가 속하는 범위를 시각적으로 표현한다. 들여쓰기가 없다면 코드의 가독성이 현저하게 떨어진다. 들여쓰기한 파일은 구조가 한눈에 들어온다. 변수, 생성자 함수, 접근자 함수, 메소드가 금방 보인다. 들여쓰기 무시하기 때로는 간단한 if문, while문, 짧은 함수에서 들여쓰기 규칙을 무시하고픈 유혹이 생긴다. 이런 유혹에 빠질 때마다 코드를 들여쓰기 해야 한다. 그로 인해 코드가 더 명확하게 눈에 들어온다. 가짜범위 때로는 빈 while문, for문을 접한다. 이럴 때는 빈 블록을 올바로 들여쓰고 괄호로 감싼다. 세미콜론은 새 행에다 제대로 들여써서 넣어준다. 팀 규칙 팀은 한 가지 규칙에 합의해야 한다. 그리고 모든 팀원은 그 규칙을 따라야 한다. 그래야 소프트웨어가 일관적인 스타일을 보인다. 그로 인해 팀원 중 한명이 다른 사람의 코드 부분을 수정하더라도 일관성을 가지고 있기 때문에 읽기도 수월하며 수정하기도 어렵지 않을 것이다. 개개인이 따로국밥처럼 맘대로 짜대는 코드는 피해야 한다. 좋은 소프트웨어 시스템은 읽기 쉬운 문서로 이뤄진다는 사시를 기억해야 한다. 스타일은 일관적이고 매끄러워야 한다. 한 소스 파일에서 봤던 형식이 다른 소스 파일에도 쓰이리라는 신뢰감을 독자에게 줘야 한다. 온갖 스타일을 뒤섞어 소스 코드를 필요 이상으로 복잡하게 만드는 실수는 반드시 피한다.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"주석","slug":"주석","permalink":"http://victorywoolee/victorywoolee.github.io/tags/주석/"}]},{"title":"[Android] ripple","slug":"Android-ripple","date":"2019-09-22T03:54:56.000Z","updated":"2019-09-22T04:31:57.650Z","comments":true,"path":"2019/09/22/Android-ripple/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/22/Android-ripple/","excerpt":"","text":"안드로이드에서는 리플 효과라는 것이 있다. 사용자가 앱의 버튼이나 특정한 위젯을 클릭했을 때, 물결처럼 퍼져나가는 효과를 말한다. 이는 사용자가 터치를 했다는 것을 명확하게 보여주기 때문에 사용자에게 터치했다는 좋은 경험을 제공할 수 있다. 그래서 대부분의 앱들이 이러한 효과를 제공하고 있다. 그럼 리플 효과를 어떻게 적용할 수 있는지에 대해서 이야기해보려고 한다. 리플 효과버튼을 만들려고할 때, 디자인을 보고 xml에서 색상과 radius, 텍스트만 설정해서 구성할 수 있다면 클라이언트단에서 처리하는 편이 낫다. 이로 인해 리소스를 절약하고 용량도 어느정도는 작게 만들수 있기 때문이다. 그래서 xml에서 selector를 이용해서 원하는 모양을 작성하고 적용을 하기 위해서 background 속성을 이용하면 이쁘게 적용할 수 있다. 그러면 여기서 리플 효과는 어떻게 적용할까?? appcompat-v7 라이브러리에서 선택 가능한 항목의 터치 피드백을 플랫폼 버전엥 맞춰 쉽게 표시할 수 있도록 ?attr/selectableItemBackground라는 속성을 제공하고 있다. 하지만, 배경에 이 속성을 적용할 경우 해당하는 뷰에 다른 색상이나 모양, 혹은 이미지를 배경으로 함께 지정할 수 없어 레이아웃을 원하는 대로 구성할 수 없다. 위에서 작성한 xml을 적용할 수 없다는 뜻이다. 이와 같은 문제를 해결하기 위해서 터치 피드백이 다른 뷰의 가장 앞에 표시되도록 하면 될 것이다. android:foreground 속성을 사용해 해결할 수 있다. 터치 피드백이 필요한 곳에 아래와 같이 추가해주면 된다. background로 모양이나 색상을 정하지 않더라도 이를 사용하면 추후에 모양이나 색상이 추가되었을 때, 다른 수정을 할 필요가 없다. 앞으로 아래와 같이 사용하면 될 것이다. 1android:foreground=\"?selectableItemBackground\"","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"ripple","slug":"ripple","permalink":"http://victorywoolee/victorywoolee.github.io/tags/ripple/"}]},{"title":"[Android] Gradle","slug":"Android-Gradle","date":"2019-09-21T06:39:20.000Z","updated":"2019-09-21T07:57:08.567Z","comments":true,"path":"2019/09/21/Android-Gradle/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/21/Android-Gradle/","excerpt":"","text":"Grdle이란? 빌드 배포 도구 안드로이드 스튜디오와 빌드 시스템은 서로 독립적이다. 안드로이드 스튜디오 : 코드의 편집을 담당 Gradle : 빌드 빌드 프로세스를 자동화하고 관리, 유연한 맞춤형 빌드 구성을 정의할 수 있다. 3가지의 Gradle 파일이 있다. 1. Gradle 설정 파일(settings.gradle) 로트 프로젝트 디렉토리에 존재한다. 어떤 모듈을 포함할지를 Gradle에 알려준다. 1include &apos;:app&apos; 2. 최상위 빌드 파일(build.gradle) 루트 프로젝트 디렉토리에 최상위 파일로 프로젝트의 모든 모듈에 적용되는 빌드 구성을 정의한다. 모든 모듈에 공통되는 Gradle 저장소와 의존성을 정의하기 위해 buildscript 블록을 사용한다. 123456789101112buildscript&#123; repositories&#123; // gradle이 종속성을 검색하거나 다운로드하는 데 사용하는 레포지토리를 구성 &#125; dependencies&#123; // gradle이 사용하는 종속성을 정의 &#125;&#125;allprojects&#123; // 타사 플러그인 또는 라이브러리와 같이 모든 모듈이 사용하는 레포지토리 및 종속성을 구성하는 곳&#125; 3. 모듈 수준 빌드 파일(build.gradle) 해당 파일이 위치하는 특정 모듈의 빌드 설정을 구성 최상위 파일을 재정의할 수 있다. 1234567891011121314151617181920212223242526272829303132333435apply plugin: &apos;com.android.application&apos;// top-level에 선언되어야 하며, 안드로이드 플러그인을 gradle에 적용한다.android&#123; // 안드로이드와 관련된 빌드 설정을 한다. defaultConfig&#123; // AndroidManifest.xml에서 사용하는 설정에 대해 동적인 옵션을 주고 싶을 때, 이 블록 내에서 포함시킨다. // 예를 들면, versionCode, versionName 등 &#125; buildTypes&#123; // debug, release와 같이 빌드 타입을 지정할 수 있다. // 이외에도 alpha, beta 등등 &#125; flavorDimensions &quot;api&quot; // product flavor에 대한 그룹 productFlavors&#123; // 버전을 맞춤 설정하여 다양한 코드 및 리소스를 사용할 수 있으며, 모든 앱 버전에 공통되는 부분을 공유하거나 재사용할 수 있다. // flavorDimensions을 생성하고 동기화 진행 // 자신이 빌드 및 실행하고자 하는 것으로 변경 가능하다. &#125; lintOptions&#123; // 특정 lint 옵션을 구성할 수 있다. &#125; testOptions&#123; // text를 어떻게 실행하는지 방법에 대한 옵션을 지정한다. &#125;&#125;dependencies&#123; // 종속성을 관리한다. // 라이브러리를 추가하기 위해 수동으로 검색 및 다운로드 하지 않고 사용 가능하다.&#125; build variants 단일 프로젝트에서 다양한 버전의 앱을 생성하기 위해 사용한다. 각 build variants는 빌드할 수 있는 다른 버전의 앱을 나타낸다. build type과 product flavor에 구성된 설정, 코드 및 리소스를 조합한 결과 proguard 빌드 프로세스 중에 클래스를 축소하고 난독화 처리하기 위해 사용한다. 불필요한 메소드를 제거하여 멀티덱스를 피할 수 있다. 난독화 : 특정 언어로 작성된 코드를 읽기 어렵게 만드는 작업 디컴파일시 난독화가 되어 코드를 읽기 어렵다. 멀티 덱스 : 안드로이드 앱을 구성하는 코드는 컴파일되어 덱스 파일로 만들어진다. 하나의 덱스파일은 최대 65536개의 메소드만 참조 가능하다. 이를 초과하면 여러 개의 덱스 파일이 생성된다. 멀티 덱스를 사용할 수도 있지만, 빌드 과정에서 앱 내의 파일을 여러 개의 덱스 파일로 나누어야 하므로 빌드 속도가 느려지고 APK의 용량이 커지다. APK와 App Bundle APK : Android Package App Bundle : Application Bundle 두 가지 모두 여러 개의 흩뿌려져 있는 코드들을 안드로이드 기반 기기에서 독립적으로 실행 가능하도록 묶음으로 만드는 역할을 한다. APK가 커지는 이유 멀티 스크린을 지원하기 위해 이미지와 같은 리소스들이 증가 다국어를 지원하는 앱인 경우 String 파일 증가 자주 사용되지 않는 기능들의 증가 안드로이드 App Bundle은 새로운 업로드 방법으로 앱의 크기를 줄일 수 있다.기존에는 Play Console에 APK을 업로드하여 배포를 진행했지만, 새로운 배포 방법은 서명된 App Bundle을 Play Console로 배포하면 사용자의 기기에 맞는 언어, 리소스, CPU 아키텍처에 맞는 부분만 빌드하여 생성하기 때문에 사용자가 다운로드 받는 APK 용량을 줄일 수 있다. App Bundle? App Bundle은 APK와 비슷하지만 모든 코드, 리소스, CPU 아키텍처와 메타 데이터를 압축한 Zip 파일이다. 그래서 Google Play는 App Bundle에서 사용자 기기에 필요한 코드와 리소스만을 선택해 빌드될 수 있는 것이다. App Bundle을 빌드하면 .aab 파일이 생성된다. 빌드된 aab 파일을 Play Store에 업로드하면 Play Console이 사용자 각각의 디바이스에 최적화된 APK를 빌드한다. Dynamic Delivery? 사용자 기기에 필요한 리소스만을 다운로드 가능하게 해준다. Android 5.0(SDK 21) 이상부터 사용할 수 있다. Split APK 매커니즘을 이용한다. 이는 분리된 APK를 하나의 앱으로 만들어주는 것으로 여러가지 기능을 분리하고 나중에 기능이 필요할 때 다운로드 받아 설치된다. 따라서 Dynamic Delivery로 Google Play는 각 기기의 맞는 리소스만 빌드를 하고 기기에 설치되도록 한 다음에 사용자가 특정 기능을 필요로 할 때, 부분적으로 다운 받아서 사용할 수 있게 해주기 때문에 앱 용량을 줄일 수 있다. Base APK : 모든 APK가 접근할 수 있는 코드와 리소스가 포함된 APK이다. 앱의 기본 기능을 제공하고 사용자가 앱 다운로드를 요청하면 가장 처음 다운로드 받는 APK. Configuration APK : 기기에 설치될 때, 각 기기에 최적화된 화면 밀도(dpi)나 CPU 아키텍처, 다국어, 리소스와 네이티브 라이브러리가 포함된 APK이다. Google Play에서 자동으로 생성해준다. Dynamic feature APK : 사용자가 기기에 처음 설치할 때 필요하지 않지만, 나중에 추가로 설치할 수 있는 코드와 리소스가 들어있는 APK. 즉, 필요에 따라 동적으로 APK를 설치하여 사용자에게 추가 기능을 제공할 수 있다. 기본적으로 Google Play는 Base APK와 Configuration APK를 설치한다.예를 들어, 과거에는 다국어와 화면 사이즈를 대응하는 앱인 경우 APK를 빌드하고 서명 후 Play Console에 배포했다. 하지만, 지금은 App Bundle을 Google Play에 업로드하면 Google Play는 App Bundle의 메타데이터와 리소스에서 영어, xxhdpi 리소스만 빌드하여 base+en+xxhdpi으로 조합된 APK를 만든다. 이로 인해 사용자는 더 작고 최적화된 설치 파일을 다운로드 받을 수 있다.","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Gradle","slug":"Gradle","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Gradle/"},{"name":"Build","slug":"Build","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Build/"}]},{"title":"[Git] Git Flow 전략","slug":"Git-Flow","date":"2019-09-21T05:34:12.000Z","updated":"2019-09-21T06:22:52.962Z","comments":true,"path":"2019/09/21/Git-Flow/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/21/Git-Flow/","excerpt":"","text":"협업을 하면서 프로젝트를 진행하다보면 서로 같은 부분을 건드려서 개발하는 경우가 있다. 그리고 서로 다른 부분을 작업해 하나의 프로젝트에 합치는 경우도 많다. 이렇게 개발자가 협업을 할 때, 소스 코드의 버전 관리를 하기 위해서 Git을 사용하는데 여기에는 여러 전략이 있다. Github Flow 전략 Git Flow 전략 여기서 알아볼 전략은 Git Flow 전략이다.간단하게 말하면 브랜치를 효율적으로 관리하는 전략을 말한다. master branch 배포되었거나 배포될 소스가 저장되는 브랜치 master 브랜치는 배포될 때마다 태그만 달아주는 형식으로 관리한다. 예를 들어, 제품 1.0.0, 제품 1.2.1 등의 배포 버전이 있으면 해당 버전에 태그를 달아서 언제든 원하는 버전의 소스를 받아볼 수 있게 하는 역할을 한다. develop branch 다음 배포를 위해서 개발을 진행하는 브랜치다. 여러 명의 개발자가 함께 공유하면서 개발을 진행하는 브랜치다. 프로젝트 관점에서 보면 결국 개발이 진행되는 곳은 develop 브랜치다. 개발자 각각이 개발해야 하는 기능은 개발하기 전에 각자 자신의 로컬에 브랜치를 따로 생성해 개발을 진행하고 로컬 브랜치에서 개발이 완료되면 완료된 소스를 develop 브랜치에 푸시하거나 PR을 보내서 내부적인 코드 리뷰 후 merge 하는 것을 통해 개발이 진행된다. 위의 두 브랜치는 remote repository에서 항상 유지되는 브랜치이며, main branch라고 한다. feature branch 각 개발자에 의해 기능 단위의 개발이 진행되는 브랜치다. 여러 명의 개발자와 함께 프로젝트를 진행할 때, 요구사항에 있는 여러 기능을 적절하게 분배해서 개발자들과 일을 나눈다고 해보자. develop으로부터 feature 브랜치를 생성한다. 그리고 로컬에 기능을 위해 생성한 브랜치는 feature/login 브랜치다. 개발이 진행되면서 feature 브랜치로 merge를 한다. 모든 기능이 완료된 feature 브랜치는 develop으로 다시 merge되거나 push 된다. 위의 경우처럼 feature 브랜치를 로컬이 아닌 원격에 만들어서 관리해도 된다. 즉, 하나의 layer를 더 만든다고 생각하면 된다. 이렇게 함으로써 브랜치를 더 유연하게 만들어서 개발을 하면 적은 인원이 효율적으로 개발을 할 수 있다고 생각한다. hotfix branch 배포 버전에 생긴 문제로 긴급한 트러블 슈팅이 필요할 때 개발이 진행되는 브랜치다. 배포 버전에 문제가 발생해서 긴급하게 해당 기능만 수정이 필요할 때, 사용하는 브랜치다 실제 배포된 master 브랜치가 있고 이후에 개발이 지속적으로 진행된 develop 브랜치가 있는 상황이라고 가정해보자. 이때 배포된 버전에서 버그가 발생하면 어떻게 해야할까? develop 브랜치는 이미 다음에 배포될 버전이 충분히 개발된 버전이라 건들면 안된다. 이때는 배포된 master 브랜치에서 새로운 hotfitx 브랜치를 따고 문제가 생긴 코드를 고쳐서 master 브랜치에 merge한다. 아무래도 이미 배포된 버전에서 문제가 생겼기 때문에 즉각적으로 수정이 필요하다. 따라서 master로 직접 merge된다. 또한, 실제 출시된 버전에서 생긴 문제는 develop 브랜치에도 적용해야 한다. 운영에서 발견된 심각한 문제기 때문이다. release branch 내부적으로 배포할 준비가 되었다고 생각되는 소스가 저장되는 브랜치다. QA로 넘길 소스라고 보면된다. 요구되는 기능들을 모두 개발하고 내부적으로 배포하기 전에 테스트를 거치는 소스가 저장되는 브랜치다. 만약 QA 중에 문제가 발생하면 버그 픽스를 진행하고 버그가 제거된 release 소스를 중간에 develop 브랜치에 적용해 추가 개발을 이어갈 수 있다. 하지만 추가 기능 개발을 위해서 다시 develop 브랜치로 가지는 않는다. 만약 develop으로 버그가 수정된 소스가 가고 기능 개발을 한다면 그 기능은 이번 release가 아닌 다음 release 브랜치에 적용될 것이다. 모든 준비를 마치고 배포 가능한 상태가 되면 master 브랜치로 병합시키고, 병합한 커밋에 릴리즈 번호 태그를 추가한다.","categories":[{"name":"Git","slug":"Git","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Git/"},{"name":"Git Flow","slug":"Git-Flow","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Git-Flow/"}]},{"title":"[Android] 해상도","slug":"Android-Pixels","date":"2019-09-19T11:48:06.000Z","updated":"2019-09-21T04:38:35.419Z","comments":true,"path":"2019/09/19/Android-Pixels/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/19/Android-Pixels/","excerpt":"","text":"DIP(Device Independent Pixels) or DP 안드로이드에서 사용하는 독립적인 단위 수치 어떤 해상도에서도 같은 크기를 보여주는 것이 목적 DPI(Dot Per Inch) 1인치(2.54cm)에 들어가는 픽셀의 수 안드로이드에서는 160dpi를 기본 값으로 한다. px(pixel) 스크린의 실제 픽셀 단위를 사용한다. 실제 크기나 밀도와 상관 없다. 변환식 px = dp * (dpi/160) dp = px * (160/dpi) 160dpi인 해상도에서 1dp = 1px이다. 밀도 분류 160dpi = mdpi -&gt; 160 * 1 = 1dp = 1px 240dpi = hdpi -&gt; 160 * 1.5 = 1dp = 1.5px 320dpi = xhdpi -&gt; 160 * 2 = 1dp = 2px 480dpi = xxhdpi -&gt; 160 * 3 = 1dp = 3px 640dpi = xxxhdpi -&gt; 160 * 4 = 1dp = 4px 위의 그림은 구글 공식 문서에 있다. 안드로이드의 리소스 우선순위를 확인할 수 있다.자신에게 맞는 dpi 폴더를 먼저 읽고 해당 리소스가 없다면 가장 큰 dpi 폴더에서부터 작은 폴더순으로 읽으며 리소스를 찾는다. 최소 너비 사용 가능한 화면 영역의 가장 짧은 치수 기준으로 분류한다. swdp -&gt; sw320dp, sw600dp sw600dp로 분류된 레이아웃은 화면의 사용 가능한 영역 중, 가로 또는 세로 중 짧은 치수를 기준으로 600dp가 넘는 경우에만 접근이 가능하도록 한다.","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"해상도","slug":"해상도","permalink":"http://victorywoolee/victorywoolee.github.io/tags/해상도/"}]},{"title":"[Android] DI - Dagger2","slug":"Android-DI","date":"2019-09-19T11:46:46.000Z","updated":"2019-09-21T05:33:53.856Z","comments":true,"path":"2019/09/19/Android-DI/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/19/Android-DI/","excerpt":"","text":"해당 글은 DI와 관련된 공부 및 정리 글이며 추후에 내용이 추가될 가능성이 있습니다. DI Dependency Inject이라고 하면 의존성 주입을 의미한다. 구성요소 간의 의존 관계를 소스 코드 내부가 아닌 외부 설정 파일 등을 통해 정의되게 하는 디자인 패턴이다. 크게 3가지 유형으로 나누어 볼 수 있다. 생성자 주입 Setter를 통한 주입 Interface를 통한 주입 직접 의존성을 주입하는 형태의 클래스를 작성해도 되지만, 프로젝트의 규모가 커진다면 번거로운 작업이 된다. 그래서 이를 라이브러리로 넘겨서 대신 처리하도록 구현할 수 있다. 그 중에서도 Dagger와 관련해서 내용을 정리해보았다. Dagger2 Dagger의 핵심 키워드는 아래 그림과 같다. Module 의존성을 제공하는 @Provides 메소드를 가진 클래스에 이용한다. 모든 @Provides 메소드는 @Module 클래스 안에 속해야 한다. Provides 어떻게 의존성을 구성하고 제공하는지 정의하는 메소드에 사용한다. Module과 Provides는 공급자의 역할을 한다. Inject 의존성이 필요한 클래스에서 의존성 주입을 요청한다. @Inject 어노테이션으로 주입을 요청하면 연결된 Component가 Module로부터 객체를 생성하여 넘겨준다. 소비자의 역할을 한다. Component 연결된 Module을 이용해 의존성 객체를 생성하고, Inject로 요청받은 인스턴스에 생성한 객체를 주입한다. 의존성을 요청받고 주입하는 Dagger의 주된 역할을 수행한다. Module과 Inject 사이의 다리 역할을 한다. 인터페이스에만 사용한다. Scope 생성된 객체의 Lifecycle 범위를 뜻한다. 안드로이드에서는 주로 PerActivity, PerFragment 등으로 화면의 생명주기와 맞추어 사용한다. Module에서는 이 Scope을 보고 객체를 관리한다. Subcomponent Component는 계층 관계를 만들 수 있다. Subcomponent는 Inner Class 방식의 하위계층 Component이다. Sub의 Sub도 가능하다. 이는 Dagger의 중요한 컨셉인 그래프를 형성한다. Inject로 주입을 요청받으면 Subcomponent에서 먼저 의존성을 검색하고 없으면 부모로 올라가면서 검색한다. Qualifier 동일한 유형이지만 다른 인스턴스를 가진 객체를 구별하는데 사용된다. 주로 타입만으로 의존성을 식별하기 어려운 경우에 사용한다. 예를 들어, String과 같은 범용적인 타입일 경우 중첩될 수 있어서 이때 사용하면 된다. Flow@Inject -&gt; Subcomponent -&gt; Module -&gt; Scope에 있으면 return. 없으면 생성Subcomponent module에서 맞는 타입을 못찾으면 상위 Component -&gt; Module -&gt; Scope에 있으면 return. 없으면 생성. @Component를 구성하는 모든 @Module 클래스 목록을 작성해야 한다.아래와 같은 그림처럼 나타난다. Component를 구성하는 모든 Module 클래스 목록을 작성한다. 이를 통해서 Component는 Module과 연결되었다. 의존성 주입이 필요한 곳에서 @Inject를 통해 요청이 들어오면 해당 컴포넌트는 연결된 모듈 중에서 의존성을 제공할 수 있는 모듈이 있는지 검색한다. 제공할 수 있는 모듈이 있으면 Module에서 정의했던 메소드를 통해서 객체를 제공하게 된다. 그리고 주의해야할 점은 @Inject가 필요한 곳을 Component에 정의해야 한다는 것이다. 예를 들어, MainActivity에서 의존성 주입이 필요하다면 다음과 같이 Component에 정의해야 한다. 1234@Component(modules = [CatModule::class, DogModule::class])interface AnimalComponent&#123; fun inject(mainActivity: MainActivity)&#125; Component 인터페이스를 만들고 후에 build를 하면 Dagger는 이 인터페이스를 구현한 클래스를 자동으로 생성해준다. 생성된 클래스는 @Component 인터페이스 앞에 Dagger를 붙인채로 생성된다. 추가될 내용꽤 많은 블로그를 참고해 내용을 작성했는데, 주로 한글로 작성된 자료를 참고했다. 그래서 아래에 명시한 영어로 된 자료들을 참고해서 내용을 다시 정리할 예정이다.또한, Subcomponent와 관련된 내용도 더 숙지해서 정리할 필요가 있다. 참고1 참고2","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"DI","slug":"DI","permalink":"http://victorywoolee/victorywoolee.github.io/tags/DI/"},{"name":"Dagger2","slug":"Dagger2","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Dagger2/"}]},{"title":"[Android] WindowBackground","slug":"Android-WindowBackground","date":"2019-09-19T10:47:44.000Z","updated":"2019-09-19T11:44:09.018Z","comments":true,"path":"2019/09/19/Android-WindowBackground/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/19/Android-WindowBackground/","excerpt":"","text":"아래의 글을 읽어보면 어떻게 drawing을 더 빠르게 하고, activity의 시작 시간을 단축시킬 수 있는지 알 수 있다. 이는 window background drawable과 관련이 있다. setContentView()를 통해 Activity에 View를 붙이면, 이 View는 activity의 window에 붙게 된다. 하지만, window는 setContentView()를 통해 붙인 뷰만 붙이는 것이 아니다. 가장 중요한 것 중 하나인 DecorView를 붙이게 된다. DecorView는 window의 background Drawable을 가지고 있는 View다. getWindows().setBackgroundDrawable()을 호출하는 것은 실제로 DecorView의 background를 변경하여 window의 background가 변경되는 것과 같은 효과를 낸다. 하지만 이같은 설정은 추후에 version 혹은 device에 따라 달라질 수 있다. 기본 android theme를 사용한다면 default background drawable이 activity에 설정되어있다. 기본적으로는 ColorDrawable이 설정되어있다. 보통의 앱에서는 이 ColorDrawable이 DecorView에 설정되어 있는게 문제가 안된다. 하지만, drawing performance에는 영향을 줄 수도 있다. 아래는 불투명 그림이 activity 전체에 설정되어 있는 경우다. 그림에서 window background가 보이지 않는 것을 확인할 수 있다. 전부 불투명한 그림을 담고 있는 ImageView로 덮여있기 때문이다. 이 앱은 44fps가 나온다. 더 빨리 그리게 하기 위해서는 background drawable을 제거해주면 된다. 그림이 불투명이며 화면 전체를 차지하기 때문에 background는 낭비일 뿐이다. background를 제거함으로써 더 나은 퍼포먼스를 얻을 수 있다. background를 제거한 버전에서는 51fps가 나온다. 만약 default window backgroun가 더 큰 용량의 drawable일 경우에는 그 차이가 더 확연하게 난다. window background를 없애는 것은 custom theme를 적용하면 간단하게 해결된다.res/values/theme.xml을 만들고 아래와 같이 정의하면 된다. 12345&lt;resources&gt; &lt;style name=\"Theme.NoBackground\" parent=\"android:Theme\"&gt; &lt;item name=\"android:windowBackground\"&gt;@null&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 위와 같은 theme을 activity나 application의 theme로 적용해주면 된다. 1android:theme=&quot;@style/Theme.NoBackground&quot; MapView나 WebView 같은 경우도 보통 activity를 꽉 채우며 불투명하기 때문에 이런 theme를 사용하는게 좋다. 이 방법은 Android UI toolkit이 가려진 drawable을 그리지 않을만큼 똑똑하지는 않기 때문이다. 보통 android application에서 이렇게 full screen 전부가 불투명한 경우가 많지 않기 때문에 이런 최적화를 framework 단에서 하지 않았다. 하지만 이것은 추후 구현에서 자동으로 그리지 않도록 최적화될 수 있다. 전체 바탕을 theme으로 설정함으로서 activity의 시작 시간을 단축시킬수 있는 것도 좋은 방법이다. 아래와 같은 상황이 적절한 예가 될 수 있다. 위와 같은 background가 onCreate에서 설정되거나 XML layout을 통해서 설정되었다면 activity의 시작은 처음에 검은 배경이 나온 후 해당 그림으로 바뀌는 방식으로 이루어질 것이다. 사용자는 이 background를 로드하는데 시간이 걸린다고 느낄 것이며, 깜빡이는 경험도 할 것이다. 이렇게 하는 대신 theme로 설정해서 custom backgrounㅇ를 깔아주면 activity의 시작시간도 단축할 수 있고, 이렇게 깜빡이는 느낌도 없앨 수 있다. 참고 [Android/안드로이드] Window Backgrounds &amp; UI Speed","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Window Background","slug":"Window-Background","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Window-Background/"}]},{"title":"[ETC] GNB","slug":"What-is-GNB","date":"2019-09-16T13:15:48.000Z","updated":"2019-09-16T13:18:43.413Z","comments":true,"path":"2019/09/16/What-is-GNB/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/16/What-is-GNB/","excerpt":"","text":"GNB란? Global Navigation Bar의 줄임말이다. 사이트 전체에 동일하게 적용되는 네비게이션 바를 의미한다. 즉, 어느 페이지에 들어가든 공통적으로 사용할 수 있는 메뉴를 뜻한다. 그래서 의존성을 줄이고 모듈로 만들어서 필요한 곳에 사용하도록 만든다. 최상위 메뉴로 보통 상단에 위치한다.","categories":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/categories/ETC/"}],"tags":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/tags/ETC/"},{"name":"GNV","slug":"GNV","permalink":"http://victorywoolee/victorywoolee.github.io/tags/GNV/"}]},{"title":"[ConstraintLayout] 속성","slug":"Android-ConstraintLayout","date":"2019-09-16T05:05:48.000Z","updated":"2019-09-19T10:47:22.737Z","comments":true,"path":"2019/09/16/Android-ConstraintLayout/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/16/Android-ConstraintLayout/","excerpt":"","text":"안드로이드에서 뷰를 짤 때 사용하는 레이아웃은 많다.그 중에서 Constraint Layout은 이해하기 어렵지 않으며기존의 레이아웃들보다 좋은 기능을 많이 제공하고 있어 자주 사용된다. 유용한 속성들을 알아보자. 가이드 라인 뷰를 배치하기 위해 뷰그룹 내에 설정할 수 있는 일종의 기준선이다. 장점은 실제로는 이 선이 보이지 않는다는 것이다. 어떻게 보면 가상의 선을 기준으로 뷰를 배치할 수 있어서 편리하다. orientation을 통해 가로/세로 방향을 적용할 수 있다. 위치를 정하는 방법은 두 가지다. 일반적인 dp, px과 같은 수치를 적용하는 것 퍼센트를 적용하는 것 1. 수치를 적용하는 것 layout_constraintGuide_begin : begin의 경우 레이아웃 내에서 세로 가이드라인이라면 왼쪽(start)에서부터 얼만큼 떨어져있는지, 가로 가이드라인이라면 위에서부터 얼만큼 떨어져있는지를 뜻한다. layout_constraintGuide_end : end는 이와 반대로 세로는 오른쪽(end)에서부터, 가로는 아래에서부터 얼만큼 떨어져있는지를 적용하면 된다. 2. 퍼센트를 적용하는 것 layout_constraintGuidePercent : 0.0 ~ 1.0까지 적용할 수 있으며, 이때는 무조건 왼쪽이나 위쪽에서 시작한다고 생각하면 된다. 레이아웃 내부로부터 왼쪽에서 40% 지점에 세로로 된 가이드라인을 적용하려면 아래와 같이 하면 된다. 123456&lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guide_line\" android:layout_width=\"1dp\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.4\" /&gt; start vs left의 차이Android는 레이아웃 방향을 우아하게 변환하여 오른쪽에서 왼쪽으로(RTL) UI를 사용하는 언어와 아랍어, 히브리어와 같은 읽기 방향을 지원하는 사용자 인터페이스를 구축할 수 있는 API를 제공한다. 이를 설정하기 위해서는 매니페스트 파일에서 android:supportRtl의 값을 true로 설정해주면 된다. 그러면 시스템은 앱을 RTL 레이아웃으로 표시할 수 있도록 RTL API를 활성화할 것이다. RTL 레이아웃으로 표시할 때 앱의 UI를 최적화해야 하는 경우, 아래와 같은 최적화가 있다.1. 첫 번째 방법 레이아웃에서 left, right 방향을 start, end로 변경해야 한다. ex) android:layout_marginLeft -&gt; android:layout_marginStart 2. 두 번째 방법 RTL 레이아웃을 완벽하게 최적화하기 위해 ldrtl 리소스를 사용해 완전히 별개의 레이아웃 파일을 제공할 수 있다. 드로잉 가능한 자원에 매우 적합하므로 읽는 방향에 해당하는 방향에 맞는 그래픽을 제공할 수 있다. ex) 기본 레이아웃 파일은 /res/layout/에 저장하고, RTL 최적화 레이아웃은 /res/layout-ldtrl에 저장할 수 있다. 즉, start와 end 속성은 RTL을 지원하는 레이아웃에 사용된다. RTL을 지원하는 레이아웃에서는 left와 right가 우리의 입장에서 반대로 동작하기 때문에 이보다는 start와 end가 더 맞는 개념이라고 생각한다. 그래서 이를 도입해서 혼란을 방지하고자 한 것으로 보인다. 체인 개념은 간단하다. 단일축(가로축, 세로축)에서 위젯들이 그룹처럼 동작할 수 있도록 해준다. 최소 2개의 위젯이 서로 연결되어 있으면 체인 기능을 사용할 수 있다. 체인의 머리 : 체인의 가장 왼쪽(가로축일 경우) 혹은 가장 위쪽(세로축일 경우)에 있는 위젯이 체인의 머리가 된다. 체인의 여백은 체인의 스타일에 따라 달라진다. 체인의 스타일 체인의 머리는 연결된 뷰들 중 왼쪽과 위쪽이 우선순위를 갖는다. 주의할 점은 체인을 사용할 위젯들은 모두 서로 연결되어 있어야 한다는 점이다. 그래야 체인 조건이 성립되며 원하는 체인을 걸 수 있다. 배리어 다국어 지원을 하는 앱을 개발할 때 사용하면 유용하게 쓸 수 있다. 예를 들어, 세로로 2개의 텍스트뷰가 있다. 이 둘은 가로로 길어진다. 그리고 이 둘의 길이가 다를 때 더 긴쪽의 텍스트뷰 오른쪽에 뷰를 배치하고 싶을 때 사용하면 된다. barrierDirection : 왼쪽, 오른쪽의 기준을 설정할 수 있다. constraint_referenced_id : 기준시킬 뷰들의 아이디를 나열한다. 즉, 어떤 뷰가 상황에 따라서 길어지고 이 옆에 어떤 뷰를 또 배치해야할 때 유용하게 사용할 수 있을 것 같다. 그 중 하나의 예가 다국어같은 상황이다. 한 단어라도 다른 언어를 사용하면 굉장히 길어질 수 있기 때문에 이 상황에서 사용하면 예방할 수 있다. 참고 Google Developer Google Developer","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Constraint Layout","slug":"Constraint-Layout","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Constraint-Layout/"}]},{"title":"[CleanCode] 4장","slug":"CleanCode04","date":"2019-09-15T09:45:54.000Z","updated":"2019-09-16T05:05:32.497Z","comments":true,"path":"2019/09/15/CleanCode04/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/15/CleanCode04/","excerpt":"","text":"이번에는 주석과 관련된 내용입니다.책에서는 코드와 관련해서 설명이 많이 나오지만, 코드를 모두 담기에는 어려워 일부분만 담았습니다.정확한 이해가 필요하시다면 책을 구매하는 것을 추천드립니다. 잘 달린 주석은 그 어떤 정보보다 유용하다. 경솔하고 근거 없는 주석은 코드를 이해하기 어렵게 만든다. 오래되고 조잡한 주석은 거짓과 잘못된 정보를 퍼뜨려 해악을 미친다. 부정확한 주석은 아예 없는 주석보다 훨씬 나쁘다. 주석은 나쁜 코드를 보완하지 못한다. 코드에 주석을 추가하는 이유는 코드 품질이 나쁘기 때문이다. 지저분하게 코드를 짰다면 주석을 다는게 아니라 코드를 정리해야 한다! 표현력이 풍부하고 깔끔하며 주석이 거의 없는 코드가 복잡하고 어수선하며 주석이 많이 달린 코드보다 훨씬 좋다. 코드로 의도를 표현하라! 코드로 의도를 표현하라! 주석으로 달려는 설명을 함수로 만들어 표현해도 충분하다. 12345// 직원에게 복지 혜택이 있는지 검사한다.if((employee.flags &amp;&amp; HOURLY_FALT) &amp;&amp; employee.age &gt; 65) if(employee.isEligibleForFullbenefis())// 위보다 아래 코드가 의도를 더 명확하게 표현한다. 좋은 주석 어떤 주석은 필요하거나 유익하다. 하지만 정말 좋은 주석은 주석을 달지 않을 방법을 찾아낸 주석이다. 법적인 주석 소스 파일 첫 머리에 들어가는 저작권 정보와 소유권 정보 정보를 제공하는 주석 기본적인 정보를 주석으로 제공하면 편리하다. 아래 주석은 추상 메소드가 반환할 값을 설명한다. 12protected abstract Responder responderInstance();// 테스트 중인 Responder 인스턴스를 반환한다. 하지만, 가능하다면 함수 이름에 정보를 담는 편이 더 좋다.예를 들어, 위 코드에서 함수 이름을 responderBeingTested로 바꾸면 주석이 필요없어진다. 의도를 설명하는 주석 때때로 주석은 구현을 이해학 도와주는 선을 넘어 결정에 깔린 의도까지 설명한다. 의미를 명료하게 밝히는 주석 때때로 모호한 인수나 반환값은 그 의미를 읽기 좋게 표현하면 이해하기 쉬워진다. 일반적으로는 인수나 반환값 자체를 명확하게 만드련 더 좋겠지만, 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속한다면 의미를 명료하게 밝히는 주석이 유용하다. 결과를 경고하는 주석 다른 프로그래머에게 결과를 경고할 목적으로 주석을 사용한다. 아래는 특정 테스트 케이스를 꺼야 하는 이유를 설명한다. 1234// 여유 시간이 충분하지 않다면 실행하지 마십시오.public void _testWithReallyBigFile()&#123; ...&#125; 요즘은 위의 방식보다는 @Ignore 속성을 이용해 테스트 케이스를 꺼버린다. 구체적인 설명은 @Ignore 속성에 문자열로 넣어준다. JUnit4가 나오기 전에는 메소드 이름 앞에 _ 기호를 붙이는 방법이 일반적인 관례였다. TODO 주석 앞으로 할 일을 //TODO 주석으로 남겨두면 편하다. 이를 통해 함수를 구현하지 않은 이유와 미래 모습을 설명할 수 있다. 12345// TODO 현재는 필요하지 않다.// 체크 아웃 모델을 도입하면 함수가 필요하다.public VersionInfo makeVersion()&#123; return null;&#125; TODO 주석은 프로그래머가 필요하다 여기지만 당장 구현하기 어려운 업무를 기술한다. 예를 들면, 더이상 필요 없는 기능을 삭제하라는 알림, 누군가에 문제를 봐달라는 요청 등이다. TODO로 떡칠한 코드는 바람직하지 않다. 중요성을 강조하는 주석 자칫 대수롭지 않다고 여겨질 뭔가의 중요성을 강조하기 위해서도 주석을 사용한다. 예를 들면 다음과 같은 경우다. 123String listItemContent = match.group(3).trim();// trim()은 중요하다. 이 함수는 문자열에서 시작 공백을 제거한다.// 문자열에 시작 공백이 있다면 다른 문자열로 인식되기 때문이다. 공개 API에서 Javadocs 설명이 잘 된 공개 API는 참으로 유용하고 만족스럽다. 표준 자바 라이브러리에서 사용한 Javadocs가 좋은 예다. Javadocs가 없다면 자바 프로그램을 짜기가 아주 어렵다. 나쁜 주석 대다수 주석이 이 범주에 속한다. 일반적으로 대다수 주석은 허술한 코드를 지탱하거나, 엉성한 코드를 변명하거나, 미숙한 결정을 합리화하는 등 프로그래머가 주절거리는 독백에서 크게 벗어나지 못한다. 주절거리는 주석 특별한 이유 없이 의무감으로 혹은 프로세스에서 하라고 하니까 마지못해 주석을 단다면 전적으로 시간낭비다. 주석을 달기로 결정했다면 충분한 시간을 들여서 최고의 주석을 달도록 노력한다. 주석이 이해가 안되어 다른 모듈까지 뒤져야 하는 주석을 독자와 제대로 소통하지 못하는 주석이다. 같은 이야기를 중복하는 주석 함수를 보고 의미를 해석할 수 있지만, 주석으로 함수에 대한 설명을 한다. 심지어 함수보다 의미를 잘 전달하지 못한다. 없는게 더 낫다. 즉, 주석이 더 많은 정보를 제공하지 못한다. 코드를 정당화하는 주석도 아니고, 의도나 근거를 설명하는 주석도 아니다. 코드보다 읽기가 쉽지도 않다. 오해할 여지가 있는 주석 때때로 의도는 좋았으나 프로그래머가 딱 맞을 정도로 엄밀하게는 주석을 달지 못하기도 한다. 의무적으로 다는 주석 모든 함수에 Javadocs를 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석기 그지없다. 이런 주석은 코드를 복잡하게 만들며, 거짓말을 퍼뜨리고 혼동과 무질서를 초래한다. 오히려 코드만 헷갈리게 만들며, 거짓말할 가능성을 높이며 잘못된 정보를 제공할 여지만 만든다. 이력을 기록하는 주석 예전에 사람들은 모듈을 편집할 때마다 모듈 첫머리에 주석을 추가한다. 그리하여 모듈 첫머리 주석은 지금까지 모듈에 가한 변경을 모두 기록하는 일종의 일지 혹은 로그가 된다. 이제는 그렇게 하지 않는다. 소스 코드 관리 시스템이 다양하기 때문이다. 완전히 제거하자. 있으나 마나 한 주석 너무 당연한 사실을 언급하며 새로운 정보를 제공하지 못하는 주석이 있다. 이는 제거해야 마땅하다. 무서운 잡음 때로는 Javadocs도 잡음이다. 함수나 변수로 표현할 수 있다면 주석을 달지 마라. 다음 코드를 살펴보자. 12// 전역 목록 &lt;smodule&gt;에 속하는 모듈이 우리가 속한 하위 시스템에 의존하는가?if(smodule.getDependSubsystems().contains(subSysMod.getSubSystem())) 위 코드에서 주석을 없애고 다시 표현하면 아래와 같다. 123ArrayLis moduleDependees = smoudle.getDependSubsystems();String ourSubSystem = subSysMod.getSubSystem();if(moduleDependees.contains(ourSubSystem)) 코드를 작성한 저자는 주석을 먼더 달고 주석에 맞춰 코드를 작성했는지도 모른다. 하지만 위와 같이 주석이 필요하지 않도록 코드를 개선하는 편이 낫다. 위치를 표시하는 주석 소스 파일에서 특정 위치를 표시하려 주석을 사용한다. 1// Actions //////////////// 위와 같은 배너 아래 특정 기능을 모아놓으면 유용한 경우도 있다. 하지만, 일반적으로 위와 같은 주석은 가독성만 낮추므로 제거해야 한다. 배너를 남용하면 흔한 잡음으로 여겨진다. 닫는 괄호에 다는 주석 닫는 괄호에 특수한 주석을 달기도 한다. 중첩이 심하고 장황한 함수라면 의미가 있을지도 모르지만 작고 캡슐화된 함수에는 잡음일 뿐이다. 그러므로 닫는 괄호에 주석을 달아야겠다는 생각이 든다면 대신에 함수를 줄이려 시도하자. 공로를 돌리거나 저자를 표시하는 주석 1/* Woo가 추가함 */ 소스 코드 관리 시스템(Git)은 누가 언제 무엇을 추가했는지 기억한다. 그래서 저자 이름으로 코드를 오염시킬 필요가 없다. 위와 같은 정보는 소스 코드 관리 시스템에 저장하는 편이 좋다. 주석으로 처리한 코드 주석으로 처리한 코드만큼 밉살스러운 관행도 드물다. 주석으로 처리된 코드는 다른 사람들이 지우기를 주저한다. 이유가 있어 남겨놓았으리라고, 중요하니까 지우면 안된다고 생각한다. 그래서 계속해서 쌓여만 간다. 안된다. 지우자! HTML 주석 HTML 주석은 혐오 그자체다. 주석을 읽기 쉬어야 하는 편집기/IDE에서조차 읽기가 어렵다. 전역 정보 주석을 달아야 한다면 근처에 있는 코드만 기술하라. 코드 일부에 주석을 달면서 시스템의 전반적인 정보를 기술하지 마라. 주석을 달 코드와 연관있는 주석을 달아야 한다. 너무 많은 정보 주석에 흥미로운 역사나 관련 없는 정보를 장황하게 늘어놓지 마라. 모호환 관계 주석과 주석이 설명하는 코드는 둘 사이 관계가 명백해야 한다. 이왕 공들여 주석을 달았다면 적어도 독자가 주석과 코드를 읽어보고 무슨 소린지 알아야 한다. 함수 헤더 짧은 함수는 긴 설명이 필요 없다. 짧고 한 가지만 수행하며 이름을 잘 붙은 함수가 주석으로 헤더를 추가한 함수보다 훨씬 좋다. 비공개 코드에서 Javadocs 공개 API는 Javadocs가 유용하지만 공개하지 않을 코드라면 Javadocs는 쓸모가 없다. 유용하지 않을 뿐만 아니라 Javadocs 주석이 요구하는 형식으로 인해 코드만 보기 싫고 산만해진다. 참고 Clean Code","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"주석","slug":"주석","permalink":"http://victorywoolee/victorywoolee.github.io/tags/주석/"}]},{"title":"[CleanCode] 3장","slug":"CleanCode03","date":"2019-09-15T04:20:20.000Z","updated":"2019-09-15T04:23:40.600Z","comments":true,"path":"2019/09/15/CleanCode03/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/15/CleanCode03/","excerpt":"","text":"해당 글은 Clean Code 책을 보면서 내용을 간단하게 정리한 글입니다.문제가 된다면 바로 삭제하도록 하겠습니다. 작게 만들어라! 함수를 만드는 첫째 규칙은 ‘작게’이다. 두번째 규칙은 ‘더 작게’이다. 함수가 하나의 이야기만을 표현하며 짧아야 한다. 블록과 들여쓰기 if문, else문, while문에 들어가는 블록은 한 줄이어야 한다는 의미이다. 대개 거기서 함수를 호출한다. 그러면 바깥을 감싸는 함수가 작아질 뿐 아니라, 블록 안에서 호출하는 함수 이름을 적절히 짓는다면, 코드를 이해하기도 쉬워진다. 즉, 중첩 구조가 생길만큼 함수가 커져서는 안된다는 뜻이다. 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안된다. 그래야 함수는 읽고 이해하기 쉬워진다. 한가지만 해라! 함수는 한 가지를 해야 한다. 그 한가지를 잘해야 한다. 그 한가지만을 해야 한다. 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다. 함수가 한 가지만 하는지 판단하는 방법이 있다. 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다. 함수당 추상화 수준은 하나로! 함수가 확실히 ‘한 가지’ 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다. 위에서 아래로 코드 읽기: 내려가기 규칙 코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다. 즉, 위에서 아애로 프로그램을 읽으면 추상화 수준이 한 번에 한 단계씩 낮아진다. 서술적인 이름을 사용하라! 워드는 “코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 된다.” 한 가지만 하는 함수에 좋은 이름을 붙인다면 이런 원칙을 달성함에 있어 성공했다. 함수가 작고 단순할수록 서술적인 이름을 고르기가 쉬워진다. 길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 길고 서술적인 이름이 서술적인 주석보다 좋다. 함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다. 그런 다음, 여러 단어를 사용해도 함수 기능을 잘 표현하는 이름을 선택한다. 이름을 붙일 때는 일관성이 있어야 한다. 함수 인수 함수에서 이상적인 인수 개수는 0개이다. 다음은 1개이고, 그 다음은 2개이다. 3개는 가능한 피하는 편이 좋다. 4개 이상은 특별한 이유가 필요하다. 인수는 개념을 이해하기 어렵게 만든다. 최선은 입력 인수가 없는 경우이며, 차선은 입력 인수가 1개뿐인 경우다. 많이 쓰는 단항 형식 함수에 인수 1개를 넘기는 이유는 가장 흔한 경우 두 가지이다. 1.하나는 인수에 질문을 던지는 경우다. boolean fileExists(“file”) 2.다른 하나는 인수를 뭔가로 변환해 결과를 반환하는 경우다. InputStream fileOpen(“file”) 명령과 조회를 분리하라. 다소 드물게 사용하지만, 아주 유용한 단항 함수 형식이 이벤트다. 이벤트 함수는 조심해서 사용한다. 이벤트라는 사실이 코드에 명확하게 드러나야 한다. 입력 인수를 변환하는 함수라면 변환 결과는 반환값으로 돌려준다. 플래그 인수 플래그 인수는 추하다. 함수로 부울 값을 넘기는 관례는 정말 끔찍하다. 왜냐면 함수가 한꺼번에 여러 가지를 처리한다고 알려주는 셈이기 때문이다. 플래그 인수를 사용해서 여러 가지 일을 처리하기 보다는 함수를 쪼개서 작은 일 하나를 함수로 처리하는 것이 낫다. 이항 함수 인수가 2인 함수는 인수가 1개인 함수보다 이해하기 어렵다. 예를 들어, writeField(name)는 writeField(outputStream, name)보다 이해하기 쉽다. 둘다 의미는 명백하지만 전자가 더 쉽게 읽히고 더 빨리 이해된다. 이항 함수가 무조건 나쁘다는 소리는 아니다. 프로그램을 짜다 보면 불가피한 경우도 생긴다. 하지만, 그만큼 위험이 따른다는 사실을 이해하고 가능하면 단항 함수로 바꾸도록 애써야 한다. 삼항 함수 인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다. 순서, 주춤, 무시로 야기되는 문제가 두 배 이상 늘어난다. 삼항 함수를 만들 때는 신중히 고려해야 한다. 인수 객체 인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어보자. 예를 들어, 다음 두 함수를 살펴보자. Circle makeCircle(double x, double y, double radius); Circle makeCircle(Point center, double radius); 위의 함수처럼 객체를 생성해 인수를 줄이는 방법이 눈속임이라 여겨질지 모르지만 그렇지 않다. 이전 예제에서 x와 y를 묶었듯이 변수를 묶어 넘기려면 이름을 붙여야 하므로 결국은 개념을 표혀하게 되는 것이다. 인수 목록 때로는 인수 개수가 가변적인 함수도 필요하다. String.format 메소드가 좋은 예다. String.format(“%s worke %.2f hours.”, name, hours); 위 예제처럼 가변 인수 전부를 동등하게 취급하면 List형 인수 하나로 취급할 수 있다. 이런 논리의 측면에서 String.format은 사실 이항 함수이다. 가변 인수를 취하는 모든 함수는 같은 원리가 적용된다. 가변 인수를 취하는 함수는 단항, 이항, 삼항 함수로 취급할 수 있다. 하지만 이를 넘어서는 인수를 사용할 경우 문제가 된다. void monad(Integer… args); void dyad(String name, Integer… args); 동사와 키워드 함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수다. 단항 함수는 함수와 인수가 동사, 명사 쌍을 이뤄야 한다. write(name) → 이름을 쓴다. writeField(name) → 이름이 필드. 위의 함수보다 더 명확해서 좋다. 함수 이름에 키워드를 추가해보자. assertEquals보다 assertExpectedEqualsActual(expected, actual)이 더 좋다. 그러면 순서를 기억하지 않아도 함수 이름으 보고 유추할 수 있다. 부수 효과를 일으키지 마라! 함수에서 한가지를 하겠다고 약속하고선 남몰래 다른 짓을 하면 안된다. 때로는 예상치 못하게 클래스 변수를 수정한다. 때로는 함수로 넘어온 인수나 시스템 전역 변수를 수정한다. 어느쪽이든 교활하고 해로운 거짓말이다. 많은 경우 시간적인 결합이나 순서 종속성을 초래한다. 시간적인 결합이 필요한 경우 함수 이름에 명시해야 한다. 출력 인수 일반적으로 출력 인수는 피해야 한다. 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 선택한다. 명령과 조회를 분리하라! 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다. 둘 다 하면 안된다. 객체 상태를 변경하거나 아니면 객체 정보를 반환하거나 둘 중 하나만 해야 한다. 둘 다 하게 된다면 의미가 모호해지기 때문이다. 그래서 명령과 조회를 분리해 혼란을 없애는 게 좋다. 오류 코드보다 예외를 사용하라! 명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다. 자칫하면 if문에서 명령을 표현식으로 사용하기 쉬운 탓이다. 오류 코드를 사용하게 되면 오류가 발생했을 때, 즉시 처리해야 한다. 그러면 if문이 중첩되어서 가독성이 떨어지게 된다. 이를 오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 깔끔해진다. Try/Catch 블록 뽑아내기 try/catch 블록은 원래 추하다. 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞는다. 그러므로 try/catch 블록을 별도의 함수로 뽑아내는 편이 좋다. 123456789101112131415161718public void delete(Page page)&#123; try&#123; deletePageAndAllReferences(page); &#125; catch(Exception e)&#123; logError(e); &#125;&#125;private void deletePageAndAllReferences(Page page) throws Exception&#123; deletePage(page); registry.deleteReference(page.name); configKeys.deleteKey(page.name.makeKey());&#125;private void logError(Exception e)&#123; logger.log(e.getMessage());&#125; 위에서 delete 함수는 모든 오류를 처리한다. 그래서 코드를 이해하기 쉽다.실제로 페이지를 제거하는 함수는 deletePageAndAllReferences() 함수이다.deletePageAndAllReferences 함수는 예외를 처리하지 않는다.이렇게 정상 동작과 오류 처리 동작을 분리하면 코드를 이해하고 수정하기 쉬워진다. 오류 처리도 한 가지 작업이다. 함수는 한 가지 작업만 해야 한다. 오류 처리도 한 가지 작업에 속한다. 그러므로 오류를 처리하는 함수는 오류만 처리해야 한다. 반복하지 마라! 중복은 문제다. 코드 길이가 늘어날 뿐 아니라 알고리즘이 변하면 네 곳이나 손을 봐야 한다. 중복을 없앴더니 모듈 가독성이 크게 높아졌다. 중복은 소프트웨어에서 모든 악의 근원이다. 객체 지향 프로그래밍은 코드를 부모 클래스로 올려서 중복을 없앤다.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"함수","slug":"함수","permalink":"http://victorywoolee/victorywoolee.github.io/tags/함수/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-13T03:13:02.479Z","updated":"2019-09-13T03:13:02.479Z","comments":true,"path":"2019/09/13/hello-world/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}