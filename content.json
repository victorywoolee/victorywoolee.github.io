{"meta":{"title":"VictoryWoo","subtitle":"VictoryWoo's Blog","description":null,"author":"John Doe","url":"http://victorywoolee/victorywoolee.github.io","root":"/"},"pages":[],"posts":[{"title":"[Android] Compose","slug":"Android-Compose","date":"2019-10-05T08:07:49.000Z","updated":"2019-10-06T13:21:00.377Z","comments":true,"path":"2019/10/05/Android-Compose/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/05/Android-Compose/","excerpt":"","text":"왜??선언적 프로그래밍이 UI 프로그래밍에 있어서 부상하고 있는 이유는 갈수록 복잡해지고 다양해지는 UI/UX 때문이라고 할 수 있다. 특히 애니메이션 같은 부분은 명령형으로 처리하기 매우 까다롭다. 가장 중요한 뷰의 상태라는 것에만 신경쓰고, 상세한 부분들은 프레임워크가 알아서 해주기를 기대하는 것이다. 기존의 안드로이드 UI 시스템에는 다음과 같은 문제가 있다. 안드로이드 프레임워크와 강하게 묶여있다. 안드로이드에서 제공하는 다양한 라이브러리들은 각자 버전이 따로 업데이트 된다. 그리고 개발자들은 다른 라이브러리를 신경쓰지 않고 필요한 버전만 해당 라이브러리에 적용해서 사용할 수 있다. 반면에, UI는 SDK와 함께 버전업이 되기 때문에 새로운 기능을 사용하려면 SDK를 함께 업데이트해야 한다. 하지만, SDK에는 UI만 있는게 아니기 때문에 버전을 올리기가 쉽지 않다. 예를 들면, 마시멜로에서 생긴 권한 체크가 그 중 한가지이다. 복잡한 코드와 클래스 구조 View.java의 소스는 거의 3만줄에 육박한다. 그만큼 복잡하며 길다. 그리고 특정 뷰에 어울리지 않는 동작들이 있다. 예를 들면, Button이 TextView의 속성을 그대로 가지고 있다. 그래서 버튼 안의 텍스트를 선택하거나 수정하는 등의 동작이 가능하다. 설명 영상에서는 이를 API Regret이라고 표현했다. 너무 많은 코드 커스텀 뷰를 작성하게 된다면 작성해야 하는 파일이 많다. 새로운 속성을 추가하기 위해서는 접근해야 하는 곳이 많다. CustomView.kt layout.xml attrs.xml styles.xml 이렇게 커스텀 뷰에 대해서 분산되어 있는 코드로 인해 수정과 유지보수를 위한 비용이 많이 든다. 일관되지 않은 데이터 흐름MVP, MVVM, MVI 등의 프론트엔드 아키텍처는 데이터 흐름을 일관되게 유지하는 것을 목적으로 하고 있다고 할 수 있다. 이러한 아키텍처들은 대부분 뷰에 상태를 두지 않고, 뷰의 변화를 관찰하는 개체가 뷰의 상태를 관리한다. 이를 통해서 데이터의 흐름이 한 방향으로 흐르도록 할 수 있다. 반면, 안드로이드 UI 시스템은 이러한 아키텍처들과는 다소 상반되는 구조를 가지고 있다. 안드로이드의 뷰들은 각자만의 상태를 가지고 있고, 스스로 상태를 제어한다. 이렇다보니 코드를 깔끔하게 만들지 않는다면 UI를 구현할 때나 디버깅을 할 때 힘들다. 목표??위에서 봤듯이 꽤 큰 문제들이 있다. Compose는 이러한 문제를 어떻게 해결할 수 있을까? SDK와 UI를 분리 SDK와 UI를 분리함으로써 서로 의존성을 갖지 않게 하여 UI를 업데이트하는데 편리함을 갖게 될 수 있다. 재사용 가능하고 간단한 View 구조 불필요한 상속을 없애고, 보일러플레이트 코드를 제거하는 것을 목표로 한다. 재사용 가능하고 작성한 대로 출력되는 직관적인 UI 코드를 작성하는 것이 목표다. 적은 코드 커스텀 뷰를 작성할 때처럼 layout, attr, style과 같은 파일로 분산시켜 작성하는 것에서 하나의 UI 코드를 작성함으로써 수정 및 유지보수의 비용을 줄일 수 있다. 하나의 데이터 흐름 State는 하나의 Owner만 갖으며, 하나의 Owner만 State를 변경한다. Owner가 이벤트를 감지하고 변경을 주도한다. Compose??1. UI 작성을 위한 선언적 방법 Jetpack에 포함된 Compose는 UI 개발을 단순화하도록 설계된 번들 툴킷이다. 반응형 프로그래밍 모델과 Kotlin 프로그래밍 언어의 간결함 및 사용 편의성을 결합한다. 주의해야할 점은 Compose가 아직 초기 알파 단계 버전이기 때문에 실제 프로덕션에 사용하는 것을 권장하지는 않는다. 2. 핵심 원칙 Concise and Idiomatic Kotlin(간결하고 관용적인 코틀린) 코틀린이 제공하는 이점으로 간결하고 안전하며 Java 언어와 완벽하게 상호 운용된다. 작성해야 하는 상용구 코드의 양을 대폭 줄이도록 설계되어 앱 코드에 집중하고 전체 클래스의 오류를 피할 수 있다. Declarative(선언적) 레이아웃을 그리는 것부터 생성을 포함해서 UI 구성 요소를 정의하는데 선언적인 방법을 사용한다. UI를 컴포저블 함수로 표현하면 프레임워크는 뷰 계층에 대한 자동 업데이트를 하고 UI 최적화를 처리한다. Compatible(호환) 기존의 View와 호완되므로 모든 Android 및 Jetpack API에 직접 접근해 원하는대로 혼합시키고 일치시킬 수 있다. Enable Beautiful Apps(아름다운 앱 사용) 처음부터 Material Design과 애니메이션으로 설계되어 모션이 가득한 멋진 앱을 만들 수 있다. Accelerate Development(개발 가속화) 적은 코드를 작성하고 Apply Changes 및 라이브 미리보기와 같은 도구를 사용해 개발을 가속화할 수 있다. 3. 핵심적인 아이디어 UI as a function 어떤 입력을 받아 결과를 반환하는 함수의 아이디어를 UI로 확장해서 어떤 입력을 받아 UI 구조를 반환하는 함수라고 생각하면 된다. 함수는 어떠한 상태도 가지고 있지않고, 외부의 어떤 상태도 변경해서는 안된다. 그저 자신이 그려야할 UI의 계층을 반환할 뿐이다. -&gt; 순수함수 또한, Kotlin의 함수로 UI를 표현하기 때문에 XML에서는 불가능한 프로그래밍 언어의 다양한 기능을 UI를 작성하는데 활용할 수 있다. 123fun Greeting(name: String)&#123; Text(\"Hello $name\")&#125; Composable is composable Compose의 UI 위젯을 사용하기 위해서는 @Composable 어노테이션을 붙여줘야 한다. 그리고 이 함수는 다른 Composable 함수를 포함할 수 있다. 1234@Composablefun Greeting(name: String)&#123; Text(\"Hello $name\")&#125; Observable Model 데이터의 변경이 생길 때마다 직접 UI를 업데이트하는 건 번거로운 작업이다. 이런 문제를 해결하기 위해 RxJava나 LiveData와 같은 Observable을 사용하면 된다. 123vm.state.observe(this) &#123; state -&gt; updateUi(state)&#125; Compose에서는 데이터가 바뀔 때마다 UI를 변경시키기 위해서 LiveData를 사용하는 방법을 쓸 수도 있다. 123vm.name.observe(this) &#123; name -&gt; Greeting(name)&#125; 그려야할 데이터가 많다면 각 데이터에 대해 일일히 LiveData를 만들어줘야 하기 때문에 불편하다. 이런 경우에는 data class에 @Model 어노테이션을 붙여주어 값이 변경될 때마다 해당 값을 참조하고 있는 Composable 함수가 다시 Compose 된다고 한다. 2가지 주요 구성 요소 레이아웃, 입력, 텍스트, 애니메이션, 스타일, 위젯 및 그래픽이 포함된 핵심 UI 툴킷이 포함된 UI 라이브러리를 포함해야 한다. 컴포저블 기능을 수행하고 UI 계층 구조를 자동으로 업데이트하는 사용자 정의 Kotlin 컴파일러 플러그인, Compose 컴파일러를 포함해야 한다. Compose Application은 애플리케이션 데이터를 UI 계층으로 변환하는 Composable한 함수로 구성되어있다. @Composable 어노테이션을 추가해 컴포저블한 함수를 만들 수 있다. 기본적으로 Compose는 사용자 정의 Kotlin 컴파일러 플러그인을 사용하므로 기본 데이터가 변경되면 업데이트 가능한 UI 계층을 생성하기 위해 작성 가능한 기능을 다시 호출할 수 있다. 실행Compose는 아직 pre-alpha 단계다. 그래서 다른 라이브러리처럼 간단하게 dependency를 추가해서 사용할 수 없다. 대신에 오픈 소스를 가져와서 직접 빌드해야 한다. repo AOSP(Android Open Source Project)에서는 repo라는 툴을 사용해 버전 관리를 한다. Git과 비슷하지만, 안드로이드에 좀 더 적합하게 만들었다고 한다. 다음 명령어를 통해 repo를 설치하면 된다. 12$ curl https://storage.googleapis.com/git-repo-downloads/repo &gt; repo$ chmod a+x repo source 초기화 및 소스 코드의 Sync를 맞춘다.12$ repo init -u https://android.googlesource.com/platform/manifest -b androidx-master-dev$ repo sync -j8 -c 시작 소스를 내려받고 /frameworks/support/ui 위치로 이동해서 안드로이드 스튜디오를 실행하면 된다. 평소에 사용하는 버전이 아니라 지정된 버전을 사용해야 하기 때문에 studiow를 통해 안드로이드 스튜디오를 실행하면 된다고 한다. 12$ cd androidx-master-dev/frameworks/support/ui$ ./studiow API - Annotations Composable 이 어노테이션을 붙인 함수는 Compose의 기본이 되는 Composable Widget으로써 기능한다. 반환 타입을 따로 정의하지 않는다. 코틀린 컴파일러 플러그인을 통해서 구현된다. 따라서 컴파일 전과 후의 코드는 완전히 다르고, 우리가 일반적으로 알던 코틀린의 실행 흐름과 다르게 동작할 수 있다. Model 위젯에서 사용되는 데이터를 정의할 수 있다. 이 모델이 변경될 경우 위젯이 다시 렌더링된다. API - EffectsEffect는 위젯을 그리는 단계에서 어떠한 코드를 실행하고 싶을 때 사용한다. 이해하기 위해서 Compose의 실행 흐름을 이해할 필요가 있다 Execution Flow 1) Composition Phase 이 단계에서는 어떤 위젯을 그릴 것인지 선언한다. 선언적 프로그래밍 패러다임에는 지연 실행이라는 개념이 있는데, 최대한 실제 실행을 뒤로 미루는 것을 말한다. 이렇게 화면에 렌더링을 한다라는 실제 실행을 하기 이전에 어떻게 그릴 것인가를 정의하는 단계이다. 2) Execution Phase Compostion Phase에서 정의했던 Component의 그래프를 화면에 렌더링하는 단계이다. 123456789101112@Modeldata class Counter(val number: Int=0)&#123; fun increment(): Counter = Counter(number + 1)&#125;@Composablefun CounterWidget()&#123; var counter = Counter() Text(text = \"Counter : $&#123;counter.value&#125;\") Button(onClick = &#123;counter = counter.increment()&#125;)&#125; CounterWidget에는 counter라는 로컬 변수, 즉 상태가 존재한다. Text에서는 그것을 보여주고 Button에서는 그 값을 업데이트하고 있다. @Model로 모델 클래스임을 명시했으니 모든게 완벽하다. 버튼을 누르면 값이 증가하는 동작을 실행할 것 같지만 그렇지 않다. 앞서 @Composable 어노테이션을 이야기할 때, 코드가 일반적인 코틀린의 실행 흐름과는 다르게 동작할 수 있다고 언급했었다. Compose의 위젯들은 일종의 Context 위에서 실행된다. 따라서 위젯에서 필요한 데이터 역시 이 Context 위에 올라가 있어야 한다. 이를 도와주는게 Effect라는 것을 사용하면 가능하다. 123456789101112@Modeldata class Counter(val number: Int=0)&#123; fun increment(): Counter = Counter(number + 1)&#125;@Composablefun CounterWidget()&#123; var counter = +memo&#123; Counter() &#125; Text(text = \"Counter : $&#123;counter.value&#125;\") Button(onClick = &#123;counter = counter.increment()&#125;)&#125; 이전의 코드에서 memo Effect와 해당 Effect를 resolve하는 +(unaryPlus) 연산자 오버로딩 함수를 붙여주면 제대로 동작함을 확인할 수 있다. Effect의 이름 Effect는 개념적으로 리턴 값을 가지고 있는 Composable 함수이고 이게 Compose의 실행 흐름에 일종의 효과를 적용하는 것과 비슷해서 Effect라고 지은 것으로 추측된다. Defined Effects 몇 가지 미리 정의되어 있는 Effect들이 존재하며 다음과 같다. 실제 사용 예는 대부분 실행 단계에서 필요한 어떤 값을 가져오기 위한 목적으로 쓴다. Memo 단순히 어떤 실행 블록을 기억하는 역할을 한다.123fun &lt;T&gt; memo(calculation: () -&gt; T) = effectOf&lt;T&gt;&#123; context.remember(calculation)&#125; calculation 코드 블록에서 반환하는 클래스에 @Model이 붙어있지 않으면 Composition이 다시 이루어져도 이 코드 블록은 재실행되지 않는다. State memo와 비슷하지만, 단순히 어떤 코드 블록을 기억하는 목적이 아니라 위젯에서 사용할 Local State의 개념을 가지고 있는 Effect이다. State는 Compose의 모델 클래스이고, 단순히 어떤 값을 wrapping하고 있는 클래스다. 123456fun &lt;T&gt; state(init: () -&gt; T) = memo &#123; State(init()) &#125;@Modelclass State&lt;T&gt; internal constructor(value: T) : Framed &#123; /* ... */&#125; Lifecycle Effects 그 외 3 가지 Composition의 라이프사이클에 관련된 Effect가 존재한다. onActive : Composition이 처음 실행될 때 호출되고, 그 이후로는 호출되지 않는다. onDispose : 해당 위젯이 더 이상 화면에서 보이지 않을 때 호출된다. onCommit : Compostion이 실행될 때마다 호출된다. 선언형 프로그래밍과 명령형 프로그래밍 명령형 프로그래밍 프로그래밍의 상태와 상태를 변경시키는 구문의 관점에서 연산을 설명하는 방식 알고리즘을 명시하고 목표는 명시하지 않는다.123val container = binding.containercontainer.removeAllViews()containter.setBackgroundColor(Color.BLUE) 원하는 상태를 만들기 위해 명령문을 사용한다. 위의 코드는 container에게 모든 뷰를 제거, 백그라운드 색상을 지정하는 등의 명령을 내린다. 제어 흐름이 명확하다는 장점이 있지만, 반대로 어떤 상태에 도달하려는 것인지 명확하지 않다. 선언형 프로그래밍 제어 흐름이 아니라 어떤 상태를 원하는지 서술한다.123456return State( backgroundColor = Color.RED, children = [ createNewButton() ]) 이런 방식이 제대로 동작하기 위해서는 이전 상태와 다음 상태를 비교하고 전환을 수행하는 기능을 프레임워크가 제공해야 한다. 리액트가 이런 방식으로 동작한다고 한다. 상태를 비교하고 상태가 다를 경우 해당 부분만 렌더링한다. 참고 Google Developer Android Studio Jetpack Compose &amp; Sample App How to install Repo @tura velog","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Jetpack","slug":"Jetpack","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Jetpack/"},{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Compose","slug":"Compose","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Compose/"}]},{"title":"[CleanCode] 8장","slug":"CleanCode08","date":"2019-10-04T13:24:51.000Z","updated":"2019-10-05T01:46:20.302Z","comments":true,"path":"2019/10/04/CleanCode08/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/04/CleanCode08/","excerpt":"","text":"외부 코드 사용하기 인터페이스 제공자와 인터페이스 사용자 사이에는 특유의 긴장이 존재한다. 패키지 제공자나 프레임워크 제공자는 적용성을 최대한 넓히려 애쓴다. 더 많은 환경에서 돌아가야 더 많은 고객이 구매하기 때문이다. 반면, 사용자는 자신의 요구에 집중하는 인터페이스를 바란다. 이런 긴장으로 인해 시스템 경계에서 문제가 생길 소지가 많다. Map은 굉장히 다양한 인터페이스로 수많은 기능을 제공한다. Map이 제공하는 기능성과 유연성은 확실히 유용하지만, 그만큼 위험부담이 크다. ex)12Map sensors = new HashMap(); // Map 생성Sensor s = (Sensor) sensors.get(sensorId); // Sensor 객체를 가져온다. 위와 같은 코드가 한 번이 아니라 여러 차례 나온다. 즉, Map이 반환하는 Object를 올바른 유형으로 변환할 책임은 Map을 사용하는 클라이언트에 있다. 그래도 코드는 올바르게 동작한다. 하지만, 깨끗한 코드라 보기 어렵다. 제네릭을 사용하면 코드 가독성이 높아진다. 12Map&lt;String, Sensor&gt; sensors = new HashMap&lt;Sensor&gt;();Sensor s = sensors.get(sensorId); 하지만, 위의 방법도 결국 사용자에게 필요하지 않은 기능까지 제공한다는 문제가 남아있다. Map&lt;String, Sensor&gt;아래는 Map을 조금 더 깔끔하게 사용한 코드다. Sensors 사용자는 제네릭이 사용되었는지 여부에 신경 쓸 필요가 없다. 제네릭의 사용 여부는 Sensors 안에서 결정한다. 1234567public class Sensors&#123; private Map sensors = new HashMap(); public Sensor getById(String id)&#123; return (Sensor) sensors.get(id); &#125;&#125; 경계 인터페이스인 Map은 Sensors 안으로 숨긴다. 따라서 Map 인터페이스가 변하더라도 나머지에는 영향을 미치지 않는다. 제네릭을 사용하든 말든 문제가 되지 않는다. Sensors 클래스 안에서 객체 유형을 관리하고 변환하기 때문이다. 또한, Sensors 클래스는 프로그램에 필요한 인터페이스만 제공한다. 그래서 코드는 이해하기 쉽지만 오용하기는 어렵다. Sensors 클래스는 나머지 프로그램이 설계 규칙과 비즈니스 규칙을 따르도록 강제할 수 있다. Map과 같은 경계 인터페이스를 사용할 때는 이를 이용하는 클래스나 클래스 계열 밖으로 노출되지 않도록 주의한다. Map 인스턴스를 공개 API의 인수로 넘기거나 반환값으로 사용하지 않는다. 경계 살피고 익히기 외부 코드를 익히기는 어렵다. 외부 코드를 통합하기도 어렵다. 곧바로 우리쪽 코드를 작성해 외부 코드를 호출하는 대신 먼저 간단한 테스트 케이스를 작성해 외부 코드를 익히면 어떨까? 이를 학습 테스트라 부른다. 학습 테스트는 프로그램에서 사용하려는 방식대로 외부 API를 호출한다. 통제된 환경에서 API를 제대로 이해하는지를 확인하는 셈이다. 학습 테스트는 API를 사용하려는 목적에 초점을 맞춘다. 학습 테스트는 공짜 이상이다 학습 테스트에 드는 비용은 없다. 오히려 필요한 지식만 확보하는 손쉬운 방법이다. 이해도를 높여준다. 투자하는 노력보다 얻는 성과가 크다. 학습 테스트를 이용한 학습이 필요하든 그렇지 않든, 실제 코드와 동일한 방식으로 인터페이스를 사용하는 테스트 케이스가 필요하다. 이런 경계 테스트가 있다면 패키지의 새 버전으로 이전하기 쉬워진다. 그렇지 않다면 낡은 버전을 필요 이상으로 오랫동안 사용하려는 유혹에 빠지게 된다. 아직 존재하지 않는 코드를 사용하기 경계와 관련해 또 다른 유형은 아는 코드와 모르는 코드를 분리하는 경계다. 아직 존재하지 않는 코드를 위해 인터페이스를 사용해 설계를 먼저 한다. 우리가 바라는 인터페이스를 구현하면 우리가 인터페이스를 전적으로 통제한다는 장점이 생긴다. 또한 코드 가독성도 높아지고 코드 의도도 분명해진다. 깨끗한 경계 경계에 위치하는 코드는 깔끔히 분리한다. 또한 기대치를 정의하는 테스트 케이스도 작성한다. 통제가 불가능한 외부 패키지에 의존하는 대신 통제가 가능한 우리 코드에 의존하는 편이 훨씬 좋다. 자칫하면 외부 코드에 휘둘리고 만다. 외부 패키지를 호출하는 코드를 가능한 줄여 경계를 관리하자. 새로운 클래스로 경계를 감싸거나 Adapter 패턴을 사용해 우리가 원하는 인터페이스를 패키지가 제공하는 인터페이스로 변환하자. 어느 방법이든 코드 가독성이 높아지며, 경계 인터페이스를 사용하는 일관성도 높아지며, 외부 패키지가 변했을 때, 변경할 코드도 줄어든다.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"경계","slug":"경계","permalink":"http://victorywoolee/victorywoolee.github.io/tags/경계/"}]},{"title":"[CleanCode] 7장","slug":"CleanCode07","date":"2019-10-04T08:39:45.000Z","updated":"2019-10-04T12:04:16.120Z","comments":true,"path":"2019/10/04/CleanCode07/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/04/CleanCode07/","excerpt":"","text":"깨끗한 코드와 오류 처리는 연관성이 있다. 상당수 코드 기반은 전적으로 오류 처리 코드에 좌우된다. 여기저기 흩어진 오류 처리 코드 때문에 실제 코드가 하는 일을 파악하기가 거의 불가능하다는 의미다. 오류 처리는 중요하다. 하지만, 오류 처리 코드로 인해 프로그램 논리를 이해하기 어려워진다면 깨끗한 코드라 부르기 어렵다. 오류 코드보다 예외를 사용하라 예외를 처리하지 않고 오류를 처리하고 보고하는 방법은 제한적이다. 오류 플래그를 설절하거나 호출자에게 오류 코드를 반환하는 방법이 전부다. 이와 같은 방법은 호출자 코드가 복잡해진다. 함수를 호출한 즉기 오류를 확인해야 하기 때문이다. 이 단계는 잊어버리기 쉽다. 오류가 발생하면 예외를 던지는 편이 낫다. 그러면 호출자 코드가 깔끔해진다. 예외를 던지면 코드가 확실히 깨끗해진다. 코드 품질도 나아진다. Try-Catch-Finally 작성해라 try 블록에 들어가는 코드를 실행하면 어느 시점에서든 실행이 중단된 후 catch 블록으로 넘어갈 수 있다. try 블록은 트랜잭션과 비슷하다. try 블록에서 무슨 일이 생기든지 catch 블록은 프로그램 상태를 일관성 있게 유지해야 한다. 그러므로 예외가 발생할 코드를 짤때는 try-catch-finally 문으로 시작하는 편이 낫다. 그러면 try 블록에서 무슨 일이 생기든지 호출자가 기대하는 상태를 정의하기 쉬워진다. 미확인을 사용하라 자바가 처음에 나왔을 때는 사람들이 확인된 예외를 멋진 아이디어라고 생각했다. 당시에는 그랬지만, 지금은 아니다. 확인된 오류가 치르는 비용에 상응하는 이익을 제공하는지 철저히 따져봐야 한다. 확인된 예외는 OCP를 위반한다. 예를 들어, 메소드에서 확인된 예외를 던졌는데 catch 블록이 세 단계 위에 있다면 그 사이 메소드 모두가 선언부에 해당 예외를 정의해야 한다. 즉, 하위 단계에서 코드를 변경하면 상위 단계 메소드 선언부를 전부 고쳐야 한다. 모듈과 관련된 코드가 전혀 바뀌지 않았더라도 (선언부가 바뀌었으므로) 모듈을 다시 빌드한 다음 배포해야 한다는 말이다. 대규모 시스템에서 호출이 일어나는 방식을 생각해보자. 최상위 함수가 아래 함수를 호출한다. 아래 함수는 그 아래 함수를 호출한다. 단계를 내려갈수록 호출하는 함수의 수가 늘어난다. 이제 최하위 함수를 변경해 새로운 오류를 던진다고 가정하자. 확인된 오류를 던진다면 함수는 선언부에 throws 절을 추가해야 한다. 그러면 변경한 함수를 호출하는 함수 모두가 catch 블록에서 새로운 예외를 처리하거나 선언부에 throw 절을 추가해야 한다. 결과적으로 취하위 단계에서 최상위 단계까지 연쇄적인 수정이 일어난다. throws 경로에 위치하는 모든 함수가 최하위 함수에서 던지는 예외를 알아야 하므로 캡슐화가 깨진다. 오류를 원거리에서 처리하기 위해 예외를 사용한다는 사실을 감안한다면 이처럼 확인된 예외가 캡슐화를 깨버리는 현상은 참으로 유감스럽다. 예외에 의미를 제공하라 예외를 던질 때는 전후 상황을 충분히 덧붙인다. 그러면 오류가 발생한 원인과 위치를 찾기가 쉬워진다. 호출자를 고려해 예외 클래스를 정의하라 오류를 분류하는 방법은 수없이 많다. 오류가 발생한 위치로 분류할 수도 있고, 오류가 발생한 컴포넌트로 분류한다. 또는 유형으로도 분류가 가능하다. 하지만, 애플리케이션에서 오류를 정의할 때 프로그래머에게 가장 중요한 관심사는 오류를 잡아내는 방법이 되어야 한다. 아래는 외부 라이브러리를 호출하는 try-catch-finally문을 포함한 코드이다. 12345678910111213141516ACMEPort port = new ACMEPort(12);try&#123; port.open();&#125; catch(DeviceResponseException e)&#123; reportPortError(e); logger.log(\"Device response exception\", e);&#125; catch(ATM1212UnlockedException e)&#123; reportPortError(e); logger.log(\"Unlock exception\", e);&#125; catch(GMXError e)&#123; reportPortError(e); logger.log(\"Device response exception\", e);&#125; finally&#123; ...&#125; 중복이 심하지만 놀랍지 않다. 대다수 상황에서 우리가 오류를 처리하는 방식은 (오류를 일으킨 원인과 무관하게)비교적 일정하다. 오류를 기록한다. 프로그램을 계속 수행해도 좋은지 확인한다. 위의 경우는 예외를 대응하는 방식이 예외 유형과 무관하게 거의 동일하다. 그래서 코드를 고치기 쉽다. 123456789LocalPort port = new LocalPort(12);try &#123; port.open();&#125; catch(PortDeviceFailure e)&#123; reportError(e); logger.log(e.getMessage(), e)&#125; finally&#123; ...&#125; LocalPort 클래스가 ACMEPort 클래스가 던지는 예외를 잡아 변환하는 감싸주는 클래스다. LocalPort 클래스처럼 ACMEPort를 감싸는 클래스는 유용하다. 이렇게 외부 API를 감싸면 외부 라이브러리와 프로그램 사이에서 의존성이 크게 줄어든다. 나중에 다른 라이브러리로 갈타도 비용이 적다. 또한, 감싸기 클래스에서 외부 API를 호출하는 대신 테스트 코드를 넣어주는 방법으로 프로그램을 테스트하기도 쉬워진다.123456789101112131415161718192021222324public class LocalPort&#123; private ACMEPort innerPort; public LocalPort(int portNumber)&#123; innerPort = new ACMEPort(portNumber); &#125; public void open()&#123; try&#123; innerPort.open(); &#125; catch(DeviceResponseException e)&#123; reportPortError(e); logger.log(\"Device response exception\", e); &#125; catch(ATM1212UnlockedException e)&#123; reportPortError(e); logger.log(\"Unlock exception\", e); &#125; catch(GMXError e)&#123; reportPortError(e); logger.log(\"Device response exception\", e); &#125; finally&#123; ... &#125; &#125;&#125; 정상 흐름을 정의하라 비즈니스 논리와 오류 처리가 잘 분리된 코드가 깨끗하다. 그리고 간결한 알고리즘이 보이기 시작한다. 하지만, 그러다 보면 오류 감지가 프로그램 언저리로 밀려난다. 외부 API를 감싸 독자적인 예외를 던지고 코드 위에 처리기를 정의해 중단된 계산을 처리한다. 대개는 멋진 방식이지만, 때로는 중단이 적합하지 않은 때도 있다. 특수 상황을 처리할 필요가 없다면 더 좋고, 코드가 훨씬 깔끔해진다. 특수 사례 패턴은 클래스를 만들거나 객체를 조작해 특수 사례를 처리하는 방식이다. 그러면 클라이언트 코드가 예외적인 상황을 처리할 필요가 없어진다. 클래스나 객체가 예외적인 상황을 캡슐화해서 처리하므로. null을 반환하지 마라 null을 반환하는 코드는 일거리를 늘릴 뿐만 아니라 호출자에게 문제를 떠넘긴다. null 확인을 중간에 빼먹는다면 애플리케이션이 통제 불능에 빠지게 될지도 모른다. 메소드에서 null을 반환하고픈 유혹이 든다면 그 대신 예외를 던지거나 특수 사례 객체를 반환한다. 사용하려는 외부 API가 null을 반환한다면 감싸기 메소드를 구현해 예외를 던지거나 특수 사례 객체를 반환하는 방식을 고려한다. 123456List&lt;Employee&gt; employees = getEmployees();if(employees != null)&#123; for (Employee e: employees)&#123; totalPay += e.getPay(); &#125;&#125; 위에서 getEmployees()는 null을 반환할 수도 있다. 하지만, 반드시 null을 반환할 필요가 있을까? getEmployees()를 변경해 빈 리스트를 반환한다면 코드가 훨씬 깔끔해진다. 12345678910public List&lt;Employee&gt; getEmployees()&#123; if(직원이 없다면)&#123; return Collections.emptyList(); &#125;&#125;List&lt;Employee&gt; employees = getEmployees();for (Employee e: employees)&#123; totalPay += e.getPay();&#125; Collections.emptyList()가 있어 미리 정의된 읽기 전용 리스트를 반환한다. null을 반환하는 부분을 변경하면 위 코드처럼 깔끔하게 처리할 수 있으며 NullPointerException이 발생할 가능성도 줄어든다. null을 전달하지 마라 메소드로 null을 전달하는 방식을 null을 반환하는 것보다 더 나쁘다. 정상적인 인수로 null을 기대하는 API가 아니라면 메소드로 null을 전달하는 코드는 최대한 피한다. 대다수 프로그래밍 언어는 호출자가 실수로 넘기는 null을 적절하게 처리하는 방법이 없다. 그렇다면 애초에 null을 넘기지 못하도록 금지하는 정책이 합리적이다. 즉, 인수로 null이 넘어오면 코드에 문제가 있다는 의미다. 이런 정책을 따르면 그만큼 부주의한 실수를 저지를 확률도 작아진다. 결론깨끗한 코드는 읽기도 좋아야 하지만 안정성도 높아야 한다. 이 둘은 상충하는 목표가 아니다. 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하면 튼튼하고 깨끗한 코드를 작성할 수 있다. 오류 처리를 프로그램 논리와 분리하면 독립적인 추론이 가능해지며 코드 유지보수성도 크게 높아진다.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"오류 처리","slug":"오류-처리","permalink":"http://victorywoolee/victorywoolee.github.io/tags/오류-처리/"}]},{"title":"[Kotlin] 클래스와 인터페이스","slug":"Chap4-1","date":"2019-10-04T06:35:18.000Z","updated":"2019-10-08T11:58:57.079Z","comments":true,"path":"2019/10/04/Chap4-1/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/04/Chap4-1/","excerpt":"","text":"클래스 계층 정의1. 코틀린 인터페이스 추상 메소드 뿐 아니라 구현이 있는 메소드도 정의할 수 있다. 아무런 상태(필드)도 들어갈 수 없다. 인터페이스의 선언은 자바와 같으며, extends(상속)와 implements(구현)은 코틀린에서는 모두 콜론(:) 키워드를 사용해 클래스 확장과 인터페이스 구현을 모두 처리한다. override 변경자는 상위 클래스나 상위 인터페이스에 있는 프로퍼티나 메소드를 오버라이드한다는 표시다. 꼭 사용해야 한다. 디폴트 구현은 단지 메소드 본문은 시그니처 뒤에 작성하면 된다. 1234interface Clickable&#123; fun click() // 일반 메소드 선언 fun showOff() = println(\"I'm clickable!! \") // 디폴트 구현이 있는 메소드&#125; 위 인터페이스를 구현하는 클래스는 click에 대한 구현을 제공해야 한다. 반면, showOff() 메소드의 경우 새로운 동작은 정의할 수도 있고 그냥 정의를 생략해서 디폴트 구현을 사용할 수도 있다. 그러면 다른 인터페이스가 showOff()와 같은 구현을 포함한다고 가정해보자. 1234interface Focusable&#123; fun setFocus(b: Boolean) = println(\"I $&#123;if (b) \"got\" else \"lost\"&#125; focus. \") fun showOff() = println(\"I'm focusable!! \")&#125; 이제 한 클래스에서 이 두 인터페이스를 함께 구현하면 어떻게 될지 궁금하다. 두 인터페이스 모두 디폴트 구현이 들어있는 showOff() 메소드가 있다. 어느쪽 showOff() 메소드가 선택될까? 결론은 어느쪽도 선택되지 않는다. 클래스가 구현하는 두 상위 인터페이스에 정의된 showOff() 구현을 대체할 오버라이딩 메소드를 직접 제공하지 않으면 컴파일 오류가 발생한다. 이처럼 코틀린 컴파일러는 두 메소드를 아우르는 구현을 하위 클래스에 직접 구현하게 강제한다. 123456789class Button: Clickable, Focusable&#123; override fun click() = println(\"I was clicked!! \") override fun showOff() &#123; super&lt;Clickable&gt;.showOff() super&lt;Focusable&gt;.showOff() // 상위 타입의 이름을 꺽쇠 괄호 사이에 넣어서 super를 지정하면 // 어떤 상위 타입의 메소드를 호출할 지 지정할 수 있다. &#125;&#125; super.showOff()처럼 꺽쇠 괄호 안에 기반 타입 이름을 지정한다. 상속한 구현 중 단 하나만 호출해도 된다면 상위 타입의 메소드를 하나만 지정해도 된다. 2. open, final, abstract 변경자 취약한 기반 클래스라는 문제는 하위 클래스가 기반 클래스에 대해 가졌던 가정이 기반 클래스를 변경함으로써 깨져버린 경우에 생긴다. 어떤 클래스가 자신을 상속하는 방법에 대해 정확한 규칙(어떤 메소드를 어떻게 오버라이드해야 하는지 등)을 제공하지 않는다면 그 클래스의 클라이언트는 기반 클래스를 작성한 사람의 의도와 다른 방식으로 메소드를 오버라이드할 위험이 있다. 모든 하위 클래스를 분석하는 것은 불가능하므로 기반 클래스를 변경하는 경우, 하위 클래스의 동작이 예기치 않게 바뀔 수도 있다는 면에서 기반 클래스는 취약하다. 위와 같은 문제를 고려해 코틀린의 클래스와 메소드는 기본적으로 final이다. 어떤 클래스의 상속을 허용하려면 클래스 앞에 open 변경자를 붙여야 한다. 그와 더불어 오버라이드를 허용하고 싶은 메소드 앞에도 open 변경자를 붙여야 한다. 123456789101112// open을 통해서 상속 가능하도록 열려 있음.open class RichButton: Clickable&#123; // final로 하위 클래스에서 오버라이드할 수 없다. fun disable() &#123; &#125; // open을 통해서 오버라이드 가능하도록 열려있다. open fun animate() &#123; &#125; // 상위 클래스에서 선언된 열려있는 메소드를 오버라이드한다. // 오버라이드한 메소드는 기본적으로 열려있다. override fun click() &#123; &#125;&#125; 주의해야 할 점은 기반 클래스나 인터페이스의 멤버를 오버라이드하는 경우 그 메소드는 기본적으로 열려있다. 오버라이드하는 메소드의 구현을 하위 클래스에서 오버라이드하지 못하게 금지하려면 오버라이드하는 메소드 앞에 final 변경자를 붙여 닫혀 있도록 만들어야 한다. 1234open class RichButton: Clickable &#123; final override fun click() &#123; &#125; // 이렇게 함으로써 오버라이드한 메소드는 열려있지 않게 된다.&#125; Tip스마트 캐스트는 타입 검사 뒤에 값이 변경될 수 없는 변수에만 적용이 가능하다. 클래스 프로퍼티의 경우 val이면서 커스텀 접근자가 없는 경우에만 사용할 수 있다는 의미다. 이 요구 사항은 프로퍼티가 final이어야만 한다는 뜻이기도 하다. final이 아니라면 그 프로퍼티를 다른 클래스가 상속하면서 커스텀 접근자를 정의함으로써 스마트 캐스트의 요구 사항을 깰 수도 있기 때문이다. abstract abstract를 사용해 추상 클래스를 선언할 수 있으며, 추상 클래스는 인스턴스화 할 수 없다. 구현이 없는 추상 멤버가 있어 하위 클래스에서 추상 멤버를 오버라이드 해야 한다. 추상 멤버는 항상 열려있다. 따라서 open을 명시할 필요가 없다. 1234567891011abstract class Animated &#123; abstract fun animate() open fun stopAnimating()&#123; &#125; fun animateTwice()&#123; &#125;&#125; 추상 클래스에 속하는 비추상 함수는 기본적으로 final이지만, 원한다면 open으로 오버라이드를 허용할 수 있다. 상속 제어 변경자 인터페이스 멤버의 경우 final, open, abstract를 사용하지 않는다. 인터페이스 멤버는 항상 열려있으며, final로 변경할 수 없다. 인터페이스 멤버에게 본문이 없으면 자동으로 추상 멤버가 되지만, 그래도 따로 abstract를 명시적으로 지정할 필요가 없다. final : 오버라이드할 수 없으며, 이는 클래스 멤버의 기본 변경자다. open : 오버라이드할 수 있으며, 반드시 open을 명시해야 오버라이드할 수 있다. abstract : 반드시 오버라이드해야 하며, 추상 클래스의 멤버에만 이 변경자를 붙일 수 있다. 추상 멤버에는 구현체가 있으면 안된다. override : 상위 클래스나 상위 인스턴스의 멤버를 오버라이드하는 것을 나타낸다. 오버라이드하는 멤버는 기본적으로 열려있다. 하위 클래스의 오버라이드를 금지하라면 final을 명시해야 한다. 가시성 변경자 : 기본적으로 공개 클래스 외부 접근을 제어한다. 어떤 클래스의 구현에 대한 접근을 제한함으로써 그 클래스에 의존하는 외부 코드를 깨지 않고도 클래스 내부 구현을 변경할 수 있다. public, protected, private이 있다. 기본 변경자는 모두 공개된다. 즉, public이다. 코틀린은 패키지를 가시성 제어에 사용하지 않는다. internal은 모듈 내부에서만 볼 수 있다는 뜻이다. 모듈 : 한 번에 한꺼번에 컴파일되는 코틀린 파일들을 의미한다. 자바에서는 패키지가 같은 클래스를 선언하기만 하면 외부의 다른 프로젝트에서 접근이 가능하기 때문에 캡슐화가 깨지기 쉽다. 하지만, 모듈 내부 가시성은 모듈의 구현에 대해 진정한 캡슐화를 제공한다는 장점이 있다. 최상위 선언에 대해 private 가시성을 허용한다. 코틀린의 가시성 변경자 public(기본) : 클래스 멤버와 최상위 선언 모두 모든 곳에서 볼 수 있다. internal : 클래스 멤버, 최상위 선언 모두 같은 모듈 안에서만 볼 수 있다. protected : 클래스 멤버는 하위 클래스 안에서만 볼 수 있으며, 최상위 선언에 적용할 수 없다. private : 클래스 멤버는 같은 클래스 안에서만 볼 수 있으며, 최상위 선언에 적용되면 같은 파일 안에서만 볼 수 있다. 유의해야할 점은 자바에서는 같은 패키지 안에서 protected 멤버에 접근할 수 있지만, 코틀린은 그렇지 않다는 것이다. 코틀린에서 protected 멤버는 오직 어떤 클래스나 그 클래스를 상속한 클래스 안에서만 보인다. 클래스를 확장한 함수는 그 클래스의 private이나 protected 멤버에 접근할 수 없다. 내부 클래스와 중첩된 클래스 클래스 안에 다른 클래스를 선언할 수 있다. 클래스 안에 다른 클래스를 선언하면 도우미 클래스를 캡슐화하거나 코드 정의를 그 코드를 사용하는 곳 가까이에 두고 싶을 때 유용하다. 코틀린의 중첩 클래스는 명시적으로 요청하지 않는 한 바깥쪽 클래스 인스턴스에 대한 접근 권한이 없다. 책의 예제 참고 자바에서는 클래스 안에 정의한 클래스는 자동으로 내부 클래스가 된다. 따라서 내부의 클래스는 바깥 클래스에 대한 참조를 묵시적으로 포함한다. 그 참조로 인해 내부 클래스를 직렬화할 수 없다. 바깥 클래스를 직렬화할 수 없으므로 바깥 클래스에 대한 참조가 내부 클래스의 직렬화를 방해한다. 자바의 내부 클래스 특징 살펴보기 문제를 해결하기 위해서는 내부 클래스를 static으로 선언해야 한다. 중첩 클래스를 static으로 선언하면 그 클래스를 둘러싼 바깥쪽 클래스에 대한 묵시적인 참조가 사라진다. 코틀린에서 중첩된 클래스가 기본적으로 동작하는 방식은 위와 반대이다. 1234567class Button: View &#123; override fun getCurrentState(): State = ButtonState() override fun restoreState(state: State) &#123; .. &#125; class ButtonState: State &#123; .. &#125;&#125; 코틀린 중첩 클래스에 아무런 변경자가 붙지 않으면 자바 static 중첩 클래스와 같다.(즉, 바깥쪽 클래스에 대한 참조가 없다.) 이를 내부 클래스로 변경해서 바깥쪽 클래스에 대한 참조를 포함하게 만들기 위해서는 inner 변경자를 붙이면 된다. 클래스 B 안에 정의된 클래스 A 자바에서는 코틀린에서는 중첩 클래스(바깥쪽 클래스에 대한 참조를 저장하지 않음) static class A class A 내부 클래스(바깥쪽 클래스에 대한 참조를 저장함) class A inner class A 클래스 계층을 만들되 그 계층에 속한 클래스의 수를 제한하고 싶은 경우 중첩 클래스를 쓰면 편리하다. 봉인됭 클래스 클래스 계층 정의 시 계층 확장 제한 아래에서는 상위 클래스인 Expr에 숫자를 표현하는 Num과 덧셈 연산을 표현하는 Sum이라는 두 하위 클래스가 존재한다. When 식에서 이 모든 하위 클래스를 처리하면 편리하지만, When 식에서 Num과 Sum이 아닌 경우를 처리하는 else 분기를 반드시 넣어야 한다.1234567891011interface Exprclass Num(val value: Int): Exprclass Sume(val left: Expr, val right: Expr): Expr fun eval(e: Expr) : Int = when(e)&#123; is Num -&gt; e.value is Sum -&gt; eval(e.right) + eval(e.left) else -&gt; throw IllegalArgumentException(\"Unknown expression\") &#125; 코틀린 컴파일러는 when을 사용해 Expr 타입의 값을 검사할 때 꼭 디폴트 분기인 else 분기를 덧붙이게 강제한다. 위의 코드는 else 분기에서 반환할 만한 의미 있는 값이 없으므로 예외를 던진다. 항상 디폴트 분기를 추가하는게 편하지 않다. 그리고 디폴트 분기가 있으면 클래스 계층에 새로운 하위 클래스를 추가하더라도 컴파일러가 when이 모든 경우를 처리하는지 제대로 검사할 수 없다. 혹여나 실수로 새로운 클래스에 대한 처리를 잊어버리더라도 디폴트 분기가 선택되기 때문에 심각한 버그가 발생할 수 있다. 이런 문제에 대한 해답은 sealed 클래스다. 상위 클래스에 sealed 변경자를 붙이면 그 상위 클래스를 상속한 하위 클래스 정의를 제한할 수 있다. sealed 클래스의 하위 클래스를 정의할 때는 반드시 상위 클래스 안에 중첩시켜야 한다. 12345678910sealed class Expr&#123; class Num(val value: Int): Expr() class Sume(val left: Expr, val right: Expr): Expr()&#125; fun eval(e: Expr) : Int = when(e) &#123; is Expr.Num -&gt; e.value is Expr.Sum -&gt; eval(e.right) + eval(e.left) &#125; when 식이 sealed 클래스의 모든 하위 클래스를 검사하므로 별도의 디폴트(else) 분기가 없어도 된다. sealed 클래스는 자동으로 open이 되어 상속 가능하다. 외부에 자신을 상속한 클래스를 둘 수 없다. sealed 클래스에 속한 값에 대해 디폴트 분기를 사용하지 않고 when 식을 사용하면 나중에 sealed 클래스의 상속 계층에 새로운 하위 클래스를 추가해도 when 식이 컴파일되지 않는다. 따라서 when 식을 고쳐야 한다. 내부적으로 Expr 클래스는 private한 생성자를 가진다. 그 생성자는 클래스 내부에서만 호출할 수 있다. sealed 인터페이스를 정의할 수는 없다. 왜그럴까? 봉인된 인터페이스를 만들 수 있다면 그 인터페이스를 자바 쪽에서 구현하지 못하게 막을 수 있는 수단이 코틀린 컴파일러에게 없기 때문이다. 코틀린 1.1부터는 sealed 클래스와 같은 파일의 아무데서나 상위 클래스를 상속한 하위 클래스를 만들 수 있고, 데이터 클래스로 하위 클래스를 정의할 수도 있다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"}]},{"title":"[Kotlin] 문자열과 정규식 다루기","slug":"Chap3-2","date":"2019-10-03T15:59:40.000Z","updated":"2019-10-04T06:34:26.272Z","comments":true,"path":"2019/10/04/Chap3-2/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/10/04/Chap3-2/","excerpt":"","text":"해당 포스팅은 코틀린 인 액션 책을 보며 정리한 내용입니다. 주관적인 생각이 포함되어 있으니 다른 의견이 있으시다면 적극적으로 알려주시면 감사합니다. 문자열과 정규식 다루기 다양한 확장 함수를 제공함으로써 표준 자바 문자열을 더 잘 다룰 수 있게 해준다. 1. 문자열 나누기 코틀린에서는 자바의 split 대신에 여러 가지 다른 조합의 파라미터를 받는 split 확장 함수를 제공한다. 이는 정규식을 파라미터로 받는 함수는 String이 아닌 Regex 타입의 값을 받는다. 아래는 마침표나 대시로 문자열을 분리하는 예이다.12345678println(\"12.345-6.A\".split(\"\\\\.|-\".toRegex()))// toRegex()를 통해 명시적으로 정규식을 만든다.// 결과 : [12, 345, 6, A]println(\"12.345-6.A\".split(\".\",\"-\"))// 간단한 정규식일 경우, 구분 문자열을 하나 이상 인자로 받는 오버로딩된 함수를 호출하면 된다.// 결과 : [12, 345, 6, A] 코드 다듬기 로컬 함수와 확장 코틀린에서는 함수에서 추출한 함수를 원 함수 내부에 중첩시킬 수 있다. 그렇게 하면 문법적인 비용을 들이지 않고도 깔끔하게 코드를 조직할 수 있다. 중복 코드를 로컬 함수를 통해 제거할 수 있다. 중복되는 부분을 함수로 작성하고 함수 내에서 중첩시켜서 로컬 함수로 만든다. 이를 통해 중복 부분을 제거할 수 있다. 하지만, 중첩된 함수의 깊이가 깊어지면 코드를 읽기 어려워진다. 따라서 일반적으로 한 단계만 함수를 중첩시킨다. 요약 자체 컬렉션 클래스를 정의하지 않지만, 자바 클래스를 확장해서 더 풍부한 API를 제공한다. 함수 파라미터의 디폴트 값을 정의하면 오버로딩한 함수를 정의하지 않아도 된다. 이름 붙인 인자를 사용해 함수 호출 시의 가독성을 높일 수 있다. 코틀린은 클래스 멤버가 아니라 최상위 함수와 프로퍼티를 직접 선언할 수 있다. 이를 활용해 코드 구조를 더 유연하게 만들 수 있다. 확장 함수와 프로퍼티를 사용하면 외부 라이브러리에 정의된 클래스를 포함해 모든 클래스의 API를 그 클래스의 소스 코드를 바꿀 필요 없이 확장할 수 있다. 확장 함수를 사용해도 실행 시점에 부가 비용이 들지 않는다. 중위 호출을 통해 인자가 하나 밖에 없는 메소드나 확장 함수를 더 깔끔한 구문으로 호출할 수 있다. 정규식과 일반 문자열을 처리할 때 다양한 문자열 처리함수를 제공한다. 3중 따옴표 문자열을 사용하면 이스케이프와 같은 처리를 깔끔하게 할 수 있다. 로컬 함수를 사용해 코드를 더 깔끔하게 유지하면서 중복을 제거할 수 있다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"}]},{"title":"[Kotlin] 함수 정의와 호출","slug":"Chap3-1","date":"2019-09-29T13:08:18.000Z","updated":"2019-10-04T05:35:19.373Z","comments":true,"path":"2019/09/29/Chap3-1/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/29/Chap3-1/","excerpt":"","text":"해당 포스팅은 코틀린 인 액션 책을 보며 정리한 내용입니다. 주관적인 생각이 포함되어 있으니 다른 의견이 있으시다면 적극적으로 알려주시면 감사합니다. 코틀린에서 컬렉션코틀린는 자체 컬렉션을 제공하지 않는다. 대신에 기존 자바의 컬렉션을 활용할 수 있다. 이는 자바 코드와 상호작용하기가 훨씬 쉽다는 것을 의미한다. 자바에서 코틀린 함수를 호출하거나 코틀린에서 자바 함수를 호출할 때 자바와 코틀린을 서로 변환할 필요가 없다. 하지만, 코틀린에서는 좀 더 다양한 기능을 제공하기도 한다. 예를 들면, 리스트에서 가장 마지막 원소를 가져오거나 수로 이뤄진 컬렉션에서 최대값을 찾을 수 있다. 이름 붙인 인자 매개변수가 많은 함수를 호출할 때, 내가 전달하는 인자가 어떤 역할을 하는지 확인하기 어려운 경우가 많다. 우리가 함수의 시그니처를 외우거나 IDE가 함수 시그니처를 표시해서 도움을 줄 수 있겠지만, 함수 호출 코드 자체는 여전히 모호하다. 코틀린에서는 이러한 문제를 해결하기 위해서 작성한 함수를 호출할 때는 함수에 전달하는 인자 중 일부(또는 전부)의 이름을 명시할 수 있다. 일반적으로 인자 중 어느 하나라도 이름을 명시하고 나면 혼동을 줄이기 위해 나머지 인자도 모두 이름을 붙여주는 것이 좋다. 1joinToString(collection, separator = \" \", prefix = \" \", postfix = \" \") 디폴트 파라미터 값 자바에서는 일부 클래스에서 오버로딩한 메소드가 많아진다는 문제가 있다. 오버로딩을 통해 편의를 줄 수 있지만, 많아진다면 결국 중복이라는 결과를 얻게 된다. 코틀린에서는 함수 선언에서 디폴트 파라미터 값을 지정할 수 있으므로 오버로드 중 상당수를 피할 수 있다. 함수를 선언하는 곳에서 지정된다. 위에서 함수 호출만 작성했던 joinToString() 함수를 작성해보자. 아무 접두사나 접미사 없이 콤마로 원소를 구분한다. 123456fun &lt;T&gt; joinToString( collection: Collection&lt;T&gt;, separator: String = \",\". prefix: String = \" \", postfix: String = \" \"): String 함수를 호출할 때, 모든 인자를 쓸 수도 있고 일부를 생략해서 쓸 수도 있다.12345678joinToString(list, \", \", \"\",\"\")// 결과 : 1, 2, 3joinToString(list)// 결과 : 1, 2, 3joinToString(list, \"; \")// 결과 : 1; 2; 3 이름 붙은 인자를 사용하면 인자 목록의 중간에 있는 인자를 생략하고 지정하고 싶은 인자를 이름을 붙여 순서와 상관없이 호출할 수 있다. 디폴트 값과 자바 자바에는 해당 개념이 없어서 코틀린 함수를 호출하는 경우에는 그 코틀린 함수가 디폴트 파라미터 값을 제공하더라도 모든 인자를 명시해야 한다. 그래서 자바에서 코틀린 함수를 자주 호출해야 한다면, 편하게 호출할 수 있는 방법에 대해 생각해봐야 한다. @JvmOverloads 어노테이션을 함수에 추가하면 코틀린 컴파일러가 자동으로 맨 마지막 파라미터부터 하나씩 생략한 오버로딩한 메소드를 추가해주어 자바에서 디폴트 파라미터를 사용하는 코틀린 함수를 쉽게 호출할 수 있다. 정적인 유틸리티 클래스 없애기 : 최상위 함수와 프로퍼티 코틀린에서는 함수가 클래스 안에 없어도 된다. 다양한 정적 메소드를 모아두며 특별한 상태나 인스턴스 메소드는 없는 클래스가 생겨난다. JDK의 Collections 클래스가 전형적인 예이다. 코틀린에서는 무의미한 클래스가 필요없다. 대신 함수를 직접 소스 파일의 최상위 수준, 모든 다른 클래스의 밖에 위치시키면 된다. 최상위 함수를 선언해보자. 아래와 같이 join.kt 파일을 만들어보자.1234package stringsfun joinToString()&#123; // 생략.&#125; 이 함수가 어떻게 실행될까? JVM이 클래스 안에 들어있는 코드만을 실행할 수 있기 때문에 컴파일러는 이 파일을 컴파일할 때 새로운 클래스를 정의해준다. 그러면 자바 등의 다른 JVM 언어에서 호출하고 싶다면 코드가 어떻게 컴파일되는지 알아야 joinToString과 같은 최상위 함수를 사용할 수 있다. 코틀린이 join.kt를 컴파일하는지 보여주기 위해 join.kt를 컴파일한 결과와 같은 클래스를 자바 코드로 써보면 다음과 같다. 123456package strings;public class JoinKt&#123; public static String joinToString()&#123; // 생략. &#125;&#125; 코틀린 컴파일러가 생성하는 클래스의 이름은 최상위 함수가 들어있던 코틀린 소스 파일의 이름과 대응한다. 코틀린 파일의 모든 최상위 함수는 이 클래스의 정적인 메소드(static)가 된다. 따라서 자바에서 joinToString()을 호출하기 쉽다.JoinKt.joinToString(list,&quot;, &quot;,&quot;&quot;,&quot;&quot;); 최상위 프로퍼티 함수와 마찬가지로 프로퍼티도 파일의 최상위 수준에 놓을 수 있다. 이런 프로퍼티의 값은 정적 필드에 저장된다. 최상위 프로퍼티를 활용해 코드에 상수를 추가할 수도 있다. const 키워드를 사용하면 프로퍼티를 public static final 즉, 상수로 선언할 수 있으며 이 필드로 컴파일하게 만들 수 있다.(단, 원시 타입과 String 타입의 프로퍼티만 const로 지정할 수 있다.)12345const val NUMBER = 10 public static final int NUMBER = 10; // 위의 두 문장은 같다. 확장 함수와 확장 프로퍼티 기존 코드와 코틀린 코드를 자연스럽게 통합하는 것은 어려운 목표다. 코틀린을 기존 자바 프로젝트에 통합하는 경우에는 코틀린으로 직접 변환할 수 없거나 미처 변환하지 않은 기존 자바 코드를 처리할 수 있어야 한다. 이런 기존 자바 API를 재작성하지 않고도 코틀린이 제공하는 여러 편리한 기능을 사용할 수 있다면 좋을 것이다. 바로 확장 함수 가 그런 역할을 해준다. 확장 함수는 어떤 클래스의 멤버 메소드인 것처럼 호출할 수 있지만, 그 클래스의 밖에 선언된 함수이다. fun String.lastChar(): Char = this.get(this.length - 1) 위의 함수는 문자열의 마지막 문자를 반환하는 함수이다. 확장 함수를 만드는 것은 간단하다. 추가하려는 함수 이름 앞에 그 함수가 확장할 클래스의 이름을 덧붙이면 된다. 클래스의 이름을 수신 객체 타입이라고 한다. 확장 함수가 호출되는 대상이 되는 값(객체) 수신 객체라 부른다. 위의 코드에서 String이 수신 객체 타입이고, this가 수신 객체이다. 수신 객체 타입 : 확장이 정의될 클래스 수신 객체 : 그 클래스에 속한 인스턴스 객체 12println(\"kotlin\".lastChar())// 호출 String이 어떤 언어로 작성되었는가는 중요하지 않다. 자바 클래스로 컴파일한 클래스 파일이 있는 한 그 클래스에 원하는 대로 확장을 추가할 수 있다. this를 생략할 수 있다. 1fun String.lastChar(): Char = get(length - 1) 확장 함수가 캡슐화를 깨지는 않는다. 클래스 안에서 정의한 메소드와 달리 확장 함수 안에서는 클래스 내부에서만 사용할 수 있는 private, protected 멤버를 사용할 수 없다. 호출하는 쪽에서는 확장 함수와 멤버 메소드를 구분할 수 없고, 호출하는 메소드가 확장 함수인지 멤버 메소드인지 여부가 중요하지 않다. 임포트와 확장 함수 확장 함수를 정의했다고 프로젝트의 모든 소스 코드에서 사용할 수 있는 건 아니다. 확장 함수를 사용하기 위해서 그 함수를 다른 클래스나 함수와 마찬가지로 임포트해야만 한다. 자바와 마찬가지로 임포트할 때 동일한 구문을 사용하면 된다. 개별 함수를 임포트할 수도 있으며, *를 사용한 임포트도 잘 작동한다. 그리고 as 키워드를 사용해 임포트한 클래스나 함수를 다른 이름으로 부를 수 있다.123import strings.lastCharimport strings.*import strings.lastChar as last 다른 여러 패키지에 이름이 같은 함수가 많은데 한 파일 안에서 그런 함수들을 함께 써야 하는 경우 이름을 바꿔서 임포트하면 편리하다. 일반적인 클래스나 함수라면 다른 방법도 있다. 해당 클래스나 함수를 부를 때 전체 이름을 쓰면 된다. 하지만, 확장 함수는 코틀린 문법상 반드시 짧은 이름을 써야 한다. 따라서 임포트시 이름을 바꾸는 방법이 확장 함수의 이름 충돌을 해결하는 좋은 방법이 된다. 자바에서 확장 함수 호출 내부적으로 확장 함수는 수신 객체를 첫 번째 인자로 받는 정적 메소드다. → 실행 시점 부가 비용이 들지 않는다. 자바에서 확장 함수를 사용하기 편리하다. 1char c = StringUtilKt.lastChar(\"Java\") 코틀린은 아래와 같다. 1val c = \"Java\".lastChar() 가변 인자 함수 인자의 개수가 달라질 수 있는 함수 정의 파라미터 앞에 vararg 변경자를 붙인다. 이미 배열에 들어있는 원소를 가변 길이 인자로 넘길 때도 코틀린과 자바 구문이 조금 다르다. 코틀린에서는 배열을 명시적으로 풀어서 배열의 각 원소가 인자로 전달되게 해야 한다. 기술적으로는 스프레드 연산자가 그런 작업을 해준다. 실제로 전달하려는 배열 앞에 *를 붙이면 된다.12345fun main(args: Array&lt;String&gt;)&#123; val list = listOf(\"args:\", *args) // 스프레드 연산자가 배열의 내용을 펼쳐준다. println(list)&#125; 값의 쌍 다루기 중위 호출과 구조 분해 선언 to는 중위 호출이라는 특별한 방식으로 to라는 일반 메소드를 호출한 것이다. 중위 호출 시에는 수신 객체와 유일한 메소드 인자 사이에 메소드 이름을 넣는다. (이때 객체, 메소드 이름, 유일한 인자 사이에는 공백이 들어가야 한다.) 아래의 두 호출은 동일하다. 12341.to(\"one\")// to 메소드를 일반적인 방식으로 호출함.1 to \"one\"// to 메소드를 중위 호출 방식으로 호출함. 인자가 하나뿐인 일반 메소드나 인자가 하나뿐인 확장 함수에 중위 호출을 사용할 수 있다. 함수(메소드)를 중위 호출에 사용하게 허용하고 싶으면 infix 변경자를 함수(메소드) 앞에 추가해야 한다. 이어지는 내용으로 to 함수는 Pair 인스턴스를 반환한다. 이는 코틀린 표준 라이브러리 클래스로 두 원소로 이루어진 쌍을 표현한다. Pair의 내용으로 두 변수를 즉시 초기화할 수 있다. 123456val (number, name) = 1 to \"Lee\"// 루프에서 구조 분해 선언 사용for ((index, element) in collection.withIndex())&#123; println(\"$index: $element\")&#125; 이와 같은 기능을 구조 분해 선언이라고 한다. 구조 분해 선언은 Pair나 Map 객체에서 key와 value를 분해해서 한 번에 변수를 담을 때 사용할 수 있다. 또한, 반복문과 같은 루프에서도 사용할 수 있다. to 함수는 타입과 관계 없이 임의의 순서쌍을 만들 수 있다. 즉, to의 수신 객체가 제네릭하다. listOf와 마찬가지로 mapOf에도 원하는 개수만큼 인자를 전달할 수 있지만, 각 인자가 키와 값으로 이뤄진 순서쌍이어야 한다.","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Kotlin/"}],"tags":[{"name":"코틀린 인 액션","slug":"코틀린-인-액션","permalink":"http://victorywoolee/victorywoolee.github.io/tags/코틀린-인-액션/"},{"name":"안드로이드","slug":"안드로이드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/안드로이드/"}]},{"title":"[ETC] 함수와 메소드의 차이","slug":"Function-Method-Dif","date":"2019-09-29T09:42:09.000Z","updated":"2019-09-29T09:49:24.251Z","comments":true,"path":"2019/09/29/Function-Method-Dif/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/29/Function-Method-Dif/","excerpt":"","text":"개발을 하다보면 함수와 메소드라는 말을 자주 접하고 듣는다. 어찌보면 개발자에게 있어서 없어서는 안되는 것이기도 하다. 그런데 어떤 상황에서는 함수라고 하고 어떤 상황에서는 메소드라고 한다. 둘의 차이가 뭔지 궁금해서 해당 글을 포스팅해본다. 함수(Function) 특정 작업을 수행하는 코드 조각이다. 전역이던 지역이던 독립된 기능을 수행하는 단위다. 함수가 메소드를 포함하고 있다. 함수가 더 포괄적인 개념이다. 메소드(Method) 클래스, 구조체, 열거형에 포함되어 있는 함수를 메소드라고 부른다. 다른말로 클래스 함수라고도 한다. 예제12345678910111213// 함수fun printFunction()&#123; println(\"Fuction\")&#125;class Person&#123; val name: String = \"Victory\" // 메소드 fun printMethod()&#123; println(\"$name Method\") &#125;&#125;","categories":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/categories/ETC/"}],"tags":[{"name":"함수","slug":"함수","permalink":"http://victorywoolee/victorywoolee.github.io/tags/함수/"},{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/tags/ETC/"},{"name":"메소드","slug":"메소드","permalink":"http://victorywoolee/victorywoolee.github.io/tags/메소드/"},{"name":"함수와 메소드 차이","slug":"함수와-메소드-차이","permalink":"http://victorywoolee/victorywoolee.github.io/tags/함수와-메소드-차이/"}]},{"title":"[Clean Code] 6장","slug":"CleanCode06","date":"2019-09-27T15:28:28.000Z","updated":"2019-09-29T09:40:00.689Z","comments":true,"path":"2019/09/28/CleanCode06/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/28/CleanCode06/","excerpt":"","text":"자료 추상화아래의 두 코드 차이를 살펴보자. 두 클래스 모두 2차원 점을 표현한다. 그런데 한 클래스는 구현을 외부로 노출하고 다른 클래스는 구현을 완전히 숨긴다. 구체적인 Point 클래스 1234public class Point&#123; public double x; public double y;&#125; 추상적인 Point 클래스 12345678public interface Point&#123; double getX(); double getY(); void setCartesian(double x, double y); double getR(); double getTheta(); void setPolar(double r, double theta);&#125; 추상적인 Point 클래스에서는 직교 좌표계를 사용하는지 극좌표계를 사용하는지 알 수 없다. 둘 다 아닐 수도 있다. 그럼에도 불구하고 인터페이스는 자료구조를 명백하게 표현한다. 사실, 자료 구조 이상을 표현한다. 클래스 메소드가 접근 정책을 강제한다. 또한, 좌표를 읽을 때는 각 값을 개별적으로 읽어야 한다. 하지만 좌표를 설정할 때는 두 값을 한꺼번에 설정해야 한다. 구체적인 Point 클래스는 직교좌표계를 사용하며 구현을 노출한다. 변수를 private으로 선언하더라도 각 값마다 조회, 설정 함수를 제공한다면 구현을 외부로 노출하는 셈이다. 변수 사이에 함수라는 계층을 넣는다고 구현이 감춰지지는 않는다. 구현을 감추기 위해서는 추상화가 필요하다. 그저 조회, 설정 함수로 변수를 다룬다고 클래스가 되지 않는다. 그보다는 추상 인터페이스를 제공해 사용자가 구현을 모른 채 자료의 핵심을 조작할 수 있어야 진정한 의미의 클래스다. 자료를 세세하게 공개하기보다는 추상적인 개념으로 표현하는 편이 좋다. 인터페이스나 조회,설정 함수만으로는 추상화가 이뤄지지 않는다. 개발자는 객체가 포함하는 자료를 표현할 수 있는 가장 좋은 방법을 심각하게 고민해야 한다. 아무 생각 없이 조회, 설정 함수를 추가하는 방법이 가장 나쁘다. 자료/객체 비대칭 객체는 추상화 뒤로 자료를 숨긴 채 자료를 다루는 함수만 공개한다. 자료 구조는 자료를 그대로 공개하며 별다른 함수는 제공하지 않는다. 아래는 객체 지향적인 도형 클래스다. area()는 다형성 메소드다. 그러므로 새 도형을 추가해도 기존 함수에 아무런 영향을 미치지 않는다. 반면, 새 함수를 추가하고 싶다면 도형 클래스 전부를 고쳐야 한다. 12345678910111213141516171819202122232425262728public class Square implements Shape&#123; private Point topLeft; private double side; public double area()&#123; return side * side; &#125;&#125;public class Rectangle implements Shape&#123; private Point topLeft; private double height; private double width; public double area()&#123; return height * width; &#125;&#125;public class Circle implements Shape&#123; private Point center; private double radius; public final double PI = 3.14159; public double area()&#123; return PI * radius * radius; &#125;&#125; 자료 구조를 사용하는 절차적인 코드는 기존 자료 구조를 변경하지 않으면서 새 함수를 추가하기 쉽다. 반면, 객체 지향 코드는 기존 함수를 변경하지 않으면서 새 클래스를 추가하기 쉽다. 절차적인 코드는 새로운 자료 구조를 추가하기 어렵다. 그러려면 모든 함수를 고쳐야 한다. 객체 지향 코드는 새로운 함수를 추가하기 어렵다. 그러려면 상속 받는 클래스에서 모든 클래스를 고쳐야 한다. 디미터 법칙 모듈은 자신이 조작하는 객체의 속사정을 몰라야 한다는 법칙이다. 객체는 자료를 숨기고 함수를 공개한다. 즉, 객체는 조회 함수로 내부 구조를 공개하면 안된다는 의미다. 그러면 내부 구조를 숨기지 않고 노출하는 셈이 된다. 좀 더 정확하게 표현해서 “클래스 C의 메소드 f는 다음과 같은 객체의 메소드만 호출해야 한다.“고 주장한다. 클래스 C f가 생성한 객체 f 인수로 넘어온 객체 C 인스턴스 변수에 저장된 객체 위 객체에서 허용된 메소드가 반환하는 객체의 메소드는 호출하면 안된다. 낮선 사람은 경계하고 친구랑만 놀라는 의미다. 기차 충돌 여러 객차가 한 줄로 이어진 기차처럼 보이는 코드이다. 일반적으로 조잡하다 여겨지는 방식이므로 피하는 편이 좋다. 흔히 아래와 같은 코드를 기차 충돌이라 부른다. 1final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath(); 위의 코드는 아래와 같이 나누는 편이 좋다. 123Options opts = ctxt.getOptions();File scratchDir = opts.getScratchDir();final String outputDir = scratchDir.getAbsolutePath(); 위의 코드에서는 함수 하나가 아는 지식이 굉장히 많다. 즉 함수가 많은 객체를 탐색할 줄 안다는 의미다. 위 코드가 디미터 법칙을 위반하는지 여부는 ctxt, Options, ScratchDir이 객체인지 아니면 자료 구조인지에 달렸다. 객체라면 내부 구조를 숨겨야 하므로 확실히 디미터 법칙을 위반한다. 반면, 자료구조라면 당연히 내부 구조를 노출하므로 디미터 법칙이 적용되지 않는다. 위 코드는 조회 함수를 사용해서 혼란을 일으킨다. 코드를 아래와 같이 구현했다면 디미터 법칙을 거론할 필요가 없어진다. 1final String outputDir = ctxt.options.scratchDir.absolutePath; 자료 구조는 무조건 함수 없이 공개 변수만 포함하고 객체는 비공개 변수와 공개 함수를 포함한다면 문제는 훨씬 간단하다. 하지만, 단순한 자료 구조에도 조회 함수와 설정 함수를 정의하라 요구하는 프레임워크와 표준이 존재한다. 잡종 구조 혼란으로 말미암아 절반은 객체, 절반은 자료 구조인 잡종 구조가 나온다. 이런 잡종 구조는 새로운 함수는 물론이고 새로운 자료 구조도 추가하기 어렵다. 단점만 모아놓았다. 그러므로 잡종 구조는 피하는 편이 좋다. 구조체 감추기 만약 위에서 사용했던 ctxt, options, scratchDir이 진짜 객체라면 앞의 예제처럼 줄줄이 사탕으로 엮어서는 안된다. 객체라면 내부 구조를 감춰야 하기 때문이다. 그렇다면 임시 디렉토리의 절대 경로는 어떻게 얻어야 좋을까? 다음 두 코드를 참고해보자.12ctxt.getAbsolutePathofScratchDirectoryOption();ctxt.getScratchDirectoryOption().getAbsolutePath(); 첫 번째 방법은 ctxt 객체에 공개해야 하는 메소드가 너무 많아진다. 두 번째 방법은 getScratchDirectoryOption()이 객체가 아니라 자료 구조를 반환한다고 가정한다. 어느 방법도 내키지 않는다. ctxt가 객체라면 뭔가를 하라고 말해야지 속을 드러내라고 말하면 안된다. 임시 디렉토리의 절대 경로는 왜 필요할까? 이유는 임시 파일을 생성하기 위한 목적이 있기 때문이다. 그렇다면 ctxt 객체에 임시 파일을 생성하라고 시키면 어떨까? 1BufferedOutputStream bos = ctxt.creteScratchFileStream(classFileName); 이는 객체에게 맡기기에 적당한 임무로 보인다. ctxt는 내부 구조를 드러내지 않으며, 모듈에서 해당 함수는 자신이 몰라야 하는 여러 객체를 탐색할 필요가 없다. 따라서 디미터 법칙을 위반하지 않는다.ㄴ 자료 전달 객체 자료 구조체의 전형적인 형태는 공개 변수만 있고 함수가 없는 클래스다. 자료 전달 객체(Data Transfer Object, DTO)라고 한다. 데이터베이스와 통신하거나 소켓에서 받은 메시지의 구문을 분석할 때 유용하다. 흔히 DTO는 데이터베이스에 저장된 가공되지 않은 정보를 애플리케이션 코드에서 사용할 객체로 변환하는 일련의 단계에서 처음으로 사용하는 구조체다. 활성 레코드 DTO의 특수형 형태다. 공개 변수가 있거나 비공개 변수에 조회/설정 함수가 있는 자료 구조지만, 대게 save나 find와 같은 탐색 함수도 제공한다. 활성 레코드는 데이터베이스 테이블이나 다른 소스에서 자료를 직접 변환한 결과다. 활성 레코드에 비즈니스 규칙 메소드를 추가하면 자료 구조도 아니고 객체도 아닌 잡종 구조가 나오기 때문에 이렇게 만드는 것은 바람직하지 않다. 활성 레코드는 자료 구조로 취급한다. 비즈니스 규칙을 담으면서 내부 자료를 숨기는 객체는 따로 생성한다. 결론 객체는 동작을 공개하고 자료를 숨긴다. 그래서 기존 동작을 변경하지 않으면서 새 객체 타입을 추가하기는 쉬운 반면, 기존 객체에 새 동작을 추가하기는 어렵다. 자료 구조는 별다른 동작 없이 자료를 노출한다. 그래서 기존 자료 구조에 새 동작을 추가하기는 쉬우나, 기존 함수에 새 자료 구조를 추가하기는 어렵다. 시스템을 구현할 때, 새로운 자료 타입을 추가하는 유연성이 필요하면 객체가 더 적합하다. 다른 경우로 새로운 동작을 추가하는 유연성이 필요하면 자료 구조와 절차적인 코드가 더 적합하다. 우수한 소프트웨어 개발자는 편견없이 이 사실을 이해해 직면한 문제에 최적인 해결책을 선택한다.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"객체와 자료구조","slug":"객체와-자료구조","permalink":"http://victorywoolee/victorywoolee.github.io/tags/객체와-자료구조/"}]},{"title":"[ETC] Freeze","slug":"Freeze","date":"2019-09-27T14:45:17.000Z","updated":"2019-09-27T15:04:40.602Z","comments":true,"path":"2019/09/27/Freeze/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/27/Freeze/","excerpt":"","text":"회사에서 들은 용어 중 Feture Freeze라는 말이 있다. 이 말을 들으면서 어떤 의미인지 알겠지만, 정확하게 정리가 안되서 간단하게 정리하고 넘어가려고 이 글을 작성한다. 해당 글은 필자의 생각을 바탕으로 작성한 글로 잘못된 내용이 포함되었을 수 있습니다. 의견이 있으면 댓글을 남겨주세요! Feature Freeze검색해보니까 한글로 된 자료는 거의 찾아보기 힘들다. Feature Freeze와 Code Freeze라는 용어가 있는데 필자가 생각하기에는 두 용어 거의 비슷한 것으로 보인다. 어떤 기능을 개발할 때, 브랜치를 나눠 작업을 한다. 이때, 브랜치를 Feature 단위로 나눈다고 한다. Feature가 하나의 작은 작업 단위라고 생각하면 될 것이다. 예를 들면, 로그인 기능을 개발한다고 하자. 간단하게 아래와 같은 작업이 필요할 것이다. 로그인 UI 작성 로그인 기능 구현 로그인 상태 판단 간단하게 생각나는 대로 적었을 때, 3개로 나눌 수도 있다. 더 쪼갤 수도 있고 2번과 3번을 합칠 수도 있다. 이때 작업 단위 하나 하나를 Feature라고 부른다. 그리고 로그인 기능이 이번에 배포에 포함된다고 해보자. 수요일이 정기 배포일이라고 한다면 배포에 포함될 기능들이 완료되어 feature 브랜치로 모여야 한다. 그리고 develop과 master에 merge가 되고 배포가 이루어져야 한다. 이 과정을 Feature Freeze 혹은 Code Freeze라고 한다. 배포를 하기 위해 진행했던 작업들(코드)이 합쳐지고 배포가 이루어지는 일련의 과정을 의미하는 것이다.","categories":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/categories/ETC/"}],"tags":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/tags/ETC/"},{"name":"Freeze","slug":"Freeze","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Freeze/"}]},{"title":"[Android] EditText","slug":"Android-EditText","date":"2019-09-27T14:24:29.000Z","updated":"2019-09-27T14:37:41.124Z","comments":true,"path":"2019/09/27/Android-EditText/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/27/Android-EditText/","excerpt":"","text":"EditTextAndroid에서 사용자 입력, 검색을 받기 위해서 EditText를 사용한다. 기본적으로는 키보드가 올라오면 엔터키 자리가 줄바꿈으로 되어있을 것이다. 하지만, 기획과 개발에서 요구하는 사항에 따라서 해당 엔터키가 특정 동작을 하길 원할 수도 있다. 나는 검색 관련 기능을 구현하면서 엔터키가 검색 버튼이며 검색 기능을 동작했으면 했다. 그래서 엔터키를 검색 아이콘으로 변경했다. xml과 코드 상에서 모두 변경 가능하며 아래는 xml에서 변경하는 방식이다. 1234567891011&lt;EditText android:id=\"@+id/search_query\" android:layout_width=\"0dp\" android:layout_height=\"wrap_content\" android:background=\"@color/transparent\" android:imeOptions=\"actionSearch\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintEnd_toStartOf=\"@id/btn_clear\" app:layout_constraintStart_toEndOf=\"@id/btn_back\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_goneMarginEnd=\"16dp\" /&gt; 그리고 엔터키가 검색 동작임을 확인해서 원하는 기능을 구현할 수 있다. 아래와 같이 리스너를 달아주어 어떤 이벤트인지와 입력되는 값을 캐치할 수 있다. 123456searchQuery.setOnEditorActionListener &#123; query, id, _ -&gt; if(EditorInfo.IME_ACTION_SEARCH == id)&#123; viewModel.searchDestination(query.text.toString()) &#125; true &#125; 리스너를 달아주고 들어오는 이벤트의 id가 위에서 설정했던 actionSearch와 같다면 viewModel의 쿼리를 날려 검색 결과를 보여주는 간단한 기능이다. 참고 imeOptions 종류","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"EditText","slug":"EditText","permalink":"http://victorywoolee/victorywoolee.github.io/tags/EditText/"}]},{"title":"[ETC] Super App","slug":"SuperApp","date":"2019-09-27T14:00:57.000Z","updated":"2019-09-27T14:23:05.724Z","comments":true,"path":"2019/09/27/SuperApp/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/27/SuperApp/","excerpt":"","text":"이 글은 슈퍼앱이라는 단어를 듣고 무엇인지 생각해보고 검색해서 어느 글을 참고해서 정리한 글입니다. 플랫폼의 시대는 저물고 있다.조금은 슬픈 이야기지만, 플랫폼의 시대는 저물고 있다. 2000년대와 2010년대 초반까지 가장 화두가 되는 키워드는 플랫폼이었다. ‘누가 세상에 없는 서비스를 만들어내는가?‘와 같은 여태까지 없던 새로움이 승부를 결정짓는 중요한 포인트였다. 페이스북, 유튜브, 위챗, 인스타그램 등과 같은 플랫폼은 각자의 장점을 가지고 오랜 기간동안 많은 사용자를 모았다. 이를 통해서 굉장한 가치를 쌓아나갔다. 하지만, 최근에는 많은 스타트업도 있고 이 중에서 플랫폼도 많이 늘어나고 있다. 그래서 포화상태에 이르렀다. 이 사이에서 새로움을 찾는 것은 힘들다. 말 그대로 플랫폼의 시대는 저물고 있으며, 이제는 기술력과 컨텐츠, 그리고 슈퍼앱의 시대가 오고 있다. PC? 이젠 모바일이지.2010년부터 빠르게 진행된 스마트폰 보급 덕분에 모바일 시장은 엄청난 속도로 성장했다. 그래서 모바일 개발자들도 많이 늘어났다. 어느 리서치의 결과에 따르면 모바일을 통한 소비가 2014년도를 기준으로 계속 성장하고 있음을 밝혔다. PC에서 모바일로 변화하게 된 가장 큰 원인은 접근성의 차이다. 스마트폰이 보편화됨에 따라 예전에는 PC 웹에서만 가능하던 일들이 이제는 손에 들려있는 핸드폰에서도 가능하게 되었기 때문이다. 정보 검색에서부터 자료 수집, 관련 자료 시청, 상품 주문, 결제까지 할 수 있게 되었다. 슈퍼앱?이제 슈퍼앱에 대해 이야기를 해보자. 검색을 하면 슈퍼앱이라는 단어가 위챗과 많은 연관이 있는 것으로 보인다. 그 이유는 위챗은 위챗 하나로 다른 앱들은 필요 없고 위챗에서 생활에 필요한 전반적인 서비스를 이용할 수 있게 만들기 위해 슈퍼앱으로 만들려는 목표를 가졌다고 한다. 스마트폰이 많이 활성화됨에 따라서 사람들의 일상 대부분은 스마트폰을 통해서 이루어진다. 음식 주문, 옷 결제, 연락, 약속 등등 대부분을 스마트폰으로 할 수 있다. 이런 편의를 제공하기 위한 앱들도 많다. 하지만, 앱이 너무 많아서 사용자들은 이런 저런 앱을 깔았다 지우기도 한다. 자주 사용하지 않는 앱의 경우 삭제할 가능성이 크다. 이와 같은 사용자의 불편함을 해소 할 수 있는 방안이 슈퍼앱인 것이다. 회사 생활을 하다보니 처음 들어보는 용어가 많다. 그리고 들어본 것 같지만 의미를 모르는 것도 많다. 이런 용어나 새로운 개념에 대해서도 정리하는 공간을 만들 것이다. 개발만 공부한다고 다가 아니라는 것을 느끼는 요즘이다.","categories":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/categories/ETC/"}],"tags":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/tags/ETC/"},{"name":"Super App","slug":"Super-App","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Super-App/"}]},{"title":"[Android] Two-Way Data Binding","slug":"Android-Two-Way-Binding","date":"2019-09-23T05:48:31.000Z","updated":"2019-09-27T13:59:35.700Z","comments":true,"path":"2019/09/23/Android-Two-Way-Binding/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/23/Android-Two-Way-Binding/","excerpt":"","text":"해당 글은 데이터 바인딩에 대한 사전 지식을 가지고 있으면 이해가 수월합니다. 위의 그림을 통해서 알 수 있듯이 View와 ViewModel이 데이터바인딩을 통해 느슨하게 연결되고 Model은 View가 아닌 ViewModel과 통신하게 된다. 원칙적으로 View는 ViewModel에게 일방적으로 작업을 던지고 ViewModel은 직접적으로 View를 알지 못하기 때문에 데이터바인딩을 통해서만 View가 갱신된다. 그래서 대부분의 상황에서 ViewModel의 변화로 인해 ViewModel -&gt; View 방향으로 전달되는 일방통행의 데이터바인딩이 만들어진다. 하지만, 그림에서도 볼 수 있듯이 반대의 경우도 가능하다. 2-way 데이터바인딩은 여기서 나오는 개념이며 양방향 데이터바인딩이라고도 한다. 이에 대해 알아보기 위해서 구글 공식 문서를 찾아봤지만, 생각보다 설명이 친절하지 않았다. 그래도 일단 공식 문서의 내용을 정리해보겠다. Google DeveloperTwo Way DataBinding은 다음과 같이 두 가지 방식으로 구현할 수 있다. ObservableField를 사용하는 방법 notifyPropertyChanged() 메소드를 사용하는 방법 1. @Bindable과 notifyPropertyChanged()를 사용하는 방법단방향 데이터바인딩을 사용해 xml의 속성에 값을 설정하고 해당 속성의 변경에 반응하도록 설정할 수 있다. 코드는 아래와 같다. 12345&lt;CheckBox android:id=\"@+id/rememberMeCheckBox\" android:checked=\"@&#123;viewmodel.rememberMe&#125;\" android:onCheckedChanged=\"@&#123;viewmodel.rememberMe&#125;\"/&gt; 체크 박스를 이용해서 처음 상태는 뷰모델의 rememberMe 상태로 초기화를 하고 변경되면 뷰모델의 rememberMe를 참조해서 속성의 변경에 반응하도록 설정할 수 있다. 양방향 데이터바인딩을 사용하면 위의 과정을 단축시킬 수 있다. 1234&lt;CheckBox android:id=\"@+id/rememberMeCheckBox\" android:checked=\"@=&#123;viewmodel.rememberMe&#125;\"/&gt; @={} 표기법은 = 표기법이 기존의 단방향 데이터바인딩과의 차이점이다. 그리고 이는 속성에 대한 데이터 변경사항을 수신하고 동시에 사용자 업데이트를 듣는다. 레이아웃에 있는 뒤쪽의 데이터의 변화에 반응하기 위해, 레이아웃 변수를 Observable 구현으로 만들 수 있다. 보통 BaseObservable()을 구현하고 코드에서 @Bindable 어노테이션을 사용한다. 12345678class User: BaseObservable()&#123; @get:Bindable var firstName: String = \"\" set(value) &#123; field = value notifyPropertyChanged(BR.firstName) &#125;&#125; 사용하려는 Class에서 BaseObservable을 상속받는다. firstName이라는 변수를 @get:Bindable 어노테이션을 이용해 바인딩을 통해서 값을 가져올 수 있도록 설정한다. 사용자 지정 set()을 사용해서 값을 할당하고 notifyPropertyChanged() 메소드를 통해서 데이터바인딩을 통해서 만들어진 파일에서 firstName이라는 변수가 변경되었다는 것을 알려서 갱신을 한다. 중요한 포인트는 set()할 때는 값을 할당하고 notifyPropertyChanged() 메소드를 통해서 변경되었다는 것을 알려주는 것이고, @get:Bindable 어노테이션을 통해서 접근이 가능하도록 연결 통로를 마련해줘야 한다. 2. ObservableField를 사용하는 방법 이 방법도 1번과 비슷한 방법이지만, 조금 다르다. @Bindable과 notifyPropertyChanged() 메소드를 사용하지 않는다. 대신에 사용하려는 프로퍼티를 ObservableField 타입으로 선언한다. 1234567891011class User: BaseObservable()&#123; var user: ObservableField&lt;String&gt; = ObservableField(\"\") fun getInformation(): String&#123; return user.get()!! &#125; fun setInformation(name: String)&#123; user.set(name) &#125;&#125; ObservableField를 이용할 때는 get() 메소드를 이용해서 프로퍼티의 값을 가져온다. 값을 할당할 때는 set() 메소드를 이용해서 프로퍼티에 값을 할당한다. 주의해야할 점은 ObservableField를 초기화할 때, 빈 생성자로 초기화를 하면 객체가 생성되지 않는다. 기본값을 넘겨주어 초기화를 진행해야 객체가 생성된다. ObservableField의 get() 메소드는 Nullable하기 때문에 주의해서 처리해야 한다. 형태와 값을 가져오고 할당하는 코드가 조금 다르지만 결국 같은 결과를 보여준다. 어떤 방법을 사용할지는 개발자의 몫이다. 조금 더 생각해보면 코드를 간단히 할 수도 있을 것 같다. 이 부분은 조금 더 생각해보기로 하자. ObservableField를 사용하는 경우, BaseObervable()을 상속받지 않고 프로퍼티를 선언만해서 사용하는 방법도 가능하다. 그리고 추가될 내용으로는 양방향 데이터바인딩에서 바인딩 어댑터를 사용하는 방법을 알아볼 예정이다. 참고 Google Developer Google Developer 안드로이드의 2-way 데이터바인딩","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Data Binding","slug":"Data-Binding","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Data-Binding/"},{"name":"Two way Binding","slug":"Two-way-Binding","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Two-way-Binding/"}]},{"title":"[Clean Code] 5장","slug":"CleanCode05","date":"2019-09-22T10:48:14.000Z","updated":"2019-09-22T12:21:28.153Z","comments":true,"path":"2019/09/22/CleanCode05/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/22/CleanCode05/","excerpt":"","text":"형식 맞추기와 관련된 내용입니다. 프로그래머라면 형식을 깔끔하게 맞춰 코드를 짜야한다. 코드 형식을 맞추기 위해 간단한 규칙을 정하고 그 규칙을 착실히 따라야 한다. 팀으로 일한다면 팀이 합의해 규칙을 정하고 모두가 그 규칙을 따라야 한다. 형식을 맞추는 목적 코드 형식을 중요하다. 이는 의사소통의 일환이다. 의사소통은 전문 개발자의 일차적인 의무다. 원활한 소통을 장려하는 코드 형식은 무엇일까? 생각해봐야 한다. 적절한 행 길이를 유지하라 코드의 길이가 길지 않게 유지하더라도 큰 규모의 시스템을 구축할 수 있다. 일반적으로 큰 파일보다는 작은 파일이 이해하기 쉽다. 신문 기사처럼 작성하라 이름은 간단하면서도 설명이 가능하게 짓는다. 이름만 보고도 올바른 모듈을 살펴보고 있는지 아닌지를 판단할 정도로 신경써서 짓는다. 소스 파일의 첫 부분은 고차원 개념과 알고리즘을 설명한다. 아래로 내려갈수록 의도를 세세하게 표현한다. 마지막에는 가장 저차원 함수와 세부 내역이 나온다. 개념은 빈 행으로 분리하라 거의 모든 코드는 왼쪽에서 오른쪽으로 그리고 위에서 아래로 읽힌다. 각 행은 수식이나 절을 나타내고 일련의 행 묶음은 완결된 생각 하나를 표현한다. 생각 사이는 빈 행을 넣어 분리해야 마땅하다. 빈 행은 새로운 개념을 시작하는 시각적 단서가 되면서 가독성을 높여준다. 세로 밀집도 바로 위의 줄바꿈이 개념을 분리한다면 세로 밀집도는 연관성을 의미한다. 즉, 서로 밀접한 코드 행은 세로 가까이 놓여야 한다는 뜻이다. 수직 거리 함수 연관 관계와 동작 방식을 이해하려고 어디에 있는지 찾고 기억하느라 시간과 노력을 소모하는 것은 낭비다. 서로 밀접한 개념은 세로로 가까위 둬야 한다. 물론 두 개념이 서로 다른 파일에 속한다면 규칙이 통하지 않는다. 하지만 타당한 근거가 없다면 서로 밀접한 개념은 한 파일에 속해야 마땅하다. 이게 바로 protected 변수를 피해야 하는 이유 중 하나다. 같은 파일에 속할 정도로 밀접한 두 개념은 세로 거릴 연관성을 표현한다. 여기서 연관성이란 한 개념을 이해하는데 다른 개념이 중요한 정도다. 연관성이 깊은 두 개념이 멀리 떨어져 있으면 코드를 읽는 사람이 소스파일과 클래스를 여기저기 뒤지게 되어 혼란스러워진다. 변수 선언 변수는 사용하는 위치에 최대한 가까이 선언한다. 루프를 제어하는 변수는 흔히 루프 문 내에 선언한다. 드물게 다소 긴 함수에서 블록 상단이나 루프 직전에 변수를 선언하는 사례도 있다. 인스턴스 변수 클래스 맨 처음에 선언한다. 변수간에 세로로 거리를 두지 않는다. 위치가 어디가 되었던 간에 잘 알려진 위치에 인스턴스 변수를 모은다는 사실이 중요하다. 종속 함수 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까에 배치한다. 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다. 그러면 프로그램이 더 자연스럽게 읽힌다. 이를 통해 모듈 전체의 가독성이 높아진다. 개념적 유사성 친화도가 높을수록 코드를 가까이 배치한다. 친화도가 높은 요인은 여러가지다. 위의 경우처럼 종속함수가 한 예가 된다. 변수와 그 변수를 사용하는 함수도 된다. 또한, 비슷한 동작을 수행하는 일군의 함수가 그 예가 된다. 세로 순서 일반적으로 함수 호출 종속성은 아래 방향으로 유지한다. 다시 말해, 호출되는 함수를 호출하는 함수보다 아래에 배치한다. 그러면 소스 코드 모듈이 고차원에서 저차원으로 자연스럽게 내려간다. 중요한 개념을 표현할 때는 세세한 사항을 최대한 배제한다. 세세한 사항은 가장 마지막에 표현한다. 그러면 독자가 소스 파일에서 첫 함수 몇개만 읽어도 개념을 파악하기 쉬워진다. 가로 형식 맞추기 프로그래머는 명백하게 짧은 행을 선호한다. 짧은 행이 바람직하다. 120자 정도의 행 길이를 제한하는 것이 추천된다. 가로 공백과 밀집도 가로로는 공백을 사용해 밀접한 개념과 느슨한 개념을 표현한다. 1234public void max(int a, int b)&#123; int size = a; return size*2 + b;&#125; 할당 연산자를 강조하려고 앞뒤에 공백을 줬다. 이로 인해 두 가지 주요 요소가 확실히 나뉜다는 사실이 더욱 분명해진다. 반면, 함수 이름과 이어지는 괄호 사이에는 공백을 넣지 않았다. 함수와 인수는 서로 밀접하기 때문이다. 공백을 넣으면 한 개념이 아니라 별개로 보인다. 가로 정렬 별로 유용하지 못하다. 이를 통해서 코드가 엉뚱한 부분을 강조해 진짜 의도가 가려진다. 인수 목록이 많아 코드가 가로로 길어진다면 정렬이 필요한게 아니라 목록 길이가 길기 때문에 목록을 정리해야 한다. 즉, 클래스를 쪼개야 한다. 들여 쓰기 범위로 이뤄진 계층을 표현하기 위해 코드를 들여쓴다. 왼쪽으로 코들르 맞춰 코드가 속하는 범위를 시각적으로 표현한다. 들여쓰기가 없다면 코드의 가독성이 현저하게 떨어진다. 들여쓰기한 파일은 구조가 한눈에 들어온다. 변수, 생성자 함수, 접근자 함수, 메소드가 금방 보인다. 들여쓰기 무시하기 때로는 간단한 if문, while문, 짧은 함수에서 들여쓰기 규칙을 무시하고픈 유혹이 생긴다. 이런 유혹에 빠질 때마다 코드를 들여쓰기 해야 한다. 그로 인해 코드가 더 명확하게 눈에 들어온다. 가짜범위 때로는 빈 while문, for문을 접한다. 이럴 때는 빈 블록을 올바로 들여쓰고 괄호로 감싼다. 세미콜론은 새 행에다 제대로 들여써서 넣어준다. 팀 규칙 팀은 한 가지 규칙에 합의해야 한다. 그리고 모든 팀원은 그 규칙을 따라야 한다. 그래야 소프트웨어가 일관적인 스타일을 보인다. 그로 인해 팀원 중 한명이 다른 사람의 코드 부분을 수정하더라도 일관성을 가지고 있기 때문에 읽기도 수월하며 수정하기도 어렵지 않을 것이다. 개개인이 따로국밥처럼 맘대로 짜대는 코드는 피해야 한다. 좋은 소프트웨어 시스템은 읽기 쉬운 문서로 이뤄진다는 사시를 기억해야 한다. 스타일은 일관적이고 매끄러워야 한다. 한 소스 파일에서 봤던 형식이 다른 소스 파일에도 쓰이리라는 신뢰감을 독자에게 줘야 한다. 온갖 스타일을 뒤섞어 소스 코드를 필요 이상으로 복잡하게 만드는 실수는 반드시 피한다.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"주석","slug":"주석","permalink":"http://victorywoolee/victorywoolee.github.io/tags/주석/"}]},{"title":"[Android] ripple","slug":"Android-ripple","date":"2019-09-22T03:54:56.000Z","updated":"2019-09-22T04:31:57.650Z","comments":true,"path":"2019/09/22/Android-ripple/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/22/Android-ripple/","excerpt":"","text":"안드로이드에서는 리플 효과라는 것이 있다. 사용자가 앱의 버튼이나 특정한 위젯을 클릭했을 때, 물결처럼 퍼져나가는 효과를 말한다. 이는 사용자가 터치를 했다는 것을 명확하게 보여주기 때문에 사용자에게 터치했다는 좋은 경험을 제공할 수 있다. 그래서 대부분의 앱들이 이러한 효과를 제공하고 있다. 그럼 리플 효과를 어떻게 적용할 수 있는지에 대해서 이야기해보려고 한다. 리플 효과버튼을 만들려고할 때, 디자인을 보고 xml에서 색상과 radius, 텍스트만 설정해서 구성할 수 있다면 클라이언트단에서 처리하는 편이 낫다. 이로 인해 리소스를 절약하고 용량도 어느정도는 작게 만들수 있기 때문이다. 그래서 xml에서 selector를 이용해서 원하는 모양을 작성하고 적용을 하기 위해서 background 속성을 이용하면 이쁘게 적용할 수 있다. 그러면 여기서 리플 효과는 어떻게 적용할까?? appcompat-v7 라이브러리에서 선택 가능한 항목의 터치 피드백을 플랫폼 버전엥 맞춰 쉽게 표시할 수 있도록 ?attr/selectableItemBackground라는 속성을 제공하고 있다. 하지만, 배경에 이 속성을 적용할 경우 해당하는 뷰에 다른 색상이나 모양, 혹은 이미지를 배경으로 함께 지정할 수 없어 레이아웃을 원하는 대로 구성할 수 없다. 위에서 작성한 xml을 적용할 수 없다는 뜻이다. 이와 같은 문제를 해결하기 위해서 터치 피드백이 다른 뷰의 가장 앞에 표시되도록 하면 될 것이다. android:foreground 속성을 사용해 해결할 수 있다. 터치 피드백이 필요한 곳에 아래와 같이 추가해주면 된다. background로 모양이나 색상을 정하지 않더라도 이를 사용하면 추후에 모양이나 색상이 추가되었을 때, 다른 수정을 할 필요가 없다. 앞으로 아래와 같이 사용하면 될 것이다. 1android:foreground=\"?selectableItemBackground\"","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"ripple","slug":"ripple","permalink":"http://victorywoolee/victorywoolee.github.io/tags/ripple/"}]},{"title":"[Android] Gradle","slug":"Android-Gradle","date":"2019-09-21T06:39:20.000Z","updated":"2019-09-21T07:57:08.567Z","comments":true,"path":"2019/09/21/Android-Gradle/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/21/Android-Gradle/","excerpt":"","text":"Grdle이란? 빌드 배포 도구 안드로이드 스튜디오와 빌드 시스템은 서로 독립적이다. 안드로이드 스튜디오 : 코드의 편집을 담당 Gradle : 빌드 빌드 프로세스를 자동화하고 관리, 유연한 맞춤형 빌드 구성을 정의할 수 있다. 3가지의 Gradle 파일이 있다. 1. Gradle 설정 파일(settings.gradle) 로트 프로젝트 디렉토리에 존재한다. 어떤 모듈을 포함할지를 Gradle에 알려준다. 1include &apos;:app&apos; 2. 최상위 빌드 파일(build.gradle) 루트 프로젝트 디렉토리에 최상위 파일로 프로젝트의 모든 모듈에 적용되는 빌드 구성을 정의한다. 모든 모듈에 공통되는 Gradle 저장소와 의존성을 정의하기 위해 buildscript 블록을 사용한다. 123456789101112buildscript&#123; repositories&#123; // gradle이 종속성을 검색하거나 다운로드하는 데 사용하는 레포지토리를 구성 &#125; dependencies&#123; // gradle이 사용하는 종속성을 정의 &#125;&#125;allprojects&#123; // 타사 플러그인 또는 라이브러리와 같이 모든 모듈이 사용하는 레포지토리 및 종속성을 구성하는 곳&#125; 3. 모듈 수준 빌드 파일(build.gradle) 해당 파일이 위치하는 특정 모듈의 빌드 설정을 구성 최상위 파일을 재정의할 수 있다. 1234567891011121314151617181920212223242526272829303132333435apply plugin: &apos;com.android.application&apos;// top-level에 선언되어야 하며, 안드로이드 플러그인을 gradle에 적용한다.android&#123; // 안드로이드와 관련된 빌드 설정을 한다. defaultConfig&#123; // AndroidManifest.xml에서 사용하는 설정에 대해 동적인 옵션을 주고 싶을 때, 이 블록 내에서 포함시킨다. // 예를 들면, versionCode, versionName 등 &#125; buildTypes&#123; // debug, release와 같이 빌드 타입을 지정할 수 있다. // 이외에도 alpha, beta 등등 &#125; flavorDimensions &quot;api&quot; // product flavor에 대한 그룹 productFlavors&#123; // 버전을 맞춤 설정하여 다양한 코드 및 리소스를 사용할 수 있으며, 모든 앱 버전에 공통되는 부분을 공유하거나 재사용할 수 있다. // flavorDimensions을 생성하고 동기화 진행 // 자신이 빌드 및 실행하고자 하는 것으로 변경 가능하다. &#125; lintOptions&#123; // 특정 lint 옵션을 구성할 수 있다. &#125; testOptions&#123; // text를 어떻게 실행하는지 방법에 대한 옵션을 지정한다. &#125;&#125;dependencies&#123; // 종속성을 관리한다. // 라이브러리를 추가하기 위해 수동으로 검색 및 다운로드 하지 않고 사용 가능하다.&#125; build variants 단일 프로젝트에서 다양한 버전의 앱을 생성하기 위해 사용한다. 각 build variants는 빌드할 수 있는 다른 버전의 앱을 나타낸다. build type과 product flavor에 구성된 설정, 코드 및 리소스를 조합한 결과 proguard 빌드 프로세스 중에 클래스를 축소하고 난독화 처리하기 위해 사용한다. 불필요한 메소드를 제거하여 멀티덱스를 피할 수 있다. 난독화 : 특정 언어로 작성된 코드를 읽기 어렵게 만드는 작업 디컴파일시 난독화가 되어 코드를 읽기 어렵다. 멀티 덱스 : 안드로이드 앱을 구성하는 코드는 컴파일되어 덱스 파일로 만들어진다. 하나의 덱스파일은 최대 65536개의 메소드만 참조 가능하다. 이를 초과하면 여러 개의 덱스 파일이 생성된다. 멀티 덱스를 사용할 수도 있지만, 빌드 과정에서 앱 내의 파일을 여러 개의 덱스 파일로 나누어야 하므로 빌드 속도가 느려지고 APK의 용량이 커지다. APK와 App Bundle APK : Android Package App Bundle : Application Bundle 두 가지 모두 여러 개의 흩뿌려져 있는 코드들을 안드로이드 기반 기기에서 독립적으로 실행 가능하도록 묶음으로 만드는 역할을 한다. APK가 커지는 이유 멀티 스크린을 지원하기 위해 이미지와 같은 리소스들이 증가 다국어를 지원하는 앱인 경우 String 파일 증가 자주 사용되지 않는 기능들의 증가 안드로이드 App Bundle은 새로운 업로드 방법으로 앱의 크기를 줄일 수 있다.기존에는 Play Console에 APK을 업로드하여 배포를 진행했지만, 새로운 배포 방법은 서명된 App Bundle을 Play Console로 배포하면 사용자의 기기에 맞는 언어, 리소스, CPU 아키텍처에 맞는 부분만 빌드하여 생성하기 때문에 사용자가 다운로드 받는 APK 용량을 줄일 수 있다. App Bundle? App Bundle은 APK와 비슷하지만 모든 코드, 리소스, CPU 아키텍처와 메타 데이터를 압축한 Zip 파일이다. 그래서 Google Play는 App Bundle에서 사용자 기기에 필요한 코드와 리소스만을 선택해 빌드될 수 있는 것이다. App Bundle을 빌드하면 .aab 파일이 생성된다. 빌드된 aab 파일을 Play Store에 업로드하면 Play Console이 사용자 각각의 디바이스에 최적화된 APK를 빌드한다. Dynamic Delivery? 사용자 기기에 필요한 리소스만을 다운로드 가능하게 해준다. Android 5.0(SDK 21) 이상부터 사용할 수 있다. Split APK 매커니즘을 이용한다. 이는 분리된 APK를 하나의 앱으로 만들어주는 것으로 여러가지 기능을 분리하고 나중에 기능이 필요할 때 다운로드 받아 설치된다. 따라서 Dynamic Delivery로 Google Play는 각 기기의 맞는 리소스만 빌드를 하고 기기에 설치되도록 한 다음에 사용자가 특정 기능을 필요로 할 때, 부분적으로 다운 받아서 사용할 수 있게 해주기 때문에 앱 용량을 줄일 수 있다. Base APK : 모든 APK가 접근할 수 있는 코드와 리소스가 포함된 APK이다. 앱의 기본 기능을 제공하고 사용자가 앱 다운로드를 요청하면 가장 처음 다운로드 받는 APK. Configuration APK : 기기에 설치될 때, 각 기기에 최적화된 화면 밀도(dpi)나 CPU 아키텍처, 다국어, 리소스와 네이티브 라이브러리가 포함된 APK이다. Google Play에서 자동으로 생성해준다. Dynamic feature APK : 사용자가 기기에 처음 설치할 때 필요하지 않지만, 나중에 추가로 설치할 수 있는 코드와 리소스가 들어있는 APK. 즉, 필요에 따라 동적으로 APK를 설치하여 사용자에게 추가 기능을 제공할 수 있다. 기본적으로 Google Play는 Base APK와 Configuration APK를 설치한다.예를 들어, 과거에는 다국어와 화면 사이즈를 대응하는 앱인 경우 APK를 빌드하고 서명 후 Play Console에 배포했다. 하지만, 지금은 App Bundle을 Google Play에 업로드하면 Google Play는 App Bundle의 메타데이터와 리소스에서 영어, xxhdpi 리소스만 빌드하여 base+en+xxhdpi으로 조합된 APK를 만든다. 이로 인해 사용자는 더 작고 최적화된 설치 파일을 다운로드 받을 수 있다.","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Gradle","slug":"Gradle","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Gradle/"},{"name":"Build","slug":"Build","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Build/"}]},{"title":"[Git] Git Flow 전략","slug":"Git-Flow","date":"2019-09-21T05:34:12.000Z","updated":"2019-09-21T06:22:52.962Z","comments":true,"path":"2019/09/21/Git-Flow/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/21/Git-Flow/","excerpt":"","text":"협업을 하면서 프로젝트를 진행하다보면 서로 같은 부분을 건드려서 개발하는 경우가 있다. 그리고 서로 다른 부분을 작업해 하나의 프로젝트에 합치는 경우도 많다. 이렇게 개발자가 협업을 할 때, 소스 코드의 버전 관리를 하기 위해서 Git을 사용하는데 여기에는 여러 전략이 있다. Github Flow 전략 Git Flow 전략 여기서 알아볼 전략은 Git Flow 전략이다.간단하게 말하면 브랜치를 효율적으로 관리하는 전략을 말한다. master branch 배포되었거나 배포될 소스가 저장되는 브랜치 master 브랜치는 배포될 때마다 태그만 달아주는 형식으로 관리한다. 예를 들어, 제품 1.0.0, 제품 1.2.1 등의 배포 버전이 있으면 해당 버전에 태그를 달아서 언제든 원하는 버전의 소스를 받아볼 수 있게 하는 역할을 한다. develop branch 다음 배포를 위해서 개발을 진행하는 브랜치다. 여러 명의 개발자가 함께 공유하면서 개발을 진행하는 브랜치다. 프로젝트 관점에서 보면 결국 개발이 진행되는 곳은 develop 브랜치다. 개발자 각각이 개발해야 하는 기능은 개발하기 전에 각자 자신의 로컬에 브랜치를 따로 생성해 개발을 진행하고 로컬 브랜치에서 개발이 완료되면 완료된 소스를 develop 브랜치에 푸시하거나 PR을 보내서 내부적인 코드 리뷰 후 merge 하는 것을 통해 개발이 진행된다. 위의 두 브랜치는 remote repository에서 항상 유지되는 브랜치이며, main branch라고 한다. feature branch 각 개발자에 의해 기능 단위의 개발이 진행되는 브랜치다. 여러 명의 개발자와 함께 프로젝트를 진행할 때, 요구사항에 있는 여러 기능을 적절하게 분배해서 개발자들과 일을 나눈다고 해보자. develop으로부터 feature 브랜치를 생성한다. 그리고 로컬에 기능을 위해 생성한 브랜치는 feature/login 브랜치다. 개발이 진행되면서 feature 브랜치로 merge를 한다. 모든 기능이 완료된 feature 브랜치는 develop으로 다시 merge되거나 push 된다. 위의 경우처럼 feature 브랜치를 로컬이 아닌 원격에 만들어서 관리해도 된다. 즉, 하나의 layer를 더 만든다고 생각하면 된다. 이렇게 함으로써 브랜치를 더 유연하게 만들어서 개발을 하면 적은 인원이 효율적으로 개발을 할 수 있다고 생각한다. hotfix branch 배포 버전에 생긴 문제로 긴급한 트러블 슈팅이 필요할 때 개발이 진행되는 브랜치다. 배포 버전에 문제가 발생해서 긴급하게 해당 기능만 수정이 필요할 때, 사용하는 브랜치다 실제 배포된 master 브랜치가 있고 이후에 개발이 지속적으로 진행된 develop 브랜치가 있는 상황이라고 가정해보자. 이때 배포된 버전에서 버그가 발생하면 어떻게 해야할까? develop 브랜치는 이미 다음에 배포될 버전이 충분히 개발된 버전이라 건들면 안된다. 이때는 배포된 master 브랜치에서 새로운 hotfitx 브랜치를 따고 문제가 생긴 코드를 고쳐서 master 브랜치에 merge한다. 아무래도 이미 배포된 버전에서 문제가 생겼기 때문에 즉각적으로 수정이 필요하다. 따라서 master로 직접 merge된다. 또한, 실제 출시된 버전에서 생긴 문제는 develop 브랜치에도 적용해야 한다. 운영에서 발견된 심각한 문제기 때문이다. release branch 내부적으로 배포할 준비가 되었다고 생각되는 소스가 저장되는 브랜치다. QA로 넘길 소스라고 보면된다. 요구되는 기능들을 모두 개발하고 내부적으로 배포하기 전에 테스트를 거치는 소스가 저장되는 브랜치다. 만약 QA 중에 문제가 발생하면 버그 픽스를 진행하고 버그가 제거된 release 소스를 중간에 develop 브랜치에 적용해 추가 개발을 이어갈 수 있다. 하지만 추가 기능 개발을 위해서 다시 develop 브랜치로 가지는 않는다. 만약 develop으로 버그가 수정된 소스가 가고 기능 개발을 한다면 그 기능은 이번 release가 아닌 다음 release 브랜치에 적용될 것이다. 모든 준비를 마치고 배포 가능한 상태가 되면 master 브랜치로 병합시키고, 병합한 커밋에 릴리즈 번호 태그를 추가한다.","categories":[{"name":"Git","slug":"Git","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Git/"},{"name":"Git Flow","slug":"Git-Flow","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Git-Flow/"}]},{"title":"[Android] 해상도","slug":"Android-Pixels","date":"2019-09-19T11:48:06.000Z","updated":"2019-09-21T04:38:35.419Z","comments":true,"path":"2019/09/19/Android-Pixels/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/19/Android-Pixels/","excerpt":"","text":"DIP(Device Independent Pixels) or DP 안드로이드에서 사용하는 독립적인 단위 수치 어떤 해상도에서도 같은 크기를 보여주는 것이 목적 DPI(Dot Per Inch) 1인치(2.54cm)에 들어가는 픽셀의 수 안드로이드에서는 160dpi를 기본 값으로 한다. px(pixel) 스크린의 실제 픽셀 단위를 사용한다. 실제 크기나 밀도와 상관 없다. 변환식 px = dp * (dpi/160) dp = px * (160/dpi) 160dpi인 해상도에서 1dp = 1px이다. 밀도 분류 160dpi = mdpi -&gt; 160 * 1 = 1dp = 1px 240dpi = hdpi -&gt; 160 * 1.5 = 1dp = 1.5px 320dpi = xhdpi -&gt; 160 * 2 = 1dp = 2px 480dpi = xxhdpi -&gt; 160 * 3 = 1dp = 3px 640dpi = xxxhdpi -&gt; 160 * 4 = 1dp = 4px 위의 그림은 구글 공식 문서에 있다. 안드로이드의 리소스 우선순위를 확인할 수 있다.자신에게 맞는 dpi 폴더를 먼저 읽고 해당 리소스가 없다면 가장 큰 dpi 폴더에서부터 작은 폴더순으로 읽으며 리소스를 찾는다. 최소 너비 사용 가능한 화면 영역의 가장 짧은 치수 기준으로 분류한다. swdp -&gt; sw320dp, sw600dp sw600dp로 분류된 레이아웃은 화면의 사용 가능한 영역 중, 가로 또는 세로 중 짧은 치수를 기준으로 600dp가 넘는 경우에만 접근이 가능하도록 한다.","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"해상도","slug":"해상도","permalink":"http://victorywoolee/victorywoolee.github.io/tags/해상도/"}]},{"title":"[Android] DI - Dagger2","slug":"Android-DI","date":"2019-09-19T11:46:46.000Z","updated":"2019-09-21T05:33:53.856Z","comments":true,"path":"2019/09/19/Android-DI/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/19/Android-DI/","excerpt":"","text":"해당 글은 DI와 관련된 공부 및 정리 글이며 추후에 내용이 추가될 가능성이 있습니다. DI Dependency Inject이라고 하면 의존성 주입을 의미한다. 구성요소 간의 의존 관계를 소스 코드 내부가 아닌 외부 설정 파일 등을 통해 정의되게 하는 디자인 패턴이다. 크게 3가지 유형으로 나누어 볼 수 있다. 생성자 주입 Setter를 통한 주입 Interface를 통한 주입 직접 의존성을 주입하는 형태의 클래스를 작성해도 되지만, 프로젝트의 규모가 커진다면 번거로운 작업이 된다. 그래서 이를 라이브러리로 넘겨서 대신 처리하도록 구현할 수 있다. 그 중에서도 Dagger와 관련해서 내용을 정리해보았다. Dagger2 Dagger의 핵심 키워드는 아래 그림과 같다. Module 의존성을 제공하는 @Provides 메소드를 가진 클래스에 이용한다. 모든 @Provides 메소드는 @Module 클래스 안에 속해야 한다. Provides 어떻게 의존성을 구성하고 제공하는지 정의하는 메소드에 사용한다. Module과 Provides는 공급자의 역할을 한다. Inject 의존성이 필요한 클래스에서 의존성 주입을 요청한다. @Inject 어노테이션으로 주입을 요청하면 연결된 Component가 Module로부터 객체를 생성하여 넘겨준다. 소비자의 역할을 한다. Component 연결된 Module을 이용해 의존성 객체를 생성하고, Inject로 요청받은 인스턴스에 생성한 객체를 주입한다. 의존성을 요청받고 주입하는 Dagger의 주된 역할을 수행한다. Module과 Inject 사이의 다리 역할을 한다. 인터페이스에만 사용한다. Scope 생성된 객체의 Lifecycle 범위를 뜻한다. 안드로이드에서는 주로 PerActivity, PerFragment 등으로 화면의 생명주기와 맞추어 사용한다. Module에서는 이 Scope을 보고 객체를 관리한다. Subcomponent Component는 계층 관계를 만들 수 있다. Subcomponent는 Inner Class 방식의 하위계층 Component이다. Sub의 Sub도 가능하다. 이는 Dagger의 중요한 컨셉인 그래프를 형성한다. Inject로 주입을 요청받으면 Subcomponent에서 먼저 의존성을 검색하고 없으면 부모로 올라가면서 검색한다. Qualifier 동일한 유형이지만 다른 인스턴스를 가진 객체를 구별하는데 사용된다. 주로 타입만으로 의존성을 식별하기 어려운 경우에 사용한다. 예를 들어, String과 같은 범용적인 타입일 경우 중첩될 수 있어서 이때 사용하면 된다. Flow@Inject -&gt; Subcomponent -&gt; Module -&gt; Scope에 있으면 return. 없으면 생성Subcomponent module에서 맞는 타입을 못찾으면 상위 Component -&gt; Module -&gt; Scope에 있으면 return. 없으면 생성. @Component를 구성하는 모든 @Module 클래스 목록을 작성해야 한다.아래와 같은 그림처럼 나타난다. Component를 구성하는 모든 Module 클래스 목록을 작성한다. 이를 통해서 Component는 Module과 연결되었다. 의존성 주입이 필요한 곳에서 @Inject를 통해 요청이 들어오면 해당 컴포넌트는 연결된 모듈 중에서 의존성을 제공할 수 있는 모듈이 있는지 검색한다. 제공할 수 있는 모듈이 있으면 Module에서 정의했던 메소드를 통해서 객체를 제공하게 된다. 그리고 주의해야할 점은 @Inject가 필요한 곳을 Component에 정의해야 한다는 것이다. 예를 들어, MainActivity에서 의존성 주입이 필요하다면 다음과 같이 Component에 정의해야 한다. 1234@Component(modules = [CatModule::class, DogModule::class])interface AnimalComponent&#123; fun inject(mainActivity: MainActivity)&#125; Component 인터페이스를 만들고 후에 build를 하면 Dagger는 이 인터페이스를 구현한 클래스를 자동으로 생성해준다. 생성된 클래스는 @Component 인터페이스 앞에 Dagger를 붙인채로 생성된다. 추가될 내용꽤 많은 블로그를 참고해 내용을 작성했는데, 주로 한글로 작성된 자료를 참고했다. 그래서 아래에 명시한 영어로 된 자료들을 참고해서 내용을 다시 정리할 예정이다.또한, Subcomponent와 관련된 내용도 더 숙지해서 정리할 필요가 있다. 참고1 참고2","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"DI","slug":"DI","permalink":"http://victorywoolee/victorywoolee.github.io/tags/DI/"},{"name":"Dagger2","slug":"Dagger2","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Dagger2/"}]},{"title":"[Android] WindowBackground","slug":"Android-WindowBackground","date":"2019-09-19T10:47:44.000Z","updated":"2019-09-19T11:44:09.018Z","comments":true,"path":"2019/09/19/Android-WindowBackground/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/19/Android-WindowBackground/","excerpt":"","text":"아래의 글을 읽어보면 어떻게 drawing을 더 빠르게 하고, activity의 시작 시간을 단축시킬 수 있는지 알 수 있다. 이는 window background drawable과 관련이 있다. setContentView()를 통해 Activity에 View를 붙이면, 이 View는 activity의 window에 붙게 된다. 하지만, window는 setContentView()를 통해 붙인 뷰만 붙이는 것이 아니다. 가장 중요한 것 중 하나인 DecorView를 붙이게 된다. DecorView는 window의 background Drawable을 가지고 있는 View다. getWindows().setBackgroundDrawable()을 호출하는 것은 실제로 DecorView의 background를 변경하여 window의 background가 변경되는 것과 같은 효과를 낸다. 하지만 이같은 설정은 추후에 version 혹은 device에 따라 달라질 수 있다. 기본 android theme를 사용한다면 default background drawable이 activity에 설정되어있다. 기본적으로는 ColorDrawable이 설정되어있다. 보통의 앱에서는 이 ColorDrawable이 DecorView에 설정되어 있는게 문제가 안된다. 하지만, drawing performance에는 영향을 줄 수도 있다. 아래는 불투명 그림이 activity 전체에 설정되어 있는 경우다. 그림에서 window background가 보이지 않는 것을 확인할 수 있다. 전부 불투명한 그림을 담고 있는 ImageView로 덮여있기 때문이다. 이 앱은 44fps가 나온다. 더 빨리 그리게 하기 위해서는 background drawable을 제거해주면 된다. 그림이 불투명이며 화면 전체를 차지하기 때문에 background는 낭비일 뿐이다. background를 제거함으로써 더 나은 퍼포먼스를 얻을 수 있다. background를 제거한 버전에서는 51fps가 나온다. 만약 default window backgroun가 더 큰 용량의 drawable일 경우에는 그 차이가 더 확연하게 난다. window background를 없애는 것은 custom theme를 적용하면 간단하게 해결된다.res/values/theme.xml을 만들고 아래와 같이 정의하면 된다. 12345&lt;resources&gt; &lt;style name=\"Theme.NoBackground\" parent=\"android:Theme\"&gt; &lt;item name=\"android:windowBackground\"&gt;@null&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; 위와 같은 theme을 activity나 application의 theme로 적용해주면 된다. 1android:theme=&quot;@style/Theme.NoBackground&quot; MapView나 WebView 같은 경우도 보통 activity를 꽉 채우며 불투명하기 때문에 이런 theme를 사용하는게 좋다. 이 방법은 Android UI toolkit이 가려진 drawable을 그리지 않을만큼 똑똑하지는 않기 때문이다. 보통 android application에서 이렇게 full screen 전부가 불투명한 경우가 많지 않기 때문에 이런 최적화를 framework 단에서 하지 않았다. 하지만 이것은 추후 구현에서 자동으로 그리지 않도록 최적화될 수 있다. 전체 바탕을 theme으로 설정함으로서 activity의 시작 시간을 단축시킬수 있는 것도 좋은 방법이다. 아래와 같은 상황이 적절한 예가 될 수 있다. 위와 같은 background가 onCreate에서 설정되거나 XML layout을 통해서 설정되었다면 activity의 시작은 처음에 검은 배경이 나온 후 해당 그림으로 바뀌는 방식으로 이루어질 것이다. 사용자는 이 background를 로드하는데 시간이 걸린다고 느낄 것이며, 깜빡이는 경험도 할 것이다. 이렇게 하는 대신 theme로 설정해서 custom backgrounㅇ를 깔아주면 activity의 시작시간도 단축할 수 있고, 이렇게 깜빡이는 느낌도 없앨 수 있다. 참고 [Android/안드로이드] Window Backgrounds &amp; UI Speed","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Window Background","slug":"Window-Background","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Window-Background/"}]},{"title":"[ETC] GNB","slug":"What-is-GNB","date":"2019-09-16T13:15:48.000Z","updated":"2019-09-16T13:18:43.413Z","comments":true,"path":"2019/09/16/What-is-GNB/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/16/What-is-GNB/","excerpt":"","text":"GNB란? Global Navigation Bar의 줄임말이다. 사이트 전체에 동일하게 적용되는 네비게이션 바를 의미한다. 즉, 어느 페이지에 들어가든 공통적으로 사용할 수 있는 메뉴를 뜻한다. 그래서 의존성을 줄이고 모듈로 만들어서 필요한 곳에 사용하도록 만든다. 최상위 메뉴로 보통 상단에 위치한다.","categories":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/categories/ETC/"}],"tags":[{"name":"ETC","slug":"ETC","permalink":"http://victorywoolee/victorywoolee.github.io/tags/ETC/"},{"name":"GNV","slug":"GNV","permalink":"http://victorywoolee/victorywoolee.github.io/tags/GNV/"}]},{"title":"[ConstraintLayout] 속성","slug":"Android-ConstraintLayout","date":"2019-09-16T05:05:48.000Z","updated":"2019-09-19T10:47:22.737Z","comments":true,"path":"2019/09/16/Android-ConstraintLayout/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/16/Android-ConstraintLayout/","excerpt":"","text":"안드로이드에서 뷰를 짤 때 사용하는 레이아웃은 많다.그 중에서 Constraint Layout은 이해하기 어렵지 않으며기존의 레이아웃들보다 좋은 기능을 많이 제공하고 있어 자주 사용된다. 유용한 속성들을 알아보자. 가이드 라인 뷰를 배치하기 위해 뷰그룹 내에 설정할 수 있는 일종의 기준선이다. 장점은 실제로는 이 선이 보이지 않는다는 것이다. 어떻게 보면 가상의 선을 기준으로 뷰를 배치할 수 있어서 편리하다. orientation을 통해 가로/세로 방향을 적용할 수 있다. 위치를 정하는 방법은 두 가지다. 일반적인 dp, px과 같은 수치를 적용하는 것 퍼센트를 적용하는 것 1. 수치를 적용하는 것 layout_constraintGuide_begin : begin의 경우 레이아웃 내에서 세로 가이드라인이라면 왼쪽(start)에서부터 얼만큼 떨어져있는지, 가로 가이드라인이라면 위에서부터 얼만큼 떨어져있는지를 뜻한다. layout_constraintGuide_end : end는 이와 반대로 세로는 오른쪽(end)에서부터, 가로는 아래에서부터 얼만큼 떨어져있는지를 적용하면 된다. 2. 퍼센트를 적용하는 것 layout_constraintGuidePercent : 0.0 ~ 1.0까지 적용할 수 있으며, 이때는 무조건 왼쪽이나 위쪽에서 시작한다고 생각하면 된다. 레이아웃 내부로부터 왼쪽에서 40% 지점에 세로로 된 가이드라인을 적용하려면 아래와 같이 하면 된다. 123456&lt;androidx.constraintlayout.widget.Guideline android:id=\"@+id/guide_line\" android:layout_width=\"1dp\" android:layout_height=\"wrap_content\" android:orientation=\"vertical\" app:layout_constraintGuide_percent=\"0.4\" /&gt; start vs left의 차이Android는 레이아웃 방향을 우아하게 변환하여 오른쪽에서 왼쪽으로(RTL) UI를 사용하는 언어와 아랍어, 히브리어와 같은 읽기 방향을 지원하는 사용자 인터페이스를 구축할 수 있는 API를 제공한다. 이를 설정하기 위해서는 매니페스트 파일에서 android:supportRtl의 값을 true로 설정해주면 된다. 그러면 시스템은 앱을 RTL 레이아웃으로 표시할 수 있도록 RTL API를 활성화할 것이다. RTL 레이아웃으로 표시할 때 앱의 UI를 최적화해야 하는 경우, 아래와 같은 최적화가 있다.1. 첫 번째 방법 레이아웃에서 left, right 방향을 start, end로 변경해야 한다. ex) android:layout_marginLeft -&gt; android:layout_marginStart 2. 두 번째 방법 RTL 레이아웃을 완벽하게 최적화하기 위해 ldrtl 리소스를 사용해 완전히 별개의 레이아웃 파일을 제공할 수 있다. 드로잉 가능한 자원에 매우 적합하므로 읽는 방향에 해당하는 방향에 맞는 그래픽을 제공할 수 있다. ex) 기본 레이아웃 파일은 /res/layout/에 저장하고, RTL 최적화 레이아웃은 /res/layout-ldtrl에 저장할 수 있다. 즉, start와 end 속성은 RTL을 지원하는 레이아웃에 사용된다. RTL을 지원하는 레이아웃에서는 left와 right가 우리의 입장에서 반대로 동작하기 때문에 이보다는 start와 end가 더 맞는 개념이라고 생각한다. 그래서 이를 도입해서 혼란을 방지하고자 한 것으로 보인다. 체인 개념은 간단하다. 단일축(가로축, 세로축)에서 위젯들이 그룹처럼 동작할 수 있도록 해준다. 최소 2개의 위젯이 서로 연결되어 있으면 체인 기능을 사용할 수 있다. 체인의 머리 : 체인의 가장 왼쪽(가로축일 경우) 혹은 가장 위쪽(세로축일 경우)에 있는 위젯이 체인의 머리가 된다. 체인의 여백은 체인의 스타일에 따라 달라진다. 체인의 스타일 체인의 머리는 연결된 뷰들 중 왼쪽과 위쪽이 우선순위를 갖는다. 주의할 점은 체인을 사용할 위젯들은 모두 서로 연결되어 있어야 한다는 점이다. 그래야 체인 조건이 성립되며 원하는 체인을 걸 수 있다. 배리어 다국어 지원을 하는 앱을 개발할 때 사용하면 유용하게 쓸 수 있다. 예를 들어, 세로로 2개의 텍스트뷰가 있다. 이 둘은 가로로 길어진다. 그리고 이 둘의 길이가 다를 때 더 긴쪽의 텍스트뷰 오른쪽에 뷰를 배치하고 싶을 때 사용하면 된다. barrierDirection : 왼쪽, 오른쪽의 기준을 설정할 수 있다. constraint_referenced_id : 기준시킬 뷰들의 아이디를 나열한다. 즉, 어떤 뷰가 상황에 따라서 길어지고 이 옆에 어떤 뷰를 또 배치해야할 때 유용하게 사용할 수 있을 것 같다. 그 중 하나의 예가 다국어같은 상황이다. 한 단어라도 다른 언어를 사용하면 굉장히 길어질 수 있기 때문에 이 상황에서 사용하면 예방할 수 있다. 참고 Google Developer Google Developer","categories":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Android/"},{"name":"Constraint Layout","slug":"Constraint-Layout","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Constraint-Layout/"}]},{"title":"[CleanCode] 4장","slug":"CleanCode04","date":"2019-09-15T09:45:54.000Z","updated":"2019-09-16T05:05:32.497Z","comments":true,"path":"2019/09/15/CleanCode04/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/15/CleanCode04/","excerpt":"","text":"이번에는 주석과 관련된 내용입니다.책에서는 코드와 관련해서 설명이 많이 나오지만, 코드를 모두 담기에는 어려워 일부분만 담았습니다.정확한 이해가 필요하시다면 책을 구매하는 것을 추천드립니다. 잘 달린 주석은 그 어떤 정보보다 유용하다. 경솔하고 근거 없는 주석은 코드를 이해하기 어렵게 만든다. 오래되고 조잡한 주석은 거짓과 잘못된 정보를 퍼뜨려 해악을 미친다. 부정확한 주석은 아예 없는 주석보다 훨씬 나쁘다. 주석은 나쁜 코드를 보완하지 못한다. 코드에 주석을 추가하는 이유는 코드 품질이 나쁘기 때문이다. 지저분하게 코드를 짰다면 주석을 다는게 아니라 코드를 정리해야 한다! 표현력이 풍부하고 깔끔하며 주석이 거의 없는 코드가 복잡하고 어수선하며 주석이 많이 달린 코드보다 훨씬 좋다. 코드로 의도를 표현하라! 코드로 의도를 표현하라! 주석으로 달려는 설명을 함수로 만들어 표현해도 충분하다. 12345// 직원에게 복지 혜택이 있는지 검사한다.if((employee.flags &amp;&amp; HOURLY_FALT) &amp;&amp; employee.age &gt; 65) if(employee.isEligibleForFullbenefis())// 위보다 아래 코드가 의도를 더 명확하게 표현한다. 좋은 주석 어떤 주석은 필요하거나 유익하다. 하지만 정말 좋은 주석은 주석을 달지 않을 방법을 찾아낸 주석이다. 법적인 주석 소스 파일 첫 머리에 들어가는 저작권 정보와 소유권 정보 정보를 제공하는 주석 기본적인 정보를 주석으로 제공하면 편리하다. 아래 주석은 추상 메소드가 반환할 값을 설명한다. 12protected abstract Responder responderInstance();// 테스트 중인 Responder 인스턴스를 반환한다. 하지만, 가능하다면 함수 이름에 정보를 담는 편이 더 좋다.예를 들어, 위 코드에서 함수 이름을 responderBeingTested로 바꾸면 주석이 필요없어진다. 의도를 설명하는 주석 때때로 주석은 구현을 이해학 도와주는 선을 넘어 결정에 깔린 의도까지 설명한다. 의미를 명료하게 밝히는 주석 때때로 모호한 인수나 반환값은 그 의미를 읽기 좋게 표현하면 이해하기 쉬워진다. 일반적으로는 인수나 반환값 자체를 명확하게 만드련 더 좋겠지만, 인수나 반환값이 표준 라이브러리나 변경하지 못하는 코드에 속한다면 의미를 명료하게 밝히는 주석이 유용하다. 결과를 경고하는 주석 다른 프로그래머에게 결과를 경고할 목적으로 주석을 사용한다. 아래는 특정 테스트 케이스를 꺼야 하는 이유를 설명한다. 1234// 여유 시간이 충분하지 않다면 실행하지 마십시오.public void _testWithReallyBigFile()&#123; ...&#125; 요즘은 위의 방식보다는 @Ignore 속성을 이용해 테스트 케이스를 꺼버린다. 구체적인 설명은 @Ignore 속성에 문자열로 넣어준다. JUnit4가 나오기 전에는 메소드 이름 앞에 _ 기호를 붙이는 방법이 일반적인 관례였다. TODO 주석 앞으로 할 일을 //TODO 주석으로 남겨두면 편하다. 이를 통해 함수를 구현하지 않은 이유와 미래 모습을 설명할 수 있다. 12345// TODO 현재는 필요하지 않다.// 체크 아웃 모델을 도입하면 함수가 필요하다.public VersionInfo makeVersion()&#123; return null;&#125; TODO 주석은 프로그래머가 필요하다 여기지만 당장 구현하기 어려운 업무를 기술한다. 예를 들면, 더이상 필요 없는 기능을 삭제하라는 알림, 누군가에 문제를 봐달라는 요청 등이다. TODO로 떡칠한 코드는 바람직하지 않다. 중요성을 강조하는 주석 자칫 대수롭지 않다고 여겨질 뭔가의 중요성을 강조하기 위해서도 주석을 사용한다. 예를 들면 다음과 같은 경우다. 123String listItemContent = match.group(3).trim();// trim()은 중요하다. 이 함수는 문자열에서 시작 공백을 제거한다.// 문자열에 시작 공백이 있다면 다른 문자열로 인식되기 때문이다. 공개 API에서 Javadocs 설명이 잘 된 공개 API는 참으로 유용하고 만족스럽다. 표준 자바 라이브러리에서 사용한 Javadocs가 좋은 예다. Javadocs가 없다면 자바 프로그램을 짜기가 아주 어렵다. 나쁜 주석 대다수 주석이 이 범주에 속한다. 일반적으로 대다수 주석은 허술한 코드를 지탱하거나, 엉성한 코드를 변명하거나, 미숙한 결정을 합리화하는 등 프로그래머가 주절거리는 독백에서 크게 벗어나지 못한다. 주절거리는 주석 특별한 이유 없이 의무감으로 혹은 프로세스에서 하라고 하니까 마지못해 주석을 단다면 전적으로 시간낭비다. 주석을 달기로 결정했다면 충분한 시간을 들여서 최고의 주석을 달도록 노력한다. 주석이 이해가 안되어 다른 모듈까지 뒤져야 하는 주석을 독자와 제대로 소통하지 못하는 주석이다. 같은 이야기를 중복하는 주석 함수를 보고 의미를 해석할 수 있지만, 주석으로 함수에 대한 설명을 한다. 심지어 함수보다 의미를 잘 전달하지 못한다. 없는게 더 낫다. 즉, 주석이 더 많은 정보를 제공하지 못한다. 코드를 정당화하는 주석도 아니고, 의도나 근거를 설명하는 주석도 아니다. 코드보다 읽기가 쉽지도 않다. 오해할 여지가 있는 주석 때때로 의도는 좋았으나 프로그래머가 딱 맞을 정도로 엄밀하게는 주석을 달지 못하기도 한다. 의무적으로 다는 주석 모든 함수에 Javadocs를 달거나 모든 변수에 주석을 달아야 한다는 규칙은 어리석기 그지없다. 이런 주석은 코드를 복잡하게 만들며, 거짓말을 퍼뜨리고 혼동과 무질서를 초래한다. 오히려 코드만 헷갈리게 만들며, 거짓말할 가능성을 높이며 잘못된 정보를 제공할 여지만 만든다. 이력을 기록하는 주석 예전에 사람들은 모듈을 편집할 때마다 모듈 첫머리에 주석을 추가한다. 그리하여 모듈 첫머리 주석은 지금까지 모듈에 가한 변경을 모두 기록하는 일종의 일지 혹은 로그가 된다. 이제는 그렇게 하지 않는다. 소스 코드 관리 시스템이 다양하기 때문이다. 완전히 제거하자. 있으나 마나 한 주석 너무 당연한 사실을 언급하며 새로운 정보를 제공하지 못하는 주석이 있다. 이는 제거해야 마땅하다. 무서운 잡음 때로는 Javadocs도 잡음이다. 함수나 변수로 표현할 수 있다면 주석을 달지 마라. 다음 코드를 살펴보자. 12// 전역 목록 &lt;smodule&gt;에 속하는 모듈이 우리가 속한 하위 시스템에 의존하는가?if(smodule.getDependSubsystems().contains(subSysMod.getSubSystem())) 위 코드에서 주석을 없애고 다시 표현하면 아래와 같다. 123ArrayLis moduleDependees = smoudle.getDependSubsystems();String ourSubSystem = subSysMod.getSubSystem();if(moduleDependees.contains(ourSubSystem)) 코드를 작성한 저자는 주석을 먼더 달고 주석에 맞춰 코드를 작성했는지도 모른다. 하지만 위와 같이 주석이 필요하지 않도록 코드를 개선하는 편이 낫다. 위치를 표시하는 주석 소스 파일에서 특정 위치를 표시하려 주석을 사용한다. 1// Actions //////////////// 위와 같은 배너 아래 특정 기능을 모아놓으면 유용한 경우도 있다. 하지만, 일반적으로 위와 같은 주석은 가독성만 낮추므로 제거해야 한다. 배너를 남용하면 흔한 잡음으로 여겨진다. 닫는 괄호에 다는 주석 닫는 괄호에 특수한 주석을 달기도 한다. 중첩이 심하고 장황한 함수라면 의미가 있을지도 모르지만 작고 캡슐화된 함수에는 잡음일 뿐이다. 그러므로 닫는 괄호에 주석을 달아야겠다는 생각이 든다면 대신에 함수를 줄이려 시도하자. 공로를 돌리거나 저자를 표시하는 주석 1/* Woo가 추가함 */ 소스 코드 관리 시스템(Git)은 누가 언제 무엇을 추가했는지 기억한다. 그래서 저자 이름으로 코드를 오염시킬 필요가 없다. 위와 같은 정보는 소스 코드 관리 시스템에 저장하는 편이 좋다. 주석으로 처리한 코드 주석으로 처리한 코드만큼 밉살스러운 관행도 드물다. 주석으로 처리된 코드는 다른 사람들이 지우기를 주저한다. 이유가 있어 남겨놓았으리라고, 중요하니까 지우면 안된다고 생각한다. 그래서 계속해서 쌓여만 간다. 안된다. 지우자! HTML 주석 HTML 주석은 혐오 그자체다. 주석을 읽기 쉬어야 하는 편집기/IDE에서조차 읽기가 어렵다. 전역 정보 주석을 달아야 한다면 근처에 있는 코드만 기술하라. 코드 일부에 주석을 달면서 시스템의 전반적인 정보를 기술하지 마라. 주석을 달 코드와 연관있는 주석을 달아야 한다. 너무 많은 정보 주석에 흥미로운 역사나 관련 없는 정보를 장황하게 늘어놓지 마라. 모호환 관계 주석과 주석이 설명하는 코드는 둘 사이 관계가 명백해야 한다. 이왕 공들여 주석을 달았다면 적어도 독자가 주석과 코드를 읽어보고 무슨 소린지 알아야 한다. 함수 헤더 짧은 함수는 긴 설명이 필요 없다. 짧고 한 가지만 수행하며 이름을 잘 붙은 함수가 주석으로 헤더를 추가한 함수보다 훨씬 좋다. 비공개 코드에서 Javadocs 공개 API는 Javadocs가 유용하지만 공개하지 않을 코드라면 Javadocs는 쓸모가 없다. 유용하지 않을 뿐만 아니라 Javadocs 주석이 요구하는 형식으로 인해 코드만 보기 싫고 산만해진다. 참고 Clean Code","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"주석","slug":"주석","permalink":"http://victorywoolee/victorywoolee.github.io/tags/주석/"}]},{"title":"[CleanCode] 3장","slug":"CleanCode03","date":"2019-09-15T04:20:20.000Z","updated":"2019-09-15T04:23:40.600Z","comments":true,"path":"2019/09/15/CleanCode03/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/15/CleanCode03/","excerpt":"","text":"해당 글은 Clean Code 책을 보면서 내용을 간단하게 정리한 글입니다.문제가 된다면 바로 삭제하도록 하겠습니다. 작게 만들어라! 함수를 만드는 첫째 규칙은 ‘작게’이다. 두번째 규칙은 ‘더 작게’이다. 함수가 하나의 이야기만을 표현하며 짧아야 한다. 블록과 들여쓰기 if문, else문, while문에 들어가는 블록은 한 줄이어야 한다는 의미이다. 대개 거기서 함수를 호출한다. 그러면 바깥을 감싸는 함수가 작아질 뿐 아니라, 블록 안에서 호출하는 함수 이름을 적절히 짓는다면, 코드를 이해하기도 쉬워진다. 즉, 중첩 구조가 생길만큼 함수가 커져서는 안된다는 뜻이다. 함수에서 들여쓰기 수준은 1단이나 2단을 넘어서면 안된다. 그래야 함수는 읽고 이해하기 쉬워진다. 한가지만 해라! 함수는 한 가지를 해야 한다. 그 한가지를 잘해야 한다. 그 한가지만을 해야 한다. 지정된 함수 이름 아래에서 추상화 수준이 하나인 단계만 수행한다면 그 함수는 한 가지 작업만 한다. 함수가 한 가지만 하는지 판단하는 방법이 있다. 단순히 다른 표현이 아니라 의미 있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 여러 작업을 하는 셈이다. 함수당 추상화 수준은 하나로! 함수가 확실히 ‘한 가지’ 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다. 위에서 아래로 코드 읽기: 내려가기 규칙 코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다. 즉, 위에서 아애로 프로그램을 읽으면 추상화 수준이 한 번에 한 단계씩 낮아진다. 서술적인 이름을 사용하라! 워드는 “코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드라 불러도 된다.” 한 가지만 하는 함수에 좋은 이름을 붙인다면 이런 원칙을 달성함에 있어 성공했다. 함수가 작고 단순할수록 서술적인 이름을 고르기가 쉬워진다. 길고 서술적인 이름이 짧고 어려운 이름보다 좋다. 길고 서술적인 이름이 서술적인 주석보다 좋다. 함수 이름을 정할 때는 여러 단어가 쉽게 읽히는 명명법을 사용한다. 그런 다음, 여러 단어를 사용해도 함수 기능을 잘 표현하는 이름을 선택한다. 이름을 붙일 때는 일관성이 있어야 한다. 함수 인수 함수에서 이상적인 인수 개수는 0개이다. 다음은 1개이고, 그 다음은 2개이다. 3개는 가능한 피하는 편이 좋다. 4개 이상은 특별한 이유가 필요하다. 인수는 개념을 이해하기 어렵게 만든다. 최선은 입력 인수가 없는 경우이며, 차선은 입력 인수가 1개뿐인 경우다. 많이 쓰는 단항 형식 함수에 인수 1개를 넘기는 이유는 가장 흔한 경우 두 가지이다. 1.하나는 인수에 질문을 던지는 경우다. boolean fileExists(“file”) 2.다른 하나는 인수를 뭔가로 변환해 결과를 반환하는 경우다. InputStream fileOpen(“file”) 명령과 조회를 분리하라. 다소 드물게 사용하지만, 아주 유용한 단항 함수 형식이 이벤트다. 이벤트 함수는 조심해서 사용한다. 이벤트라는 사실이 코드에 명확하게 드러나야 한다. 입력 인수를 변환하는 함수라면 변환 결과는 반환값으로 돌려준다. 플래그 인수 플래그 인수는 추하다. 함수로 부울 값을 넘기는 관례는 정말 끔찍하다. 왜냐면 함수가 한꺼번에 여러 가지를 처리한다고 알려주는 셈이기 때문이다. 플래그 인수를 사용해서 여러 가지 일을 처리하기 보다는 함수를 쪼개서 작은 일 하나를 함수로 처리하는 것이 낫다. 이항 함수 인수가 2인 함수는 인수가 1개인 함수보다 이해하기 어렵다. 예를 들어, writeField(name)는 writeField(outputStream, name)보다 이해하기 쉽다. 둘다 의미는 명백하지만 전자가 더 쉽게 읽히고 더 빨리 이해된다. 이항 함수가 무조건 나쁘다는 소리는 아니다. 프로그램을 짜다 보면 불가피한 경우도 생긴다. 하지만, 그만큼 위험이 따른다는 사실을 이해하고 가능하면 단항 함수로 바꾸도록 애써야 한다. 삼항 함수 인수가 3개인 함수는 인수가 2개인 함수보다 훨씬 더 이해하기 어렵다. 순서, 주춤, 무시로 야기되는 문제가 두 배 이상 늘어난다. 삼항 함수를 만들 때는 신중히 고려해야 한다. 인수 객체 인수가 2-3개 필요하다면 일부를 독자적인 클래스 변수로 선언할 가능성을 짚어보자. 예를 들어, 다음 두 함수를 살펴보자. Circle makeCircle(double x, double y, double radius); Circle makeCircle(Point center, double radius); 위의 함수처럼 객체를 생성해 인수를 줄이는 방법이 눈속임이라 여겨질지 모르지만 그렇지 않다. 이전 예제에서 x와 y를 묶었듯이 변수를 묶어 넘기려면 이름을 붙여야 하므로 결국은 개념을 표혀하게 되는 것이다. 인수 목록 때로는 인수 개수가 가변적인 함수도 필요하다. String.format 메소드가 좋은 예다. String.format(“%s worke %.2f hours.”, name, hours); 위 예제처럼 가변 인수 전부를 동등하게 취급하면 List형 인수 하나로 취급할 수 있다. 이런 논리의 측면에서 String.format은 사실 이항 함수이다. 가변 인수를 취하는 모든 함수는 같은 원리가 적용된다. 가변 인수를 취하는 함수는 단항, 이항, 삼항 함수로 취급할 수 있다. 하지만 이를 넘어서는 인수를 사용할 경우 문제가 된다. void monad(Integer… args); void dyad(String name, Integer… args); 동사와 키워드 함수의 의도나 인수의 순서와 의도를 제대로 표현하려면 좋은 함수 이름이 필수다. 단항 함수는 함수와 인수가 동사, 명사 쌍을 이뤄야 한다. write(name) → 이름을 쓴다. writeField(name) → 이름이 필드. 위의 함수보다 더 명확해서 좋다. 함수 이름에 키워드를 추가해보자. assertEquals보다 assertExpectedEqualsActual(expected, actual)이 더 좋다. 그러면 순서를 기억하지 않아도 함수 이름으 보고 유추할 수 있다. 부수 효과를 일으키지 마라! 함수에서 한가지를 하겠다고 약속하고선 남몰래 다른 짓을 하면 안된다. 때로는 예상치 못하게 클래스 변수를 수정한다. 때로는 함수로 넘어온 인수나 시스템 전역 변수를 수정한다. 어느쪽이든 교활하고 해로운 거짓말이다. 많은 경우 시간적인 결합이나 순서 종속성을 초래한다. 시간적인 결합이 필요한 경우 함수 이름에 명시해야 한다. 출력 인수 일반적으로 출력 인수는 피해야 한다. 함수에서 상태를 변경해야 한다면 함수가 속한 객체 상태를 변경하는 방식을 선택한다. 명령과 조회를 분리하라! 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야 한다. 둘 다 하면 안된다. 객체 상태를 변경하거나 아니면 객체 정보를 반환하거나 둘 중 하나만 해야 한다. 둘 다 하게 된다면 의미가 모호해지기 때문이다. 그래서 명령과 조회를 분리해 혼란을 없애는 게 좋다. 오류 코드보다 예외를 사용하라! 명령 함수에서 오류 코드를 반환하는 방식은 명령/조회 분리 규칙을 미묘하게 위반한다. 자칫하면 if문에서 명령을 표현식으로 사용하기 쉬운 탓이다. 오류 코드를 사용하게 되면 오류가 발생했을 때, 즉시 처리해야 한다. 그러면 if문이 중첩되어서 가독성이 떨어지게 된다. 이를 오류 코드 대신 예외를 사용하면 오류 처리 코드가 원래 코드에서 분리되므로 깔끔해진다. Try/Catch 블록 뽑아내기 try/catch 블록은 원래 추하다. 코드 구조에 혼란을 일으키며, 정상 동작과 오류 처리 동작을 뒤섞는다. 그러므로 try/catch 블록을 별도의 함수로 뽑아내는 편이 좋다. 123456789101112131415161718public void delete(Page page)&#123; try&#123; deletePageAndAllReferences(page); &#125; catch(Exception e)&#123; logError(e); &#125;&#125;private void deletePageAndAllReferences(Page page) throws Exception&#123; deletePage(page); registry.deleteReference(page.name); configKeys.deleteKey(page.name.makeKey());&#125;private void logError(Exception e)&#123; logger.log(e.getMessage());&#125; 위에서 delete 함수는 모든 오류를 처리한다. 그래서 코드를 이해하기 쉽다.실제로 페이지를 제거하는 함수는 deletePageAndAllReferences() 함수이다.deletePageAndAllReferences 함수는 예외를 처리하지 않는다.이렇게 정상 동작과 오류 처리 동작을 분리하면 코드를 이해하고 수정하기 쉬워진다. 오류 처리도 한 가지 작업이다. 함수는 한 가지 작업만 해야 한다. 오류 처리도 한 가지 작업에 속한다. 그러므로 오류를 처리하는 함수는 오류만 처리해야 한다. 반복하지 마라! 중복은 문제다. 코드 길이가 늘어날 뿐 아니라 알고리즘이 변하면 네 곳이나 손을 봐야 한다. 중복을 없앴더니 모듈 가독성이 크게 높아졌다. 중복은 소프트웨어에서 모든 악의 근원이다. 객체 지향 프로그래밍은 코드를 부모 클래스로 올려서 중복을 없앤다.","categories":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/categories/Clean-Code/"}],"tags":[{"name":"Clean Code","slug":"Clean-Code","permalink":"http://victorywoolee/victorywoolee.github.io/tags/Clean-Code/"},{"name":"함수","slug":"함수","permalink":"http://victorywoolee/victorywoolee.github.io/tags/함수/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-09-13T03:13:02.479Z","updated":"2019-09-13T03:13:02.479Z","comments":true,"path":"2019/09/13/hello-world/","link":"","permalink":"http://victorywoolee/victorywoolee.github.io/2019/09/13/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}